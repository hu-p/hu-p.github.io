<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于React-native+Taro开发</title>
    <link href="./2023/04/16/%E5%9F%BA%E4%BA%8Ereact-native%20+%20taro%E5%BC%80%E5%8F%91/"/>
    <url>./2023/04/16/%E5%9F%BA%E4%BA%8Ereact-native%20+%20taro%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="基于React-native-Taro开发"><a href="#基于React-native-Taro开发" class="headerlink" title="基于React-native+Taro开发"></a>基于React-native+Taro开发</h1><p>**开发平台：Windows **</p><p><strong>目标平台：Android</strong></p><p>本文基于对<a href="https://reactnative.cn/"><strong>React Native 中文网</strong></a>及<a href="https://taro.jd.com/"><strong>Taro官网</strong></a>总结环境搭建，并记录开发过程中遇到的问题</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>必须安装的依赖有：<strong>Node</strong>、<strong>JDK</strong> 和 <strong>Android Studio</strong>。</p><p>虽然你可以使用<code>任何编辑器</code>来开发应用（编写 js 代码），但你仍然<strong>必须安装 Android Studio <strong>来获得编译 Android 应用所需的</strong>工具</strong>和<strong>环境</strong>。</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a><a href="https://nodejs.org/en">Node</a></h4><p>版本应大于等于 14，使用Node建议使用安装<a href="https://github.com/coreybutler/nvm-windows/releases"><strong>nvm</strong></a>控制node版本，使用nrm控制镜像源及查看当前镜像源延迟</p><blockquote><p>注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！</p></blockquote><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a><a href="https://www.oracle.com/cn/java/technologies/downloads/">JDK</a></h4><p>react-native新版本不再支持<strong>jdk1.7</strong>和<strong>jdk1.8</strong>,需要 Java Development Kit [JDK] 11。你可以在命令行中输入 <code>javac -version</code>（请注意是 javac，不是 java）来查看你当前安装的 JDK 版本。如果版本不合要求，则可以去<a href="https://adoptium.net/?variant=openjdk11&jvmVariant=hotspot">Temurin</a>或<a href="https://www.oracle.com/java/technologies/downloads/#java11">Oracle JDK</a>上下载(后者下载需注册登录)</p><blockquote><p>低于 0.67 版本的 React Native 需要 JDK 1.8 版本（官方也称 8 版本）。</p></blockquote><h4 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a><a href="https://developer.android.google.cn/studio/features?hl=zh-cn">Android Studio</a></h4><p>Android Studio安装可直接参考<a href="https://reactnative.cn/docs/environment-setup#android-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><strong>React Native 中文网 Android 开发环境</strong></a></p><p>可通过查看设备命令行**<code>adb devices</code>**判断环境是否安装成功</p><blockquote><p>需要注意配置<code>环境变量</code>时<code>%ANDROID_HOME%</code>不生效时可替换成<code>%ANDROID_SDK_ROOT%</code>,根据文档规定配置<code>%ANDROID_HOME%</code>即可，但是笔者在配置过程中首次使用<code>%ANDROID_HOME%</code>，导致<code>platform-tools</code>中<code>adb devices</code>只有首次生效，后调整成<code>%ANDROID_SDK_ROOT%</code>排除bug，但是当第二次配置成<code>%ANDROID_HOME%</code>却没有bug出现，<strong>不排除其他环境配置问题导致，示例仅供参考</strong></p></blockquote><blockquote><p>如果定义了 ANDROID_HOME 并且其中包含有效的 SDK 安装，系统会使用 ANDROID_HOME 的值而不是 ANDROID_SDK_ROOT 中的值。</p><ul><li>如果未定义 ANDROID_HOME，系统会使用 ANDROID_SDK_ROOT 中的值。</li><li>如果定义了 ANDROID_HOME，但其中不存在或不包含有效的 SDK 安装，系统会使用 ANDROID_SDK_ROOT 中的值。</li></ul></blockquote><h2 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h2><blockquote><p>在开发过程中，由于线材、设备分辨率等限制，优先推荐使用物理机局域网调试，当不需要过多的额外的挂载设备时推荐使用虚拟机调试</p></blockquote><h3 id="物理机局域网调试"><a href="#物理机局域网调试" class="headerlink" title="物理机局域网调试"></a>物理机局域网调试</h3><blockquote><p>调试的前提需要先将<code>debug</code>包(非realease包)安装到移动设备上，那么直接使用命令行<code>yarn taro build --type rn --reset-cache</code>(基于taro)即可</p></blockquote><ol><li>首先确保你的电脑和手机设备在<strong>同一个 Wi-Fi 环境</strong>下。</li><li>在设备上运行你的 React Native 应用。和打开其它 App 一样操作。</li><li>你应该会看到一个“红屏”错误提示。这是正常的，下面的步骤会解决这个报错。</li><li>摇晃设备，或者运行<code>adb shell input keyevent 82</code>，可以打开<strong>开发者菜单</strong>。</li><li>点击<code>Dev Settings</code> -&gt; <code>Debug server host for device</code>。</li><li>输入你电脑的 IP 地址和端口号（譬如 10.0.1.1:8081）。<strong>在 Windows 上</strong>，打开命令提示符并输入<code>ipconfig</code>来查询你的 IP 地址。</li><li>回到<strong>开发者菜单</strong>然后选择<code>Reload JS</code>。</li></ol><blockquote><p>当以上操作流程无误，依然无法触发Reload JS,请关闭React Native 应用，并将二者的网络断开重新连接，如果依然不生效，请重启设备</p></blockquote><h3 id="虚拟机调试"><a href="#虚拟机调试" class="headerlink" title="虚拟机调试"></a>虚拟机调试</h3><p>需要先<a href="https://developer.android.com/studio/run/managing-avds.html">创建一个虚拟设备</a>。点击”Create Virtual Device…”，然后选择所需的设备类型并点击”Next”，然后选择<strong>S</strong> API Level 31 image</p><blockquote><p>请不要轻易点击 Android Studio 中可能弹出的建议更新项目中某依赖项的建议，否则可能导致无法运行。</p></blockquote><h3 id="物理机USB调试"><a href="#物理机USB调试" class="headerlink" title="物理机USB调试"></a>物理机USB调试</h3><p>使用 Android 真机来代替模拟器进行开发，只需用 usb 数据线连接到电脑，然后遵照<a href="https://reactnative.cn/docs/running-on-device">在设备上运行</a>这篇文档的说明操作即可</p><h3 id="编译并运行-React-Native-应用"><a href="#编译并运行-React-Native-应用" class="headerlink" title="编译并运行 React Native 应用"></a>编译并运行 React Native 应用</h3><blockquote><p>使用虚拟机调试可完全跳过该步骤，只需要<code>yarn start</code>启动项目即可</p></blockquote><p>确保你先运行了模拟器或者连接了真机，然后在你的项目目录中运行<code>yarn android</code>或者<code>yarn react-native run-android</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">cd <span class="hljs-title class_">AwesomeProject</span><br>yarn android<br># 或者<br>yarn react-native run-android<br></code></pre></td></tr></table></figure><p>此命令会对项目的原生部分进行编译，同时在另外一个命令行中启动<code>Metro</code>服务对 js 代码进行实时打包处理（类似 webpack）。<code>Metro</code>服务也可以使用<code>yarn start</code>命令单独启动。</p><p>如果配置没有问题，你应该可以看到应用自动安装到设备上并开始运行。注意第一次运行时需要下载大量编译依赖，耗时可能数十分钟。此过程<code>严重依赖稳定的代理软件</code>，否则将频繁遭遇链接超时和断开，导致无法运行。</p><p>也可以尝试阿里云提供的<a href="https://help.aliyun.com/document_detail/102512.html?spm=a2c40.aliyun_maven_repo.0.0.361865e90r2x4b">maven 镜像</a>，将<code>android/build.gradle</code>中的<code>jcenter()</code>和<code>google()</code>分别替换为<code>maven &#123; url &#39;https://maven.aliyun.com/repository/jcenter&#39; &#125;</code>和<code>maven &#123; url &#39;https://maven.aliyun.com/repository/google&#39; &#125;</code>（注意有多处需要替换）。</p><p><code>npx react-native run-android</code>只是运行应用的方式之一。你也可以在 Android Studio 中直接运行应用。</p><blockquote><p>译注：建议在<code>run-android</code>成功后再尝试使用 Android Studio 启动。请不要轻易点击 Android Studio 中可能弹出的建议更新项目中某依赖项的建议，否则可能导致无法运行。</p></blockquote><blockquote><p>如果你无法正常运行，遇到奇奇怪怪的红屏错误，先回头<code>仔细对照文档检查</code>，然后可以看看<a href="https://github.com/reactnativecn/react-native-website/issues">问题讨论区</a>。不同时期不同版本可能会碰到不同的问题，我们会在论坛中及时解答更新。但请注意***千万不要***执行 bundle 命令，那样会导致代码完全无法刷新。</p></blockquote><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><strong>技术栈：react-native taro taro-ui</strong></p><p><strong>设备：东集Seuic手持终端PDA</strong></p><blockquote><p>东集Seuic手持终端PDA未知来源初始密码:4007770876</p></blockquote><h3 id="React-Native组件"><a href="#React-Native组件" class="headerlink" title="React Native组件"></a>React Native组件</h3><h4 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h4><p>在开发过程中，同一个页面中存在多层ScrollView嵌套问题，此时会存在只有最外层的ScrollView生效，其他的ScrollView并未生效，但是</p><p>ScrollView本身提供了属性nestedScrollEnabled支持嵌套</p><h5 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;ScrollView &gt;<br>    ...<br>  &lt;ScrollView nestedScrollEnabled=&#123;true&#125;&gt;<br>   ...<br>   &lt;/ScrollView&gt;<br>    ..<br>&lt;/ScrollView&gt;<br></code></pre></td></tr></table></figure><h5 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h5><p>通过state状态值来控制外层的ScrollView是否可以滚动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs react">const [showScroll, setShowScroll] = useState&lt;boolean&gt;(false)<br>return (<br>    &lt;ScrollView scrollEnabled=&#123;showScroll&#125;&gt;<br>               &lt;ScrollView<br>                   onTouchStart=&#123;(ev) =&gt; &#123;<br>                       console.log(&#x27;开始滑动&#x27;);<br>                       setShowScroll(false)<br>                   &#125;&#125;<br>                   onMomentumScrollEnd=&#123;(e) =&gt; &#123;<br>                       console.log(&#x27;滑动结束&#x27;);<br>                       setShowScroll(true)<br>                   &#125;&#125;<br>                   //当用户开始拖动此视图时调用此函数<br>                   onScrollBeginDrag=&#123;() =&gt; &#123;<br>                       console.log(&#x27;拖动开始&#x27;);<br>                       setShowScroll(false)<br>                   &#125;&#125;<br>                   //当用户停止拖动此视图时调用此函数<br>                   onScrollEndDrag=&#123;(e) =&gt; &#123;<br>                       console.log(&#x27;拖动结束&#x27;);<br>                       setShowScroll(true)<br>                   &#125;&#125;<br>                   style=&#123;&#123; margin: 10, maxHeight: 300 &#125;&#125;<br>               &gt;<br>               &lt;/ScrollView&gt;<br>    &lt;/ScrollView&gt;<br>)<br></code></pre></td></tr></table></figure><h4 id="按钮需要点击两次生效"><a href="#按钮需要点击两次生效" class="headerlink" title="按钮需要点击两次生效"></a>按钮需要点击两次生效</h4><p>在页面的开发过程中，发现页面上的按钮需要触发两次才能生效(先失焦，再聚焦)，点击按钮需要两次的原因是，焦点还在原来的TextInput上面，解决的办法就是，监听软键盘的消失方法，然后在消失方法里面，再一次调用软键盘消失方法：但是只推荐react-native官方提供的方法，即使用组件用ScrollView或FlatList组件包裹，给ScrollView或FlatList组件添加如下属性<code>keyboardShouldPersistTaps=&#39;handled&#39;</code></p><blockquote><p>如果当前界面有软键盘，那么点击 scrollview 后是否收起键盘，取决于本属性的设置。</p><p>（译注：很多人反应 TextInput 无法自动失去焦点&#x2F;需要点击多次切换到其他组件等等问题，其关键都是需要将 TextInput 放到 ScrollView 中再设置本属性）</p><ul><li><code>&#39;never&#39;</code> （默认值），点击 TextInput 以外的子组件会使当前的软键盘收起。此时子元素不会收到点击事件。</li><li><code>&#39;always&#39;</code>，键盘不会自动收起，ScrollView 也不会捕捉点击事件，但子组件可以捕获。</li><li><code>&#39;handled&#39;</code>，当点击事件被子组件捕获时，键盘不会自动收起。这样切换 TextInput 时键盘可以保持状态。多数带有 TextInput 的情况下你应该选择此项。</li><li><code>false</code>，已过时，请使用’never’代替。</li><li><code>true</code>，已过时，请使用’always’代替。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;ScrollView keyboardShouldPersistTaps=&#x27;handled&#x27;&gt;<br></code></pre></td></tr></table></figure><p>若基于taro框架以上配置未生效，需要在每个页面入口index.tsx同级目录添加一个index.config.ts文件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//index.config.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">definePageConfig</span>(&#123;<br>    <span class="hljs-attr">disableScroll</span>: <span class="hljs-literal">true</span><br>  &#125;)<br>  <br></code></pre></td></tr></table></figure><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><p>一个用于显示文本的 React 组件，并且它也支持嵌套、样式，以及触摸处理。属性<code>selectable</code>决定用户是否可以长按选择文本，以便复制和粘贴。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;Text selectable=&#123;true&#125;&gt;and red&lt;/Text&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React Native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nvm版本管理</title>
    <link href="./2023/03/08/Nvm%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <url>./2023/03/08/Nvm%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Nvm学习"><a href="#Nvm学习" class="headerlink" title="Nvm学习"></a>Nvm学习</h1><h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一.安装"></a>一.安装</h2><p>第二步：安装nvm管理工具</p><p>1.从官网下载安装包 <a href="https://github.com/coreybutler/nvm-windows/releases%EF%BC%8C%E9%80%89%E6%8B%A9[nvm-setup.zip](https://github.com/coreybutler/nvm-windows/releases/download/1.1.9/nvm-setup.zip)%E5%8E%8B%E7%BC%A9%E5%8C%85">https://github.com/coreybutler/nvm-windows/releases，选择[nvm-setup.zip](https://github.com/coreybutler/nvm-windows/releases/download/1.1.9/nvm-setup.zip)压缩包</a></p><p>2.将下载下来的压缩包进行解压（随便解压到任一你喜欢的位置），解压文件夹里面是一个.exe文件</p><p>3.开始进行nvm安装</p><p>（切记不要选择到c:&#x2F;program files,这里的两个路径是为了自动在系统中添加环境变量的路径）</p><pre><code class="hljs">(1) 鼠标双击nvm-setup.exe文件，选择“我接受…”那一行，点击next(2) 选择nvm安装目录，可以根据自身情况自定义选择路径盘，**路径不要出现空格或中文符号**（路径最好是在路径盘的根目录下，如C盘、D盘下的根目录）(3) 选择node.js的安装位置，可以根据自身情况自定义选择路径盘，**路径不要出现空格或中文符号**（路径最好是在路径盘的根目录下新建一个文件夹，如C盘、D盘下的根目录(4)安装完毕</code></pre><p>4.安装之后</p><p>以下两种方法选其一，属玄学问题</p><p><strong>方法一：</strong></p><p><strong>使用该方法，大部分会提示npm无法下载，下载了可能无法使用</strong></p><p>打开nvm文件夹下的settings.txt文件，在最后添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">node_mirror</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//npm.taobao.org/mirrors/node/</span><br><span class="hljs-attr">npm_mirror</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//npm.taobao.org/mirrors/npm/</span><br></code></pre></td></tr></table></figure><p>将下载镜像源指向淘宝（这步也很重要，否则在安装node的时候会出现卡死，npm安装不成功的情况）</p><p><strong>方法二：</strong></p><p><strong>不添加镜像地址，但是也存在下载卡顿的情况</strong></p><p>5.nvm运行</p><blockquote><p><strong>重点</strong>：使用管理员权限的命令提示符打开，否则会在使用 <code>nvm use 版本号</code> 之后的结果为乱码，且不成功，<code>node -v</code> 和 <code>npm -v</code>找  不到</p></blockquote><p>打开管理员权限的cmd</p><p>(1) 输入命令行nvm ls available查看可用的node.js版本号</p><p>(2) 输入命令行nvm install node版本号(例如：nvm install 12.17.0)即可安装对应版本以及自动安装对应的npm版本</p><p>(3) 安装成功后，输入命令行nvm use node版本号（例如：nvm use 12.17.0）即可选择你本地所使用的Node.js版本，使用此命</p><p>令行可以根据你自己的需要随意切换node.js版本运行</p><p>(4) 输入命令行nvm ls查看你安装的所有node.js版本号，以及你当前所选择的node.js运行版本</p><p>(5) 如果想删除某node.js版本的话，输入命令行nvm uninstall node版本号（例如：nvm uninstall 12.17.0）即可删除对应版本</p><p> <code>npm</code>设置淘宝镜像源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 切换淘宝源</span><br>npm config set registry <span class="hljs-attr">https</span>:<span class="hljs-comment">//registry.npm.taobao.org --global</span><br>npm config set disturl <span class="hljs-attr">https</span>:<span class="hljs-comment">//npm.taobao.org/dist --global</span><br><br><span class="hljs-comment">//查看源信息</span><br>npm config get registry <br>npm config get disturl <br><br><span class="hljs-comment">//删除源</span><br>npm config <span class="hljs-keyword">delete</span> registry<br>npm config <span class="hljs-keyword">delete</span> disturl<br><br><span class="hljs-comment">//看npm配置信息</span><br>npm config list<br></code></pre></td></tr></table></figure><p><code>npm</code> 安装 <code>nrm</code>源管理</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 安装nrm<br>npm i nrm -g<br><span class="hljs-regexp">//</span> 添加代理<br>nrm add 自定义的代理名字 地址      <span class="hljs-regexp">//</span> 例如nrm add lesoon http:<span class="hljs-regexp">//</span>scm-verdaccio.belle.net.cn<br><span class="hljs-regexp">//</span> 切换代理<br>nrm use lesoon[或其它代理]<br><span class="hljs-regexp">//</span> 查看代理<br>nrm ls<br><span class="hljs-regexp">//</span>查看延迟<br>nrm test<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>nvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口状态码</title>
    <link href="./2023/03/08/%E6%8E%A5%E5%8F%A3%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>./2023/03/08/%E6%8E%A5%E5%8F%A3%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">200 </span>   OK    请求成功。一般用于<span class="hljs-keyword">GET</span>与POST请求<br><span class="hljs-symbol">201 </span>   Created    已创建。成功请求并创建了新的资源<br><span class="hljs-symbol">202 </span>   Accepted    已接受。已经接受请求，但未处理完成<br><span class="hljs-symbol">203 </span>   Non-Authoritative Information    非授权信息。请求成功。但返回的meta信息不在原始的服务     器，而是一个副本<br><span class="hljs-symbol">204 </span>   No Content    无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档<br><span class="hljs-symbol">205 </span>   <span class="hljs-keyword">Reset</span> Content    重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域<br><span class="hljs-symbol">206 </span>   Partial Content    部分内容。服务器成功处理了部分<span class="hljs-keyword">GET</span>请求<br><span class="hljs-symbol">300 </span>   Multiple Choices    多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择<br><span class="hljs-symbol">301 </span>   Moved Permanently    永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替<br><span class="hljs-symbol">302 </span>   Found    临时移动。与<span class="hljs-number">301</span>类似。但资源只是临时被移动。客户端应继续使用原有URI<br><span class="hljs-symbol">303 </span>   See Other    查看其它地址。与<span class="hljs-number">301</span>类似。使用<span class="hljs-keyword">GET</span>和POST请求查看<br><span class="hljs-symbol">304 </span>   <span class="hljs-keyword">Not</span> Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源<br><span class="hljs-symbol">305 </span>   Use Proxy    使用代理。所请求的资源必须通过代理访问<br><span class="hljs-symbol">306 </span>   Unused    已经被废弃的HTTP状态码<br><span class="hljs-symbol">307 </span>   Temporary Redirect    临时重定向。与<span class="hljs-number">302</span>类似。使用<span class="hljs-keyword">GET</span>请求重定向<br><span class="hljs-symbol">400 </span>   Bad Request    客户端请求的语法错误，服务器无法理解<br><span class="hljs-symbol">401 </span>   Unauthorized    请求要求用户的身份认证<br><span class="hljs-symbol">402 </span>   Payment Required    保留，将来使用<br><span class="hljs-symbol">403 </span>   Forbidden    服务器理解请求客户端的请求，但是拒绝执行此请求<br><span class="hljs-symbol">404 </span>   <span class="hljs-keyword">Not</span> Found    服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置<span class="hljs-string">&quot;您所请求的资源无法找到&quot;</span>的个性页面<br><span class="hljs-symbol">500 </span>   Internal Server <span class="hljs-keyword">Error</span>    服务器内部错误，无法完成请求<br><span class="hljs-symbol">501 </span>   <span class="hljs-keyword">Not</span> Implemented    服务器不支持请求的功能，无法完成请求<br><span class="hljs-symbol">502 </span>   Bad Gateway    作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应<br><span class="hljs-symbol">503 </span>   Service Unavailable    由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中<br><span class="hljs-symbol">504 </span>   Gateway Time-<span class="hljs-keyword">out</span>    充当网关或代理的服务器，未及时从远端服务器获取请求<br><span class="hljs-symbol">505 </span>   HTTP Version <span class="hljs-keyword">not</span> supported    服务器不支持请求的HTTP协议的版本，无法完成处理<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>request</category>
      
    </categories>
    
    
    <tags>
      
      <tag>request</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS知识点汇总</title>
    <link href="./2023/03/08/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <url>./2023/03/08/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS知识点汇总"><a href="#CSS知识点汇总" class="headerlink" title="CSS知识点汇总"></a>CSS知识点汇总</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*css可以认为时由多个选择器组成的集合，每个选择器由3个基本部分组成---&quot;选择器名称&quot;、&quot;属性&quot;、&quot;值&quot;*/</span><br>selector &#123;<br>    property:value;<br>&#125;<br><span class="hljs-comment">/*其中selector由不同的形式，包括HTML的标记(例如&lt;body&gt;、&lt;table&gt;、&lt;p&gt;等)，也可以是用户自定义的*/</span><br><span class="hljs-comment">/*标记；property是选择器的属性；value指定了属性的值*/</span><br><br><span class="hljs-comment">/*标记选择器*/</span><br><span class="hljs-comment">/*诸如&lt;p&gt;、&lt;h&gt;、&lt;div&gt;等,可直接使用*/</span><br>tagName &#123;<br>    property:value;<br>&#125;<br><br><span class="hljs-comment">/*类选择器，用于控制页面中所有同类标记的显示样式*/</span><br><span class="hljs-selector-class">.className</span>&#123;<br>    property:value;<br>&#125;<br><span class="hljs-comment">/*className是选择器的名称，具体名称由css制定者自己命名，如果一个标记具有class属性，且属性值为Na么，那么*/</span><br><span class="hljs-comment">/*该标记的呈现样式由该选择器指定。在定类选择符时，需要在className前面加一个句点&quot;.&quot;*/</span><br><br><span class="hljs-comment">/*ID选择器，和类选择器在设置样式的功能类似，都是对特定属性的属性值进行设置。但ID选择器的一个重要功能是用做网页的唯一标识*/</span><br><span class="hljs-selector-class">.idName</span>&#123;<br>    property:value;<br>&#125;<br><span class="hljs-comment">/*idName是选择器名称，可以由css定义者自己命名，如果某标记具有id属性，并且该属性值为idName，那么该标记的呈现样式由ID选择*/</span><br><span class="hljs-comment">/*器指定，在正常情况下，id属性值在文档中具有唯一性。在定于ID选择器时，需要在idName前面加一个&quot;#&quot;符号*/</span><br><span class="hljs-selector-id">#font1</span>&#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;幼圆&quot;</span>;<br>    <span class="hljs-attribute">color</span>: blue;<br> &#125;<br><span class="hljs-comment">/*a.类选择器可以给任意数量的标记定义样式，但ID选择器在页面的标记中只能使用一次，因为如果一个HTML页面中有*/</span><br><span class="hljs-comment">/*  两个相同id的标记，那么JavaScript在查找id时将会发生错误*/</span><br><span class="hljs-comment">/*b.ID选择器比类选择器具有更高的优先级，即当ID选择器与类选择器在样式定义上发生冲突时，优先使用ID选择器定义的样式*/</span><br><br><span class="hljs-comment">/*行内样式*/</span><br><span class="hljs-comment">/*&lt;h1 style=&quot;color:blue; font-style:bold&quot;&gt;&lt;/h1&gt; */</span><br><br><span class="hljs-comment">/*在html中内嵌css*/</span><br><span class="hljs-comment">/*&lt;!DOCTYPE html&gt; */</span><br><span class="hljs-comment">/*&lt;html lang=&quot;en&quot;&gt; */</span><br><span class="hljs-comment">/*&lt;head&gt; */</span><br><span class="hljs-comment">/*&lt;meta charset=&quot;UTF-8&quot;&gt;*/</span><br><span class="hljs-comment">/*&lt;style type=text/css&gt;*/</span><br><span class="hljs-comment">/*h2&#123;*/</span><br><span class="hljs-comment">/*   font-family: &quot;幼圆&quot;;*/</span><br><span class="hljs-comment">/*   font-size: 16px;*/</span><br><span class="hljs-comment">/*   color: blue;*/</span><br><span class="hljs-comment">/*   &#125;*/</span><br><span class="hljs-comment">/*.sp123&#123;*/</span><br><span class="hljs-comment">/*    line-height: 140%;*/</span><br><span class="hljs-comment">/*    background-color: blue;*/</span><br><span class="hljs-comment">/*&#125;*/</span><br><span class="hljs-comment">/*#id1&#123;*/</span><br><span class="hljs-comment">/*    line-height: 150%;*/</span><br><span class="hljs-comment">/*    background-color: red;*/</span><br><span class="hljs-comment">/*&#125;*/</span><br><span class="hljs-comment">/*&lt;/style&gt;*/</span><br><span class="hljs-comment">/*&lt;/head&gt;*/</span><br><span class="hljs-comment">/*&lt;body&gt;*/</span><br><span class="hljs-comment">/*&lt;h2&gt; 可直接调用&lt;/h2&gt;*/</span><br><span class="hljs-comment">/*&lt;p class=&quot;sp123&quot;&gt;用class调用.sp&lt;/p&gt;*/</span><br><span class="hljs-comment">/*&lt;p id=&quot;id1&quot;&gt;用id调用id1&lt;/p&gt;*/</span><br><span class="hljs-comment">/*&lt;/body&gt;*/</span><br><span class="hljs-comment">/*&lt;/html&gt;*/</span><br>链接样式<br><br><span class="hljs-comment">/*CSS外部样式表mystyle.css*/</span><br><span class="hljs-selector-tag">body</span>&#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;宋体&quot;</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0000ff</span>;<br>&#125;<br><span class="hljs-selector-id">#first</span>&#123;<br>    <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;幼圆&quot;</span>;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br><span class="hljs-comment">/*再完成一个HTML文件main.html*/</span><br><span class="hljs-comment">/*&lt;!DOCTYPE html&gt; */</span><br><span class="hljs-comment">/*&lt;html lang=&quot;en&quot;&gt; */</span><br><span class="hljs-comment">/*&lt;head&gt; */</span><br><span class="hljs-comment">/*&lt;meta charset=&quot;UTF-8&quot;&gt;*/</span><br><span class="hljs-comment">/*&lt;link href=&quot;mystyle.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt;*/</span><br><span class="hljs-comment">/*&lt;/head&gt;*/</span><br><span class="hljs-comment">/*&lt;body&gt;*/</span><br><span class="hljs-comment">/*&lt;p id=&quot;first&quot;&gt; 我是链接样式的主体&lt;/p&gt;*/</span><br><span class="hljs-comment">/*&lt;/body&gt;*/</span><br><span class="hljs-comment">/*&lt;/html&gt;*/</span><br><br><span class="hljs-comment">/*&lt;link&gt;标记的几个属性*/</span><br><span class="hljs-comment">/*a.rel属性指明了链接属性，定义链接的文件和HTML文档之间的关系就设为stylesheet*/</span><br><span class="hljs-comment">/*b.href属性指出了样式表的位置，他只是个普通的URL地址，可以是相对地址，也可以是绝对地址*/</span><br><span class="hljs-comment">/*c.type属性指明了样式表的位置，对于级联样式表，它的取值为text/css*/</span><br><br><span class="hljs-comment">/*各种样式的优先级*/</span><br><span class="hljs-comment">/*行内样式的优先级高于嵌入样式；嵌入样式的优先级高于链接样式；链接样式的优先级高于导入样式*/</span><br><br><span class="hljs-comment">/*css复合选择器*/</span><br><span class="hljs-comment">/*交集选择器，是由两个选择器直接连接构成的，其中结果是选中两者各自作用范围的交集，其中，第一个*/</span><br><span class="hljs-comment">/*必须是标记选择器，第二个必须是类选择器或ID选择器，例如：&quot;h1.class1; p#id1&quot;*/</span><br><br>tagName<span class="hljs-selector-class">.className</span> &#123;<br>    property:value;<br>&#125;<br><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.class1</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#91a0ff</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-comment">/*&lt;!DOCTYPE html&gt; */</span><br><span class="hljs-comment">/*&lt;html lang=&quot;en&quot;&gt; */</span><br><span class="hljs-comment">/*&lt;head&gt; */</span><br><span class="hljs-comment">/*&lt;meta charset=&quot;UTF-8&quot;&gt;*/</span><br><span class="hljs-comment">/*&lt;style&gt;&#123;*/</span><br><span class="hljs-comment">/*     div&#123;*/</span><br><span class="hljs-comment">/*         color: blue;*/</span><br><span class="hljs-comment">/*         font-size: 9px;*/</span><br><span class="hljs-comment">/*     &#125;*/</span><br><span class="hljs-comment">/*     .class1&#123;*/</span><br><span class="hljs-comment">/*         font-size: 12px;*/</span><br><span class="hljs-comment">/*     &#125;*/</span><br><span class="hljs-comment">/*     div.class1 &#123;*/</span><br><span class="hljs-comment">/*         color: red;*/</span><br><span class="hljs-comment">/*         font-size: 10px;*/</span><br><span class="hljs-comment">/*         font-weight: bold;*/</span><br><span class="hljs-comment">/*     &#125;*/</span><br><span class="hljs-comment">/* &#125;*/</span><br><span class="hljs-comment">/*&lt;/style&gt;*/</span><br><span class="hljs-comment">/*&lt;/head&gt;*/</span><br><span class="hljs-comment">/*&lt;body&gt;*/</span><br><span class="hljs-comment">/*&lt;div&gt; 正常div标记，蓝色，9px &lt;/div&gt;*/</span><br><span class="hljs-comment">/*&lt;p class=&quot;class1&quot;&gt;类选择器，12px&lt;/p&gt;*/</span><br><span class="hljs-comment">/*&lt;div class=&quot;class1&quot; &gt; 交集选择器，红色，加粗，10px&lt;/div&gt;*/</span><br><span class="hljs-comment">/*&lt;/body&gt;*/</span><br><span class="hljs-comment">/*&lt;/html&gt;*/</span><br><br><span class="hljs-comment">/*并集选择器，对多个选择器进行集体声明，多个选择器之间用&quot;,&quot;隔开，每个选择器可以是*/</span><br><span class="hljs-comment">/*任何类型的选择器，如果某些选择器定义的样式完全相同，或者部分相同，这时，便可以使用*/</span><br><span class="hljs-comment">/*并集选择器*/</span><br>selector,selector1 &#123;<br>    property:value;<br> &#125;<br><br><span class="hljs-comment">/*&lt;!DOCTYPE html&gt; */</span><br><span class="hljs-comment">/*&lt;html lang=&quot;en&quot;&gt; */</span><br><span class="hljs-comment">/*&lt;head&gt; */</span><br><span class="hljs-comment">/*&lt;meta charset=&quot;UTF-8&quot;&gt;*/</span><br><span class="hljs-comment">/*&lt;style&gt;&#123;*/</span><br><span class="hljs-comment">/*     div,h1,p &#123;*/</span><br><span class="hljs-comment">/*         color: blue;*/</span><br><span class="hljs-comment">/*         font-size: 9px;*/</span><br><span class="hljs-comment">/*     &#125;*/</span><br><span class="hljs-comment">/*     div.class1,class1,#id1 &#123;*/</span><br><span class="hljs-comment">/*         color: red;*/</span><br><span class="hljs-comment">/*         font-size: 10px;*/</span><br><span class="hljs-comment">/*         font-weight: bold;*/</span><br><span class="hljs-comment">/*     &#125;*/</span><br><span class="hljs-comment">/* &#125;*/</span><br><span class="hljs-comment">/*&lt;/style&gt;*/</span><br><span class="hljs-comment">/*&lt;/head&gt;*/</span><br><span class="hljs-comment">/*&lt;body&gt;*/</span><br><span class="hljs-comment">/*&lt;div&gt; 正常div标记，蓝色，9px &lt;/div&gt;*/</span><br><span class="hljs-comment">/*&lt;p &gt;p标记，和div标记相同&lt;/p&gt;*/</span><br><span class="hljs-comment">/*&lt;div class=&quot;class1&quot; &gt;红色，加粗，10px&lt;/div&gt;*/</span><br><span class="hljs-comment">/*&lt;span id=&quot;id1&quot; &gt;红色，加粗，10px&lt;/span&gt;*/</span><br><span class="hljs-comment">/*&lt;/body&gt;*/</span><br><span class="hljs-comment">/*&lt;/html&gt;*/</span><br><br><span class="hljs-comment">/*后代选择器*/</span><br><span class="hljs-comment">/*在CSS选择器中，可以通过嵌套的方式，对特殊位置HTML标记进行控制，例如：当&lt;div&gt;与&lt;/div&gt;之间包含&lt;b&gt;标记时，*/</span><br><span class="hljs-comment">/*就可以使用后代选择器定义出现在&lt;div&gt;标记中的&lt;b&gt;标记的格式，后代选择器的写法是把外层的标记写在前面，内层标记写在*/</span><br><span class="hljs-comment">/*后面，之间用空格隔开*/</span><br>selector1  selector2 &#123;<br>           property:value;<br>         &#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">color</span>: aqua;<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">800</span>;<br>&#125;<br><br>子选择器<br>子选择器用于选中标记的直接后代（即儿子），它的定义符号是大于号（&gt;）<br>selector&gt;selector1<br><br><span class="hljs-comment">/*&lt;!DOCTYPE html&gt; */</span><br><span class="hljs-comment">/*&lt;html lang=&quot;en&quot;&gt; */</span><br><span class="hljs-comment">/*&lt;head&gt; */</span><br><span class="hljs-comment">/*&lt;meta charset=&quot;UTF-8&quot;&gt;*/</span><br><span class="hljs-comment">/*&lt;style&gt;*/</span><br><span class="hljs-comment">/*div&gt;p &#123;*/</span><br><span class="hljs-comment">/*    font-family: &quot;幼圆&quot;;*/</span><br><span class="hljs-comment">/*    color: red;*/</span><br><span class="hljs-comment">/*&#125;*/</span><br><span class="hljs-comment">/*&lt;/style&gt;*/</span><br><span class="hljs-comment">/*&lt;/head&gt;*/</span><br><span class="hljs-comment">/*&lt;body&gt;*/</span><br><span class="hljs-comment">/*&lt;div&gt;</span><br><span class="hljs-comment">/*&lt;p &gt;本行应用了子选择器，幼圆，红色&lt;/p&gt;*/</span><br><span class="hljs-comment">/*&lt;em&gt;*/</span><br><span class="hljs-comment">/*&lt;p&gt;本行不是div的直接后代，子选择器无效&lt;/p&gt;*/</span><br><span class="hljs-comment">/*&lt;/em&gt;*/</span><br><span class="hljs-comment">/*&lt;/div&gt;*/</span><br><span class="hljs-comment">/*&lt;/body&gt;*/</span><br><span class="hljs-comment">/*&lt;/html&gt;*/</span><br><br>相邻选择器<br>相邻选择器，它的定义符号（+），可以选中紧跟在它后面的一个兄弟元素（这两个元素具有共同的父元素）<br>selector+selector1<br><br>属性选择器<br>例如：设置网页中id值为first的元素背景色和前景颜色，使用属性选择器的描述<br><span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[id=<span class="hljs-string">&quot;first&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br>例如：将网页表单中<span class="hljs-selector-tag">input</span>元素中的text类型，设置蓝色边框，可以通过下面的属性选择器来绑定<br><span class="hljs-selector-tag">input</span> <span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> dotted blue;<br>&#125;<br><br>属性选择器及其功能<br>选择器              说明<br><span class="hljs-selector-attr">[att*=<span class="hljs-string">&quot;value&quot;</span>]</span>     匹配属性包含特定值的元素。例如，<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href*=<span class="hljs-string">&quot;lei&quot;</span>]</span>,匹配&lt;<span class="hljs-selector-tag">a</span> href=&quot;http://www.lei.edu.cn<span class="hljs-string">&quot;&gt; 包含匹配&lt;/a&gt;</span><br><span class="hljs-string">[att^=&quot;</span>value<span class="hljs-string">&quot;]     匹配属性包含以特定值开头的元素。例如，a[href^=&quot;</span>ftp<span class="hljs-string">&quot;],匹配&lt;a href=&quot;</span>ftp://www.lei.edu.cn<span class="hljs-string">&quot;&gt; 头匹配&lt;/a&gt;</span><br><span class="hljs-string">[att$=&quot;</span>value<span class="hljs-string">&quot;]     匹配属性包含以特定值结尾的元素。例如，a[href$=&quot;</span>cn<span class="hljs-string">&quot;],匹配&lt;a href=&quot;</span>http://www.lei.edu.cn<span class="hljs-string">&quot;&gt; 尾匹配&lt;/a&gt;</span><br><span class="hljs-string">[att=&quot;</span>value<span class="hljs-string">&quot;]      匹配属性等于某特定值的元素。例如，[type=&quot;</span>text<span class="hljs-string">&quot;],匹配&lt;input type=&quot;</span>text<span class="hljs-string">&quot; name=&quot;</span>username<span class="hljs-string">&quot; /&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">* &#123;   /*网页中所有文字的格式*/</span><br><span class="hljs-string">     text-decoration: none;</span><br><span class="hljs-string">     font-size: 16px;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">a[href^=http]:before&#123;              /*在指定属性之前插入内容*/</span><br><span class="hljs-string">    content:&quot;</span>超文本传输协议：<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    color: red;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">a[href$=jpg]:after,a[href$=png]:after &#123;   /*在指定属性前之后插入内容*/</span><br><span class="hljs-string">    content: &quot;</span>图像<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    color: green;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">伪类选择器，是在css中已经定义的选择器，而不是由用户自行定义</span><br><span class="hljs-string">/*此处未给出详细内容*/</span><br><span class="hljs-string"></span><br><span class="hljs-string">字体属性</span><br><span class="hljs-string">font-family属性用于确定要使用的字体列表，例如：宋体、幼圆等</span><br><span class="hljs-string">font-size属性用于控制文字的大小，取值分为4种类型--绝对大小、相对大小、长度值、以及百分数，该属性默认值是medium</span><br><span class="hljs-string">font-size属性确定指定元素显示的字形，font-style属性的值包括normal、italic和oblique3种，默认值为normal，表示</span><br><span class="hljs-string">普通字形；itlic和oblique表示斜体字形</span><br><span class="hljs-string">font-variant属性用于子浏览器中显示指定元素的字体变体。该属性有3个值：normal、small-caps、inherit，该属性</span><br><span class="hljs-string">默认值为normal，表示使用标准字体；small-caps表示小体大写</span><br><span class="hljs-string">font-weight属性定义了字体的粗细值，它的取值可以是normal、bold、bolder、lighter，默认值为normal，表示正常粗细，</span><br><span class="hljs-string">bold表示粗体</span><br><span class="hljs-string">组合属性font</span><br><span class="hljs-string"></span><br><span class="hljs-string">文本属性</span><br><span class="hljs-string">word-spacing用于设定单词之间的间隔，它的取值可以是normal或具体的长度值，也可以是负值</span><br><span class="hljs-string">letter-spacing属性和word-spacing类似，它的值决定了字符间距（出去默认距离外）</span><br><span class="hljs-string">text-align属性指定了所选元素的对齐方式（类似与HTML标记符的align属性），取值可以是left、right、center、</span><br><span class="hljs-string">justify、start、end，分别为 左对齐、右对齐、居中对齐、两端对齐、开始边缘对齐、向行的结束边缘对齐</span><br><span class="hljs-string">text-indent属性可以对特定选项的文本进行收行缩进，取值可以为长度值或百分比，默认值为0</span><br><span class="hljs-string">line-height属性决定了相邻行之间的间距（或者说行高），其取值可以是数字、长度、百分比</span><br><span class="hljs-string">/*长度值10pt，像素值10px*/</span><br><span class="hljs-string">text-decoration属性可以对特定选项的文本进行修饰，它的取值为none、underline、overline、line-through和blink，默认值为none</span><br><span class="hljs-string">text-transform属性用于转换文本，取值为capitalize、uppercase、lowercase、none，默认值为none，capitalize值表示</span><br><span class="hljs-string">所选元素中文本的每个单词的首字母以大写显示；uppercase值表示所有文本都以大写显示，lowercase值表示所有文本都以小写显示</span><br><span class="hljs-string">text-shadow属性用于向文本添加一个或多个阴影，取值为color、length、opacity</span><br><span class="hljs-string"></span><br><span class="hljs-string">text-shadow:X-Offset Y-Offset shadow color;</span><br><span class="hljs-string">X-Offset表示阴影的水平偏移距离，其值为正向右偏移，其值为负向左偏移</span><br><span class="hljs-string">Y-Offset表示阴影的垂直偏移距离，其值为正向下偏移，其值为负向上偏移</span><br><span class="hljs-string">shadow表示阴影的模糊度，不可以为负，值越大，阴影越模糊，反之，清晰</span><br><span class="hljs-string">div &#123;</span><br><span class="hljs-string">    text-shadow: 5px 8px 3px gray;</span><br><span class="hljs-string">    font: 24pt &quot;</span>楷体<span class="hljs-string">&quot;;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">word-wrap属性允许超过容器的长单词换行到下一行，它的取值为normal和break-word，默认值为normal，表示只在允许的断字点换行；</span><br><span class="hljs-string">break-word表示在长单词或URL地址内部进行换行</span><br><span class="hljs-string"></span><br><span class="hljs-string">background-color属性用于设置HTML元素背景颜色</span><br><span class="hljs-string">background-image属性用于设置HTML元素背景图片</span><br><span class="hljs-string">background-attachment属性控制背景图片是否随内容一起滚动，取值为scroll或fixed，该属性默认值为scroll，表示背景图片随着</span><br><span class="hljs-string">内容一起滚动，fixed表示背景图像静止，而内容可以滚动</span><br><span class="hljs-string">background-position属性指定了背景图像相对于关联区域左上角的位置，该属性通常指定由空格隔开的两个值，既可以使用关键</span><br><span class="hljs-string">字left/center/right和top/center/boottom,也可以指定百分数值，胡总和指定以标准单位计算的距离</span><br><span class="hljs-string">background-repeat属性用来表示背景图片是否重复显示，取值可以是reapeat/repeat-x/repeat-y/no-repeat</span><br><span class="hljs-string">组合属性background</span><br><span class="hljs-string"></span><br><span class="hljs-string">boder:5px solid red;   /*制作圆角边框用这行代码*/</span><br><span class="hljs-string"></span><br><span class="hljs-string">boder-width设置边框粗细</span><br><span class="hljs-string">boder-color设置边框颜色</span><br><span class="hljs-string">boder-style选择一些预先定义的好的线型，如虚线、实线等</span><br><span class="hljs-string"></span><br><span class="hljs-string">max-width和max-heigth分别设置图片宽度最大值和高度最大值</span><br><span class="hljs-string"></span><br><span class="hljs-string">浮动属性</span><br><span class="hljs-string">CSS使用float属性实现文字环绕效果。float属性主要定义图像向那个方向浮动</span><br><span class="hljs-string">float:none/left/right;</span><br><span class="hljs-string"></span><br><span class="hljs-string">清除浮动属性</span><br><span class="hljs-string">clear:none |left |right |both;</span><br><span class="hljs-string"></span><br><span class="hljs-string">定位属性</span><br><span class="hljs-string">position: static |relation |absolute |fixed</span><br><span class="hljs-string">static静态定位，默认的定位属性</span><br><span class="hljs-string">absolute绝对定位，通过top、left、bottom、right等属性值定位盒子相对其具有position设置的父对象的偏移位置，不</span><br><span class="hljs-string">占用原页面空间</span><br><span class="hljs-string">relative相对定位，通过top、left、bottom、right等属性值定位元素相对其原本应显示位置的偏移位置，占用原位置空间</span><br><span class="hljs-string">fixed固定定位，通过通过top、left、bottom、right等属性值定位盒子相对浏览器窗口的拍内衣位置</span><br><span class="hljs-string"></span><br><span class="hljs-string">层叠定位属性z-index</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react中使用echarts</title>
    <link href="./2023/03/08/Echarts%E5%9C%B0%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
    <url>./2023/03/08/Echarts%E5%9C%B0%E5%9B%BE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="react中使用echarts来绘制中国地图"><a href="#react中使用echarts来绘制中国地图" class="headerlink" title="react中使用echarts来绘制中国地图"></a>react中使用echarts来绘制中国地图</h1><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/648e77796c1a441cacfc19afe76ef5b2~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="react中使用echarts来绘制中国地图"></p><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>我们可以看到有些场景需要用地图来展示数据，做地理区域数据的可视化，比如想看全国人口分布情况等。那具体怎么实现呢，我们可以利用<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/index.html">echarts</a>来进行实现。</p><h1 id="二、地图实现"><a href="#二、地图实现" class="headerlink" title="二、地图实现"></a>二、地图实现</h1><p>主要参考官方示例地图<a href="https://link.juejin.cn/?target=https://echarts.apache.org/examples/zh/editor.html?c=map-usa">2021年美国人口统计</a>这个示例进行开发。</p><h2 id="1-安装echarts"><a href="#1-安装echarts" class="headerlink" title="1.安装echarts"></a>1.安装echarts</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install echarts --save<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="2-引入echarts"><a href="#2-引入echarts" class="headerlink" title="2.引入echarts"></a>2.引入echarts</h2><p>引入echarts后，基于准备好的dom，初始化echarts实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">let</span> mapInstance = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">renderChart</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    ...<br>    <span class="hljs-comment">// 基于准备好的dom，初始化echarts实例</span><br>    mapInstance = echarts.<span class="hljs-title function_">init</span>(ref.<span class="hljs-property">current</span>);<br>    mapInstance.<span class="hljs-title function_">setOption</span>(&#123;<br>        ...<br>    &#125;)<br>    ...<br>  &#125;;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">renderChart</span>();<br>  &#125;, []);<br>  <br>  ...<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">width:</span> &quot;<span class="hljs-attr">100</span>%&quot;, <span class="hljs-attr">height:</span> &quot;<span class="hljs-attr">100vh</span>&quot; &#125;&#125; <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="3-使用echarts-registerMap-注册可用地图"><a href="#3-使用echarts-registerMap-注册可用地图" class="headerlink" title="3.使用echarts.registerMap 注册可用地图"></a>3.使用echarts.registerMap 注册可用地图</h2><p>通过官方示例<a href="https://link.juejin.cn/?target=https://echarts.apache.org/examples/zh/editor.html?c=map-usa">2021年美国人口统计</a>发现使用 <a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/api.html%23echarts.registerMap">echarts.registerMap</a>方法，查看API发现 这个方法是用来注册可用的地图，只在 <a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23geo">geo</a> 组件或者 <a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23series-map">map</a> 图表类型中才能使用。我们这里使用的是<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23series-map">map</a>图表类型。</p><p><strong>并且还需要注意文档中说明的一点：</strong></p><blockquote><p>registerMap 和 getMap 方法需要在引入地图组件后才能使用 为了减少最小打包的体积，我们从核心模块中移除了地图数据管理的方法<code>getMap</code>和<code>registerMap</code>。 如果你是<a href="https://link.juejin.cn/?target=https://echarts.apache.org/handbook/zh/basics/import/%23%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5-echarts-%E5%9B%BE%E8%A1%A8%E5%92%8C%E7%BB%84%E4%BB%B6">按需引入</a> ECharts 组件的话，需要保证先引入了<code>GeoComponent</code>或者<code>MapChart</code>之后，才能使用<code>registerMap</code>注册地图数据。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">MapChart</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts/charts&#x27;</span>;<br><br>echarts.<span class="hljs-title function_">use</span>([<span class="hljs-title class_">MapChart</span>]);<br><br><span class="hljs-comment">// 必须在使用 use 方法注册了 MapChart 后才能使用 registerMap 注册地图</span><br>echarts.<span class="hljs-title function_">registerMap</span>(<span class="hljs-string">&#x27;world&#x27;</span>, worldJSON);<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>如果你是使用<code>import * as echarts from &#39;echarts&#39;</code>全量引入，这次改动不会对你产生任何影响。</p></blockquote><h3 id="1）echarts-registerMap方法参数介绍"><a href="#1）echarts-registerMap方法参数介绍" class="headerlink" title="1）echarts.registerMap方法参数介绍"></a>1）echarts.registerMap方法参数介绍</h3><p>使用<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/api.html%23echarts.registerMap">echarts.registerMap</a>方法，首先看一下它需要传的参数有哪些：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2051c4f94edd4344adc8addd91404a4f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="echarts.registerMap参数.png"></p><p>这里我们使用的是<code>geoJSON</code>。</p><h3 id="2）下载geoJSON地图数据"><a href="#2）下载geoJSON地图数据" class="headerlink" title="2）下载geoJSON地图数据"></a>2）下载<code>geoJSON</code>地图数据</h3><p>现在<code>echarts</code>库不再自带地图，所以地图的数据需要我们自己下载。我这里提供两个渠道：</p><ul><li><a href="https://link.juejin.cn/?target=https://github.com/cj0x39e/echarts-map-data">echarts-map-data库</a>，包含包含 JS 与 GeoJSON 格式的地图数据，但是这个库已经不维护了所以还是推荐下面这个</li><li>推荐使用<a href="https://link.juejin.cn/?target=https://datav.aliyun.com/portal/school/atlas/area_selector">阿里云 DataV</a> 的工具下载相关地图数据，我使用的就是这个。</li></ul><p>通过是 <a href="https://link.juejin.cn/?target=https://datav.aliyun.com/portal/school/atlas/area_selector">阿里云 DataV</a> 下载了中国地图的<code>geoJSON</code>数据存放到本地。</p><h3 id="3）注册地图"><a href="#3）注册地图" class="headerlink" title="3）注册地图"></a>3）注册地图</h3><ul><li><code>mapName</code> 这里命名为 <code>china</code></li><li><code>opt</code> 参数是个对象，我们使用 <code>geoJSON</code>，把下载到本地<code>geoJson</code>数据引入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; geoJson &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./geojson&quot;</span>;<br><br>...<br><span class="hljs-comment">// 注册</span><br>echarts.<span class="hljs-title function_">registerMap</span>(<span class="hljs-string">&quot;china&quot;</span>, &#123; <span class="hljs-attr">geoJSON</span>: geoJson &#125;);<br>复制代码<br></code></pre></td></tr></table></figure><p>到此一个中国地图其实就可以简单的做一个呈现了。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2516b9a1bd0412c9e354849f99891d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="地图实现效果.png"></p><p>但具体在初始化得到echarts示例后所使用<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/api.html%23echartsInstance.setOption">echartsInstance.setOption</a>方法具体有哪些内容，下面我们来继续讲解。</p><h2 id="4-echartsInstance-setOption-的使用"><a href="#4-echartsInstance-setOption-的使用" class="headerlink" title="4.echartsInstance.setOption 的使用"></a>4.echartsInstance.setOption 的使用</h2><p>首先看API中关于参数的一些调用示例：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b363f0138b694f77a12d094dc364209d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="echartsInstance.setOption参数.png"></p><p><strong>这里主要使用到的是这个：<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23title">setOption的配置项手册</a></strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79126717e94f4038a031a6528ae8f924~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图形界面对应setOption的配置项.png"></p><p>上图标记的是我们当前地图中主要使用的 setOption 的配置项。</p><h3 id="1）title-标题组件"><a href="#1）title-标题组件" class="headerlink" title="1）title 标题组件"></a>1）<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23title">title</a> 标题组件</h3><p>这里主要对于主标题(<code>text</code>)进行设置和样式位置的修改。 还可以进行副标题(<code>subtext</code>)的设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">title</span>: &#123;<br>    <span class="hljs-comment">// 标题组件</span><br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;数据地图&quot;</span>, <span class="hljs-comment">// 主标题文本</span><br>    <span class="hljs-comment">// subtext: &#x27;数据来源于 xx平台&#x27;, // 副标题文本</span><br>    <span class="hljs-comment">// sublink: &#x27;http://xxx.html&#x27;, // 副标题文本超链接</span><br>    <span class="hljs-attr">left</span>: <span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-comment">// title 组件离容器左侧的距离,如果值为`&#x27;left&#x27;`, `&#x27;center&#x27;`, `&#x27;right&#x27;`，组件会根据相应的位置自动对齐。</span><br>    <span class="hljs-attr">textStyle</span>: &#123;<br>        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#000&quot;</span> <span class="hljs-comment">// 主标题文字的颜色</span><br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="2）visualMap-视觉映射组件"><a href="#2）visualMap-视觉映射组件" class="headerlink" title="2）visualMap 视觉映射组件"></a>2）<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23visualMap">visualMap</a> 视觉映射组件</h3><p><code>visualMap</code> 是视觉映射组件。可以定义为 <a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23visualMap-piecewise">分段型（visualMapPiecewise）</a> 或 <a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23visualMap-continuous">连续型（visualMapContinuous）</a>，通过 <code>type</code> 来区分。这里我们使用的是连续型(<code>type: &#39;continuous&#39;</code>)</p><p>下面根据渐变提供了两种渐变色 <code>color</code> 数组，可以根据喜欢选取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">visualMap</span>: &#123;<br>    <span class="hljs-comment">// 视觉映射组件</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;continuous&quot;</span>, <span class="hljs-comment">// 连续型</span><br>    <span class="hljs-attr">left</span>: <span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-comment">// visualMap 组件离容器左侧的距离,值为`&#x27;left&#x27;`, `&#x27;center&#x27;`, `&#x27;right&#x27;`，组件会根据相应的位置自动对齐。</span><br>    <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>,        <span class="hljs-comment">// 指定允许的最小值</span><br>    <span class="hljs-attr">max</span>: max,      <span class="hljs-comment">// 指定允许的最大值,这里进行动态设置</span><br>    <span class="hljs-attr">inRange</span>: &#123;     <span class="hljs-comment">// 定义 **在选中范围中** 的视觉元素</span><br>        <span class="hljs-comment">// 图元的颜色</span><br>        <span class="hljs-comment">// 这里以这数组所填写的颜色点作为基准，形成一种『渐变』的色带，数据映射到这个色带上</span><br>        <span class="hljs-attr">color</span>: [ <span class="hljs-comment">// 橘色效果</span><br>            <span class="hljs-string">&quot;#fff&quot;</span>,<br>            <span class="hljs-string">&quot;#fedeb5&quot;</span>,<br>            <span class="hljs-string">&quot;#f96a35&quot;</span>,<br>            <span class="hljs-string">&quot;#c3380e&quot;</span>,<br>            <span class="hljs-string">&quot;#942005&quot;</span><br>        ]<br>       <span class="hljs-comment">// color: [ // 蓝色效果</span><br>       <span class="hljs-comment">//     &#x27;#e5f7ff&#x27;,</span><br>       <span class="hljs-comment">//     &#x27;#096dd9&#x27;,</span><br>       <span class="hljs-comment">// ]</span><br>    &#125;,<br>    <span class="hljs-attr">text</span>: [<span class="hljs-string">`最大值：<span class="hljs-subst">$&#123;max&#125;</span>`</span>, <span class="hljs-number">0</span>],  <span class="hljs-comment">// 两端的文本,如 `[&#x27;High&#x27;, &#x27;Low&#x27;]`</span><br>    <span class="hljs-attr">textStyle</span>: &#123;<br>        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#000&quot;</span> <span class="hljs-comment">// visualMap 文字的颜色。</span><br>    &#125;<br>&#125;,<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="3）toolbox-工具栏"><a href="#3）toolbox-工具栏" class="headerlink" title="3）toolbox 工具栏"></a>3）<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23toolbox">toolbox</a> 工具栏</h3><p>内置有<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23toolbox.feature.saveAsImage">导出图片</a>，<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23toolbox.feature.dataView">数据视图</a>，<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23toolbox.feature.magicType">动态类型切换</a>，<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23toolbox.feature.dataZoom">数据区域缩放</a>，<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23toolbox.feature.reset">重置</a>五个工具。如下图所示部分功能：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26747bd131ee46cfab660823dc9c99a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="工具栏.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">toolbox</span>: &#123;<br>    <span class="hljs-comment">// 工具导航</span><br>    <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否显示工具栏组件。</span><br>    <span class="hljs-comment">//orient: &#x27;vertical&#x27;, // 工具栏 icon 的布局朝向。</span><br>    <span class="hljs-attr">left</span>: <span class="hljs-string">&quot;left&quot;</span>,         <span class="hljs-comment">// 工具栏组件离容器左侧的距离</span><br>    <span class="hljs-attr">top</span>: <span class="hljs-string">&quot;top&quot;</span>,           <span class="hljs-comment">// 工具栏组件离容器上侧的距离</span><br>    <span class="hljs-attr">feature</span>: &#123;   <span class="hljs-comment">// 各工具配置项</span><br>        <span class="hljs-comment">// dataView: &#123; readOnly: false &#125;, // 数据视图工具，可以展现当前图表所用的数据，编辑后可以动态更新。</span><br>        <span class="hljs-attr">restore</span>: &#123;&#125;,     <span class="hljs-comment">// 配置项还原</span><br>        <span class="hljs-attr">saveAsImage</span>: &#123;&#125;  <span class="hljs-comment">// 保存为图片</span><br>    &#125;<br>&#125;,<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="4）tooltip提示框组件"><a href="#4）tooltip提示框组件" class="headerlink" title="4）tooltip提示框组件"></a>4）<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23tooltip">tooltip</a>提示框组件</h3><p>提示框组件可以设置在多种地方，这里是设置在全局。鼠标悬浮到地图上显示的提示框就是通过这个属性进行设置的。</p><ul><li><pre><code class="hljs">trigger<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>   <br><br>  触发类型，有三种：<br><br>  - `item` 数据项图形触发，主要在散点图，饼图等无类目轴的图表中使用。<br>  - `axis` 坐标轴触发，主要在柱状图，折线图等会使用类目轴的图表中使用<br>  - `none` 什么都不触发。<br><br>```js<br>tooltip: &#123;<br>    <span class="hljs-regexp">//</span> 提示框<br>    trigger: <span class="hljs-string">&quot;item&quot;</span>, <span class="hljs-regexp">//</span> 触发类型<br>    showDelay: <span class="hljs-number">0</span>, <span class="hljs-regexp">//</span> 浮层显示的延迟，单位为 ms，默认没有延迟，也不建议设置。<br>    transitionDuration: <span class="hljs-number">0.2</span>, <span class="hljs-regexp">//</span> 提示框浮层的移动动画过渡时间，单位是 s，设置为 <span class="hljs-number">0</span> 的时候会紧跟着鼠标移动。<br>    formatter: <span class="hljs-keyword">function</span> (params) &#123; <span class="hljs-regexp">//</span> 提示框浮层内容格式器，支持字符串模板和回调函数两种形式<br>        let &#123; data = &#123;&#125; &#125; = params; <span class="hljs-regexp">//</span> 第一个参数 `params` 是 formatter 需要的数据集<br>        let &#123; value = <span class="hljs-number">0</span> &#125; = data;  <span class="hljs-regexp">//</span> 传入的数据值<br>        <span class="hljs-regexp">//</span> params.name 数据名，类目名<br>        return `<span class="hljs-variable">$&#123;params.name&#125;</span>&lt;br/&gt;个数: <span class="hljs-variable">$&#123;value&#125;</span>`;<br>    &#125;<br>&#125;,<br>复制代码<br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="5）series-map-地图"><a href="#5）series-map-地图" class="headerlink" title="5）series-map 地图"></a>5）<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23series-map">series-map</a> 地图</h3><p>地图主要用于地理区域数据的可视化，配合 <a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23visualMap">visualMap</a> 组件用于展示不同区域的人口分布密度等数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">series</span>: &#123;<br>    <span class="hljs-comment">// 地图,可以是数组，多个</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;map&quot;</span>,<br>    <span class="hljs-attr">map</span>: <span class="hljs-string">&quot;china&quot;</span>, <span class="hljs-comment">// 使用 registerMap 注册的地图名称</span><br>    <span class="hljs-attr">label</span>: &#123; <span class="hljs-comment">// 图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等。</span><br>        <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//显示省市名称</span><br>        <span class="hljs-attr">position</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">100</span>], <span class="hljs-comment">// 相对的百分比</span><br>        <span class="hljs-attr">fontSize</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-attr">offset</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>], <span class="hljs-comment">// 是否对文字进行偏移。默认不偏移。例如：`[30, 40]` 表示文字在横向上偏移 `30`，纵向上偏移 `40`。</span><br>        <span class="hljs-attr">align</span>: <span class="hljs-string">&quot;left&quot;</span> <span class="hljs-comment">// 文字水平对齐方式，默认自动。</span><br>    &#125;,<br>    <span class="hljs-attr">itemStyle</span>: &#123; <span class="hljs-comment">// 地图区域的多边形 图形样式</span><br>        <span class="hljs-attr">areaColor</span>: <span class="hljs-string">&quot;#fff&quot;</span> <span class="hljs-comment">// 地图图形颜色</span><br>    &#125;,<br>    <span class="hljs-attr">roam</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开启鼠标缩放和平移漫游。默认不开启。如果只想要开启缩放或者平移，可以设置成 `&#x27;scale&#x27;` 或者 `&#x27;move&#x27;`。设置成 `true` 为都开启</span><br>    <span class="hljs-attr">zoom</span>: <span class="hljs-number">1.2</span>, <span class="hljs-comment">// 当前视角的缩放比例</span><br>    <span class="hljs-attr">scaleLimit</span>: &#123; <span class="hljs-comment">// 滚轮缩放的极限控制，默认的缩放为`1`</span><br>        <span class="hljs-attr">max</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 最大的缩放值</span><br>        <span class="hljs-attr">min</span>: <span class="hljs-number">1</span>  <span class="hljs-comment">// 最小的缩放值</span><br>    &#125;,<br>    <span class="hljs-attr">top</span>: <span class="hljs-string">&quot;10%&quot;</span> <span class="hljs-comment">// 距离顶部距离</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="这里主要对参数-data和-nameMap-做个说明："><a href="#这里主要对参数-data和-nameMap-做个说明：" class="headerlink" title="这里主要对参数 data和 nameMap 做个说明："></a><strong>这里主要对参数 <code>data</code>和 <code>nameMap</code> 做个说明：</strong></h4><h5 id="1-data-地图系列中的数据内容数组，具体使用如下图："><a href="#1-data-地图系列中的数据内容数组，具体使用如下图：" class="headerlink" title="1. data 地图系列中的数据内容数组，具体使用如下图："></a>1. <a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23series-map.data">data</a> 地图系列中的数据内容数组，具体使用如下图：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">我们可以直接给`data`赋值我们获取的地图数据。当然也可以通过<span class="hljs-selector-attr">[dataset]</span>(https://echarts.apache.org/zh/option.html#dataset)来设置，效果是一样的。<br>复制代码<br>series: &#123;<br>    ...<br>    data: [<br>      &#123; name: <span class="hljs-string">&quot;内蒙古&quot;</span>, value: <span class="hljs-number">1000</span> &#125;,<br>      &#123; name: <span class="hljs-string">&quot;北京&quot;</span>, value: <span class="hljs-number">700</span> &#125;,<br>      &#123; name: <span class="hljs-string">&quot;河北&quot;</span>, value: <span class="hljs-number">30</span> &#125;,<br>      &#123; name: <span class="hljs-string">&quot;江苏&quot;</span>, value: <span class="hljs-number">400</span> &#125;,<br>      &#123; name: <span class="hljs-string">&quot;西藏&quot;</span>, value: <span class="hljs-number">200</span> &#125;<br>    ]<br> &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db16bb360f0a429c9e963c7631509f72~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="data设置效果图.png"></p><h5 id="2-nameMap-自定义地区的名称映射"><a href="#2-nameMap-自定义地区的名称映射" class="headerlink" title="2. nameMap 自定义地区的名称映射"></a>2. <a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23series-map.nameMap">nameMap</a> 自定义地区的名称映射</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">series</span>: &#123;<br>    ...<br>    <span class="hljs-attr">nameMap</span>:&#123;<br>        <span class="hljs-string">&#x27;北京&#x27;</span>:<span class="hljs-string">&#x27;Beijing&#x27;</span>,<br>        <span class="hljs-string">&#x27;内蒙古&#x27;</span>:<span class="hljs-string">&#x27;NeiMengGu&#x27;</span>,<br>    &#125;,<br> &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>设置 <strong>北京和内蒙古</strong> 后的效果图如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c9fd65dd2a44f76ab90467303209394~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="nameMap效果图.png"></p><p><strong>注意：</strong> 这里的 “北京”、“内蒙古” 是关联的 GeoJSON 数据的要素中 <code>name</code> 字段进行映射的。 如果写成 “北京市” 这样就映射失败了。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fba5e88cecda423b96cc63130b0cacbc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="geojson数据部分显示.png"></p><h5 id="3-nameProperty"><a href="#3-nameProperty" class="headerlink" title="3. nameProperty"></a>3. <a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23series-map.nameProperty">nameProperty</a></h5><p><code>nameProperty</code>从 <code>v4.8.0</code> 开始支持, 默认是 <code>&#39;name&#39;</code>，针对 GeoJSON 要素的自定义属性名称，作为主键用于关联数据点和 GeoJSON 地理要素。例如：</p><p>我把 <code>nameProperty</code> 设置为 <code>&#39;adcode&#39;</code>，是省市的code。地图显示的省市名称都变成code值了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// GeoJSON数据</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Feature&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;adcode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">110000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;北京&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;geometry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> ... <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>我用 <code>nameMap</code> 对省市名称和 <code>adcode</code> 值做了个映射。数据点中的 <code>name：北京</code>的数据就又可以显示在图表上了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">series</span>: &#123;<br>    ...<br>    <span class="hljs-attr">nameMap</span>:&#123;<br>        <span class="hljs-number">110000</span>: <span class="hljs-string">&quot;北京&quot;</span>,<br>        <span class="hljs-number">130000</span>: <span class="hljs-string">&quot;河北&quot;</span>,<br>        <span class="hljs-number">150000</span>: <span class="hljs-string">&quot;内蒙古&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">nameProperty</span>:<span class="hljs-string">&#x27;adcode&#x27;</span>,<br>    <span class="hljs-attr">data</span>: [<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1000</span> &#125;,<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">700</span> &#125;,<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;河北&quot;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">30</span> &#125;,<br>    ],<br> &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33a8fc745a4b486cbbbbeef7e4c4bfcc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="效果图.png"></p><h3 id="6）dataset-数据集组件"><a href="#6）dataset-数据集组件" class="headerlink" title="6）dataset 数据集组件"></a>6）<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23dataset">dataset</a> 数据集组件</h3><p><code>数据集</code>（<code>dataset</code>）组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射。这在不少场景下能带来使用上的方便。</p><p>关于 <code>dataset</code> 的详情，请参见<a href="https://link.juejin.cn/?target=https://echarts.apache.org/handbook/zh/concepts/dataset">教程</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">dataset</span>: &#123;<br>    <span class="hljs-attr">source</span>: data <span class="hljs-comment">// 原始数据</span><br>&#125;,<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="三、地图代码优化"><a href="#三、地图代码优化" class="headerlink" title="三、地图代码优化"></a>三、地图代码优化</h2><p>上面把地图实现之后，这一步对于一些地方做一些优化</p><h3 id="1-实现一个renderMap函数"><a href="#1-实现一个renderMap函数" class="headerlink" title="1. 实现一个renderMap函数"></a>1. 实现一个renderMap函数</h3><p>通过 <code>echarts.getInstanceByDom</code> 获取 dom 容器上的实例。如果已经有了就不需要再重新执行 <code>echarts.init</code> 进行初始化了，可以直接使用已经初始化好的 echarts 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br><span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">let</span> mapInstance = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">renderMap</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> renderedMapInstance = echarts.<span class="hljs-title function_">getInstanceByDom</span>(ref.<span class="hljs-property">current</span>);<br>    <span class="hljs-keyword">if</span> (renderedMapInstance) &#123;<br>      mapInstance = renderedMapInstance;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      mapInstance = echarts.<span class="hljs-title function_">init</span>(ref.<span class="hljs-property">current</span>);<br>    &#125;<br>    mapInstance.<span class="hljs-title function_">setOption</span>(<br>      ...<br>    );<br>&#125;;<br>...<br><br><span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">width:</span> &quot;<span class="hljs-attr">100</span>%&quot;, <span class="hljs-attr">height:</span> &quot;<span class="hljs-attr">99vh</span>&quot; &#125;&#125; <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="2-利用echartsInstance-resize改变图表尺寸"><a href="#2-利用echartsInstance-resize改变图表尺寸" class="headerlink" title="2.利用echartsInstance.resize改变图表尺寸"></a>2.利用<code>echartsInstance.resize</code>改变图表尺寸</h3><p>我们当改变窗口大小的时候想让图表也自适应改变大小，可以利用<a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/api.html%23echartsInstance.resize">echartsInstance.resize</a> 改变图表尺寸，在容器大小发生改变时需要手动调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 调用 echarts实例上 resize 方法</span><br>      mapInstance.<span class="hljs-title function_">resize</span>();<br>    &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 销毁实例，销毁后实例无法再被使用。</span><br>      mapInstance &amp;&amp; mapInstance.<span class="hljs-title function_">dispose</span>();<br>    &#125;;<br>&#125;, []);<br>...<br>复制代码<br></code></pre></td></tr></table></figure><p><a href="https://link.juejin.cn/?target=https://codesandbox.io/s/zhong-guo-di-tu-fen-bu-shu-ju-xian-shi-gzpbm">以上代码demo请点击查看</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://link.juejin.cn/?target=https://github.com/cj0x39e/echarts-map-data">echarts-map-data库</a></li><li><a href="https://link.juejin.cn/?target=http://datav.aliyun.com/portal/school/atlas/area_selector">阿里云 DataV</a></li><li><a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/index.html">echarts 官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>echarts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>echarts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常见操作</title>
    <link href="./2023/03/08/git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    <url>./2023/03/08/git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="git常见操作"><a href="#git常见操作" class="headerlink" title="git常见操作"></a>git常见操作</h1><p><em><strong>一般流程</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 文件夹初始化</span><br>1、git init<br><br><span class="hljs-comment"># 添加远程仓库</span><br>2、git remote add gitee(地址缩写名) https://gitee.com/xxxxx.git(url)<br><br><span class="hljs-comment"># 本地创建并切换到test分支(默认远端仓库存在test分支)</span><br>3、git checkout -b <span class="hljs-built_in">test</span><br>或者在提交的操作push中，<br>(操作发布<span class="hljs-built_in">test</span>分支指的是同步<span class="hljs-built_in">test</span>分支的代码到远程服务器(默认本地有<span class="hljs-built_in">test</span>分支,并推送至远端仓库)git push origin <span class="hljs-built_in">test</span>:<span class="hljs-built_in">test</span>  <span class="hljs-comment"># 这样远程仓库也有一个test分支了)</span><br><br><span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span><br>4、git add .<br><br><span class="hljs-comment"># 提交暂存区到仓库区</span><br>5、git commit -m <span class="hljs-string">&#x27;填写附带内容&#x27;</span><br><br><span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span><br>6、git pull gitee <span class="hljs-built_in">test</span><br><br><span class="hljs-comment"># 上传本地指定分支到远程仓库</span><br>7、git push gitee <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.Workspace：工作区 <br>2. Index / Stage：暂存区 <br>3. Repository：仓库区（或本地仓库） <br>4. Remote：远程仓库<br><br><span class="hljs-comment"># 在文件夹中初始化仓库</span><br><span class="hljs-comment"># 在当前目录新建一个Git代码库 </span><br>git init <br><span class="hljs-comment"># 新建一个目录，将其初始化为Git代码库</span><br>git init [project-name]<br><span class="hljs-comment"># 下载一个项目和它的整个代码历史 </span><br>git <span class="hljs-built_in">clone</span> [url]<br><br>Git的设置文件为.gitconfig ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目 配置）<br><span class="hljs-comment"># 显示当前的Git配置</span><br>git config --list <br><br><span class="hljs-comment"># 编辑Git配置文件 </span><br>git config -e [--global] <br><br><span class="hljs-comment"># 设置提交代码时的用户信息</span><br>git config [--global] user.name <span class="hljs-string">&quot;[name]&quot;</span> <br>git config [--global] user.email <span class="hljs-string">&quot;[email address]&quot;</span><br></code></pre></td></tr></table></figure><hr><p><em><strong>问题报错</strong></em></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"> ! [rejected]        develop -&gt; develop (non-fast-forward)<br><span class="hljs-symbol">error:</span> failed <span class="hljs-keyword">to</span> push some refs <span class="hljs-keyword">to</span> <span class="hljs-comment">&#x27;https://gitee.com/xxxx.git&#x27;</span><br><span class="hljs-symbol">hint:</span> Updates were rejected because the tip <span class="hljs-keyword">of</span> your current branch <span class="hljs-built_in">is</span> behind<br><span class="hljs-symbol">hint:</span> its remote counterpart. Integrate the remote changes (e.g.<br><span class="hljs-symbol">hint:</span> <span class="hljs-comment">&#x27;git pull ...&#x27;) before pushing again.</span><br><span class="hljs-symbol">hint:</span> See the <span class="hljs-comment">&#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></code></pre></td></tr></table></figure><p><strong>解决方式一：(大部分情况下弃用)</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">杜绝使用此方法，因为会使用本地仓库的代码覆盖掉远程仓库中的代码<br>git push --force origin <span class="hljs-keyword">master</span> <span class="hljs-title">强制提交</span><br></code></pre></td></tr></table></figure><p><strong>解决方式二：</strong></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">发布<span class="hljs-built_in">dev</span>分支指的是同步<span class="hljs-built_in">dev</span>分支的代码到远程服务器<br>git push origin <span class="hljs-built_in">dev</span>:<span class="hljs-built_in">dev</span>  # 这样远程仓库也有一个<span class="hljs-built_in">dev</span>分支了<br></code></pre></td></tr></table></figure><hr><p><em><strong>问题报错</strong></em></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"> ! [rejected]        master -&gt; master (fetch <span class="hljs-keyword">first</span>)<br>error: failed <span class="hljs-built_in">to</span> push some refs <span class="hljs-built_in">to</span> <span class="hljs-string">&#x27;https://gitee.com/xxxx.git&#x27;</span><br>hint: Updates were rejected because <span class="hljs-keyword">the</span> remote <span class="hljs-keyword">contains</span> work that you <span class="hljs-built_in">do</span><br>hint: <span class="hljs-keyword">not</span> have locally. This is usually caused <span class="hljs-keyword">by</span> another repository pushing<br>hint: <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> same ref. You may want <span class="hljs-built_in">to</span> <span class="hljs-keyword">first</span> integrate <span class="hljs-keyword">the</span> remote changes<br>hint: (e.g., <span class="hljs-string">&#x27;git pull ...&#x27;</span>) <span class="hljs-keyword">before</span> pushing again.<br>hint: See <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p><strong>解决方式：</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">报错的原因是因为，每个仓库都有一个分支，也可以理解为大仓库里的小仓库，我们只是跟线上远程仓库有了关联，但没有跟线上远程仓库的某个分支关联，所以我们没法提交<br>在终端输入 git pull --rebase origin <span class="hljs-keyword">master</span> <span class="hljs-title">即可跟刚创建的线上远程仓库的默认分支master</span>关联<br>这时再执行一下 git push -u origin <span class="hljs-keyword">master</span> <span class="hljs-title">即可将我们的项目文件上传到关联的线上远程文件中</span><br></code></pre></td></tr></table></figure><hr><p><em><strong>问题报错</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$   git push -u gitee <span class="hljs-built_in">test</span><br>error: src refspec <span class="hljs-built_in">test</span> does not match any<br>error: failed to push some refs to <span class="hljs-string">&#x27;https://gitee.com/beimingkunpeng/hp.git&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>解决方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">原因：本地没有 <span class="hljs-built_in">test</span> 分支，或者当前没有在 <span class="hljs-built_in">test</span> 分支上，而我又往远程仓库的 <span class="hljs-built_in">test</span> 上 push，导致无法 push<br>按照规范的方式来说，执行以下几条命令：<br><br>git checkout -b develop origin/develop（从远程develop分支上创建本地develop分支）<br>如果本地有develop分支了就执行：git checkout develop<br>执行：git pull origin develop<br>合并：git merge 你的分支名<br>提交：git push origin develop<br>成功处理问题<br>或者你也可以执行：git push origin 当前所处的分支名:develop 强行把自己的分支push到远程develop分支，这样做虽然能成功，但显然是错误的<br></code></pre></td></tr></table></figure><hr><p><em><strong>问题报错</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">remote: [session-d94777a6] xxxxx: Incorrect username or password (access token)<br>fatal: Authentication failed <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;https://gitee.com/xxxxx&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>解决方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">账号或密码错误，重新登录即可<br></code></pre></td></tr></table></figure><hr><p><em><strong>问题警告</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">warning: LF will be replaced by CRLF <span class="hljs-keyword">in</span> xxxxx      <br>The file will have its original line endings <span class="hljs-keyword">in</span> your working directory<br>warning: LF will be replaced by CRLF <span class="hljs-keyword">in</span> xxxxxx <br>The file will have its original line endings <span class="hljs-keyword">in</span> your working directory<br></code></pre></td></tr></table></figure><p><strong>解决方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">首先问题出在不同操作系统所使用的换行符是不一样的，下面罗列一下三大主流操作系统的换行符：<br>Uinx/Linux采用换行符LF表示下一行（LF：LineFeed，中文意思是换行）；<br>Dos和Windows采用回车+换行CRLF表示下一行（CRLF：CarriageReturn LineFeed，中文意思是回车换行）；<br>Mac OS采用回车CR表示下一行（CR：CarriageReturn，中文意思是回车）。<br>在Git中，可以通过以下命令来显示当前你的Git中采取哪种对待换行符的方式<br><br>git config core.autocrlf<br><br>此命令会有三个输出，“<span class="hljs-literal">true</span>”，“<span class="hljs-literal">false</span>”或者“input”<br>为<span class="hljs-literal">true</span>时，Git会将你add的所有文件视为文本问价你，将结尾的CRLF转换为LF，而checkout时会再将文件的LF格式转为CRLF格式。<br>为<span class="hljs-literal">false</span>时，line endings不做任何改变，文本文件保持其原来的样子。<br>为input时，add时Git会把CRLF转换为LF，而check时仍旧为LF，所以Windows操作系统不建议设置此值。<br></code></pre></td></tr></table></figure><hr><h2 id="二、增加-x2F-删除文件"><a href="#二、增加-x2F-删除文件" class="headerlink" title="二、增加&#x2F;删除文件"></a>二、增加&#x2F;删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加指定文件到暂存区</span><br>git add [file1] [file2] ...<br><br><span class="hljs-comment"># 添加指定目录到暂存区，包括子目录</span><br>git add [<span class="hljs-built_in">dir</span>]<br><br><span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span><br>git add .<br><br><span class="hljs-comment"># 添加每个变化前，都会要求确认</span><br><span class="hljs-comment"># 对于同一个文件的多处变化，可以实现分次提交</span><br>git add -p<br><br><span class="hljs-comment"># 删除工作区文件，并且将这次删除放入暂存区</span><br>git <span class="hljs-built_in">rm</span> [file1] [file2] ...<br><br><span class="hljs-comment"># 停止追踪指定文件，但该文件会保留在工作区</span><br>git <span class="hljs-built_in">rm</span> --cached [file]<br><br><span class="hljs-comment"># 改名文件，并且将这个改名放入暂存区</span><br>git <span class="hljs-built_in">mv</span> [file-original] [file-renamed]<br></code></pre></td></tr></table></figure><h2 id="三、代码提交"><a href="#三、代码提交" class="headerlink" title="三、代码提交"></a>三、代码提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 提交暂存区到仓库区</span><br>git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br>git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br>git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br>git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br>git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br>git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure><h2 id="四、分支"><a href="#四、分支" class="headerlink" title="四、分支"></a>四、分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有本地分支</span><br>git branch<br><br><span class="hljs-comment"># 列出所有远程分支</span><br>git branch -r<br><br><span class="hljs-comment"># 列出所有本地分支和远程分支</span><br>git branch -a<br><br><span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span><br>git branch [branch-name]<br><br><span class="hljs-comment"># 新建一个分支，并切换到该分支</span><br>git checkout -b [branch]<br><br><span class="hljs-comment"># 新建一个分支，指向指定commit</span><br>git branch [branch] [commit]<br><br><span class="hljs-comment"># 新建一个分支，与指定的远程分支建立追踪关系</span><br>git branch --track [branch] [remote-branch]<br><br><span class="hljs-comment"># 切换到指定分支，并更新工作区</span><br>git checkout [branch-name]<br><br><span class="hljs-comment"># 切换到上一个分支</span><br>git checkout -<br><br><span class="hljs-comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br>git branch --set-upstream [branch] [remote-branch]<br><br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>git merge [branch]<br><br><span class="hljs-comment"># 选择一个commit，合并进当前分支</span><br>git cherry-pick [commit]<br><br><span class="hljs-comment"># 删除分支</span><br>git branch -d [branch-name]<br><br><span class="hljs-comment"># 删除远程分支</span><br>git push origin --delete [branch-name]<br>git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure><h2 id="五、标签"><a href="#五、标签" class="headerlink" title="五、标签"></a>五、标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有tag</span><br>git tag<br><br><span class="hljs-comment"># 新建一个tag在当前commit</span><br>git tag [tag]<br><br><span class="hljs-comment"># 新建一个tag在指定commit</span><br>git tag [tag] [commit]<br><br><span class="hljs-comment"># 删除本地tag</span><br>git tag -d [tag]<br><br><span class="hljs-comment"># 删除远程tag</span><br>git push origin :refs/tags/[tagName]<br><br><span class="hljs-comment"># 查看tag信息</span><br>git show [tag]<br><br><span class="hljs-comment"># 提交指定tag</span><br>git push [remote] [tag]<br><br><span class="hljs-comment"># 提交所有tag</span><br>git push [remote] --tags<br><br><span class="hljs-comment"># 新建一个分支，指向某个tag</span><br>git checkout -b [branch] [tag]<br></code></pre></td></tr></table></figure><h2 id="六、查看信息"><a href="#六、查看信息" class="headerlink" title="六、查看信息"></a>六、查看信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示有变更的文件</span><br>git status<br><br><span class="hljs-comment"># 显示当前分支的版本历史</span><br>git <span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 显示commit历史，以及每次commit发生变更的文件</span><br>git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br><br><span class="hljs-comment"># 搜索提交历史，根据关键词</span><br>git <span class="hljs-built_in">log</span> -S [keyword]<br><br><span class="hljs-comment"># 显示某个commit之后的所有变动，每个commit占据一行</span><br>git <span class="hljs-built_in">log</span> [tag] HEAD --pretty=format:%s<br><br><span class="hljs-comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br>git <span class="hljs-built_in">log</span> [tag] HEAD --grep feature<br><br><span class="hljs-comment"># 显示某个文件的版本历史，包括文件改名</span><br>git <span class="hljs-built_in">log</span> --follow [file]<br>git whatchanged [file]<br><br><span class="hljs-comment"># 显示指定文件相关的每一次diff</span><br>git <span class="hljs-built_in">log</span> -p [file]<br><br><span class="hljs-comment"># 显示过去5次提交</span><br>git <span class="hljs-built_in">log</span> -5 --pretty --oneline<br><br><span class="hljs-comment"># 显示所有提交过的用户，按提交次数排序</span><br>git shortlog -sn<br><br><span class="hljs-comment"># 显示指定文件是什么人在什么时间修改过</span><br>git blame [file]<br><br><span class="hljs-comment"># 显示暂存区和工作区的差异</span><br>git diff<br><br><span class="hljs-comment"># 显示暂存区和上一个commit的差异</span><br>git diff --cached [file]<br><br><span class="hljs-comment"># 显示工作区与当前分支最新commit之间的差异</span><br>git diff HEAD<br><br><span class="hljs-comment"># 显示两次提交之间的差异</span><br>git diff [first-branch]...[second-branch]<br><br><span class="hljs-comment"># 显示今天你写了多少行代码</span><br>git diff --shortstat <span class="hljs-string">&quot;@&#123;0 day ago&#125;&quot;</span><br><br><span class="hljs-comment"># 显示某次提交的元数据和内容变化</span><br>git show [commit]<br><br><span class="hljs-comment"># 显示某次提交发生变化的文件</span><br>git show --name-only [commit]<br><br><span class="hljs-comment"># 显示某次提交时，某个文件的内容</span><br>git show [commit]:[filename]<br><br>显示当前分支的最近几次提交<br>git reflog<br></code></pre></td></tr></table></figure><h2 id="七、远程同步"><a href="#七、远程同步" class="headerlink" title="七、远程同步"></a>七、远程同步</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载远程仓库的所有变动</span><br>git fetch [remote]<br><br><span class="hljs-comment"># 显示所有远程仓库</span><br>git remote -v<br><br><span class="hljs-comment"># 显示某个远程仓库的信息</span><br>git remote show [remote]<br><br><span class="hljs-comment"># 增加一个新的远程仓库，并命名</span><br>git remote add [shortname] [url]<br><br><span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span><br>git pull [remote] [branch]<br><br><span class="hljs-comment"># 上传本地指定分支到远程仓库</span><br>git push [remote] [branch]<br><br><span class="hljs-comment"># 发布dev分支指的是同步dev分支的代码到远程服务器</span><br>git push origin dev:dev  <span class="hljs-comment"># 这样远程仓库也有一个dev分支了</span><br><br><span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span><br>git push [remote] --force<br><br><span class="hljs-comment"># 推送所有分支到远程仓库</span><br>git push [remote] --all<br></code></pre></td></tr></table></figure><h2 id="八、撤销"><a href="#八、撤销" class="headerlink" title="八、撤销"></a>八、撤销</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br>git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br>git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br>git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br>git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br>git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br>git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br>git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br>git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br>git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br>git stash<br>git stash pop<br></code></pre></td></tr></table></figure><h2 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成一个可供发布的压缩包</span><br>git archive<br></code></pre></td></tr></table></figure><h2 id="十、分支合并"><a href="#十、分支合并" class="headerlink" title="十、分支合并"></a>十、分支合并</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">１，git push origin develop:<span class="hljs-keyword">master</span> <span class="hljs-title">-f</span><br>就可以把本地的develop分支强制(-f)推送到远程<span class="hljs-keyword">master</span><br><span class="hljs-title">２，</span><br><span class="hljs-title">git</span> checkout <span class="hljs-keyword">master</span> <span class="hljs-title">// 切换到旧的分支</span><br><span class="hljs-title">git</span> reset --hard develop // 将本地的旧分支 <span class="hljs-keyword">master</span> <span class="hljs-title">重置成 develop</span><br>git push origin <span class="hljs-keyword">master</span> <span class="hljs-title">--force</span> // 再推送到远程仓库<br></code></pre></td></tr></table></figure><p>可参考：</p><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">阮一峰_git命令清单</a></p><p><a href="https://my.oschina.net/u/3915083/blog/4901928">git操作</a></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态网页技术———HTML5知识点汇总</title>
    <link href="./2023/03/08/HTML%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>./2023/03/08/HTML%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="静态网页技术———HTML5知识点汇总"><a href="#静态网页技术———HTML5知识点汇总" class="headerlink" title="静态网页技术———HTML5知识点汇总"></a>静态网页技术———HTML5知识点汇总</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!--水平线标记--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:982px;&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--标题文字标记，n表示数字--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">hn</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">hn</span>&gt;</span><br><span class="hljs-comment">&lt;!--//段落标记--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!--//换行标记--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--    //块标记，默认状态是占据一行--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-comment">&lt;!--   //块标记，默认状态是行间的一部分--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    //有序列表标记&lt;ol&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    //type=&quot;1&quot;表示是数字1、2...有序标记，（默认）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>数字有序标记<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    //type=&quot;a&quot;表示是小写字母a、b...有序标记--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>小写字母有序标记<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    //type=&quot;A&quot;表示是大写字母A、B...有序标记--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;A&quot;</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>大写字母有序标记<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    //type=&quot;i&quot;表示是小写罗马数字i、ii...有序标记--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;i&quot;</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>小写罗马数字有序标记<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    //type=&quot;I&quot;表示是大写罗马数字I、II...有序标记--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;I&quot;</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>大写罗马数字有序标记<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--    //无序列表标记&lt;ul&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    //type=&quot;disc&quot;表示是实心圆点无序标记，（默认）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;disc&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>实心圆点无序标记<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    //type=&quot;circle&quot;表示是空心圆圈无序标记，（默认）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;circle&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>空心圆圈无序标记<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    //type=&quot;Square&quot;表示是方形无序标记，（默认）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Square&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>方形无序标记<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    //自定义列表--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名称<span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>说明<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>用户名<span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>6~18个字符，需以字母开头<br>        <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>密码<span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>6~18个字符，区分大小写<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br><span class="hljs-comment">&lt;!--        // articl元素代表文档，页面或应用程序独立的、完整的、可以独立被外部引用的内容--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-comment">&lt;!--        // section元素中的内容可以单独存储到数据库中或输出到Word文档中--&gt;</span><br><span class="hljs-comment">&lt;!--        // 在HTML5中，article元素可以看成是一种特殊类型的section元素--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    //nav元素是一个可以用作页面导航的链接组--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;链接地址&quot;</span>&gt;</span>这是超链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;链接地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-comment">&lt;!--        // aside元素用来表示当前页面或文章的附属信息部分--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-comment">&lt;!--        页面标题--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    //footer元素一般作为其上层容器元素的注脚--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>版权信息<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>联系方式<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    图像标记&lt;img/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:200px; height:200px; border:10px solid #0000ff;&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;middle&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    boder属性表示边框--&gt;</span><br><span class="hljs-comment">&lt;!--    align属性设置图像对齐方式--&gt;</span><br><span class="hljs-comment">&lt;!--    align属性值 ：--&gt;</span><br><span class="hljs-comment">&lt;!--    top图像顶部与同行文字或图片顶部对齐--&gt;</span><br><span class="hljs-comment">&lt;!--    middle图像中部与同行文字或图片中部对齐--&gt;</span><br><span class="hljs-comment">&lt;!--    bottom图像底部与同行文字或图片底部对齐--&gt;</span><br><span class="hljs-comment">&lt;!--    left图像在文字左侧--&gt;</span><br><span class="hljs-comment">&lt;!--    right图像在文字右侧--&gt;</span><br><span class="hljs-comment">&lt;!--    absbottom图像底部与同行最低项的底部对齐，常用于netscape--&gt;</span><br><span class="hljs-comment">&lt;!--    absmiddle图像中部与同行最大项的中部对齐，常用于netscape--&gt;</span><br><span class="hljs-comment">&lt;!--    baseline图像底部与文本基准线对齐，常用于netscape--&gt;</span><br><span class="hljs-comment">&lt;!--    texttop图像顶部与同行最高项的顶部对齐，常用于netscape--&gt;</span><br><br><br><span class="hljs-comment">&lt;!--    //多媒体文件标记&lt;embed&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">autostart</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">loop</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">embed</span>&gt;</span><br><span class="hljs-comment">&lt;!--    //src属性用来指定插入的多媒体文件的地址或多媒体文件名--&gt;</span><br><span class="hljs-comment">&lt;!--    //autostart属性用来设置多媒体文件是否自动播放true/false--&gt;</span><br><span class="hljs-comment">&lt;!--    //loop属性用来设置多媒体文件是否循环播放true/false--&gt;</span><br><br><span class="hljs-comment">&lt;!--    //视频标记&lt;video&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span>&gt;</span>替代文字<span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br><span class="hljs-comment">&lt;!--    属性        值            说明--&gt;</span><br><span class="hljs-comment">&lt;!--    src        url           要播放视频的URL--&gt;</span><br><span class="hljs-comment">&lt;!--    autoplay   autoplay      视屏就绪后马上播放--&gt;</span><br><span class="hljs-comment">&lt;!--    controls   controls      添加播放、暂停和音量等控件--&gt;</span><br><span class="hljs-comment">&lt;!--    width      像素           设置时评播放器的宽度--&gt;</span><br><span class="hljs-comment">&lt;!--    heigth     像素           设置视频播放器的高度--&gt;</span><br><span class="hljs-comment">&lt;!--    loop       loop           设置视频是否循环播放--&gt;</span><br><span class="hljs-comment">&lt;!--    preload    preload        视频在页面加载时进行加载，并预备播放--&gt;</span><br><br><br><br><span class="hljs-comment">&lt;!--音频标记&lt;audio&gt;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span>&gt;</span> 替代内容<span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--超链接标记&lt;a&gt;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>链接标题<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!--超链接target的值及说明--&gt;</span><br><span class="hljs-comment">&lt;!--parent   当前窗口的上级窗口，一般在框架中使用--&gt;</span><br><span class="hljs-comment">&lt;!--blank    在新窗口中打开--&gt;</span><br><span class="hljs-comment">&lt;!--self     在同一窗口打开，和默认值一致--&gt;</span><br><span class="hljs-comment">&lt;!--top      在浏览器的整个窗口打开，忽略任何框架--&gt;</span><br><br><span class="hljs-comment">&lt;!--表单定义标记&lt;form&gt;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;formname&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;表单传送方式post/get&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;表单编码方式encoding&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-comment">&lt;!--在HTML5中增加formaction属性和formmethod属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testform&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;test.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    第一个测试按钮：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;n1&quot;</span> <span class="hljs-attr">formaction</span>=<span class="hljs-string">&quot;h1.html&quot;</span> <span class="hljs-attr">formmethod</span>=<span class="hljs-string">&quot;post&quot;</span> /&gt;</span><br>    第二个测试按钮: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;n2&quot;</span> <span class="hljs-attr">formaction</span>=<span class="hljs-string">&quot;h2.html&quot;</span> <span class="hljs-attr">formmethod</span>=<span class="hljs-string">&quot;post&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--输入标记&lt;input&gt;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;控件名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;控件类型&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;12 允许用户输入最大字符数&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;8 指定文本框的宽度&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;文本框默认值&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--&lt;input&gt;标记的type属性值及说明--&gt;</span><br><span class="hljs-comment">&lt;!--属性值     说明--&gt;</span><br><span class="hljs-comment">&lt;!--text      文本框--&gt;</span><br><span class="hljs-comment">&lt;!--password  密码框--&gt;</span><br><span class="hljs-comment">&lt;!--file      文件域--&gt;</span><br><span class="hljs-comment">&lt;!--checkbox  复选框--&gt;</span><br><span class="hljs-comment">&lt;!--radio     单选按钮--&gt;</span><br><span class="hljs-comment">&lt;!--button    标准按钮--&gt;</span><br><span class="hljs-comment">&lt;!--submit    提交按钮--&gt;</span><br><span class="hljs-comment">&lt;!--reset     重置按钮--&gt;</span><br><span class="hljs-comment">&lt;!--image     图像域--&gt;</span><br><br><span class="hljs-comment">&lt;!--placehoder属性是指当文本框&lt;input type=&quot;text&quot;&gt;处于未输入状态时文本框中显示的输入提示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;default text&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!--autofocus属性，若给文本框、选择框或按钮等控制加上该属性，则当页面打开时，--&gt;</span><br><span class="hljs-comment">&lt;!--改控件将自动获得焦点，从而替代使用JavaScript代码，注意：一个页面内只能有一个控件具有该属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">autofocus</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--list属性，在HTNML5中，为单行文本框&lt;input type=&quot;text&quot;&gt;增加了一个list属性，--&gt;</span><br><span class="hljs-comment">&lt;!--该属性的值是莫格datalist元素的id，datalist也是HTML5中新增的元素，该元素类似于选择框（&lt;select&gt;),但是当--&gt;</span><br><span class="hljs-comment">&lt;!--用户想要设定的值不在选择列表之内时，允许其自行输入，datalist元素本身并不显示，而是当--&gt;</span><br><span class="hljs-comment">&lt;!--文本框获得焦点时以提示输入的方式显示--&gt;</span><br><br>请选择文本：<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;greeting&quot;</span> <span class="hljs-attr">list</span>=<span class="hljs-string">&quot;greeting&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--使用style=&quot;display:none;&quot;将detalist元素设定为不显示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">datalist</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;greeting&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;选项1&quot;</span>&gt;</span>选项1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;选项2&quot;</span>&gt;</span>选项2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">datalist</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--autocomplete属性用于设置输入时是否自动完成，提供了十分方便辅助输入功能。对于autocomplete属性，--&gt;</span><br><span class="hljs-comment">&lt;!--可以指定其值为&quot;on&quot;、”off“、”“三类值。不指定时，使用浏览器的默认值（取决于个浏览器的设定）。该属性设置为on时，--&gt;</span><br><span class="hljs-comment">&lt;!--可以显示指定待输入的数据列表。如果使用datalist元素与list属性提供待输入的数据列表，自动完成时，可以将该datalist元素--&gt;</span><br><span class="hljs-comment">&lt;!--中的数据作为待输入的数据在文本框钟自动显示。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;school&quot;</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">&quot;on&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!--required属性，可以应用在大多数输入元素上（除了隐藏元素、图片元素按钮外）。在提交时，--&gt;</span><br><span class="hljs-comment">&lt;!--如果元素内容为空白，则不允许提交，同时在浏览器中显示提示信息，提示用户这个元素必须输入内容--&gt;</span><br><br><span class="hljs-comment">&lt;!--pattern属性，要求输入的内容符合一定的格式，若不符合时，则不允许提交且会有显示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[0-9] [A-Z] &#123;3&#125;&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">part</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;输入内容：1个数字与三个大写字母。&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!--数值输入域number--&gt;</span><br><span class="hljs-comment">&lt;!--min和max属性是数值类型或日期类型的input元素的专用属性，它们限制了在input元素中输入的数值与日期的范围，--&gt;</span><br><span class="hljs-comment">&lt;!--step定义合法的数字间隔，例如step=3，则就是1、3、5...,value则是定义默认值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><br>滑动条range<br>将<span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>标记中的type属性设置为range，可以在表单中插入表示数值范围的滑动条，还可以限定可接受的数值范围<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--日期选择器data pickers--&gt;</span><br><span class="hljs-comment">&lt;!--HTML5拥有多个供选取日期的和时间的新输入类型，秩序将&lt;input&gt;标记中的type属性设置为一下几种类型之一即可--&gt;</span><br><span class="hljs-comment">&lt;!--date   选取日、月、年--&gt;</span><br><span class="hljs-comment">&lt;!--month   选取月、年--&gt;</span><br><span class="hljs-comment">&lt;!--week   选取周、年--&gt;</span><br><span class="hljs-comment">&lt;!--time   选取时间（小时和分钟）--&gt;</span><br><span class="hljs-comment">&lt;!--datetime  选取时间、日、月、年（世界标准时间UTC）--&gt;</span><br><span class="hljs-comment">&lt;!--datetme-local   选取时间、日、月、年（本地时间）--&gt;</span><br><br><span class="hljs-comment">&lt;!--url类型是input元素专门用来输入url地址的文本框，提交时如果该文本框中的内容不是url地址格式的文字，则不允许提交--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;urll&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;http://www.icourses.cn&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!--email类型的input元素是一种专门用来输入email地址的文本框，提交时如果该文本框内不是email地址格式--&gt;</span><br><span class="hljs-comment">&lt;!--的文字则不允许提交，但是却不会检查email地址是否存在，email类型的文本框具有一个multiple属性，它允许在该文本框--&gt;</span><br><span class="hljs-comment">&lt;!--中输入一串以逗号分隔的email地址--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;testemail@163.com&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--列表框标记&lt;select&gt;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;列表框民名称&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;选项值&quot;</span> /&gt;</span>选项显示内容<br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;选项值&quot;</span> /&gt;</span>选项显示内容<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--文本域输入标记&lt;textarea&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    在表单中，只要插入成对的&lt;textarea&gt;&lt;/textarea&gt;就可以插入文本域--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> &gt;</span><br>    用户:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;文本域name&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;行数5&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;列数100&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-comment">&lt;!--也可以应用form属性标识id--&gt;</span><br><span class="hljs-comment">&lt;!--&lt;form  id=&quot;myform&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    用户:&lt;input type=&quot;text&quot; value=&quot;login&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--&lt;/form&gt;&lt;br/&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--&lt;textarea form=&quot;myform&quot; name=&quot;文本域name&quot; rows=&quot;行数5&quot; cols=&quot;列数100&quot;&gt; &lt;/textarea&gt;--&gt;</span><br><br><span class="hljs-comment">&lt;!--使用成对的&lt;table&gt;&lt;/table&gt;标记就可以定义一个表格--&gt;</span><br><span class="hljs-comment">&lt;!--&lt;tr&gt;为行标记&lt;td&gt;为单元格标记&lt;th&gt;表头标记--&gt;</span><br><span class="hljs-comment">&lt;!--设置表格边框宽度border&lt;table border=&quot;2&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--设置单元格跨列colspan  &lt;td colspan=&quot;value&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--设置单元格跨行 rowspan &lt;td rowspan=&quot;value&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--width  设置单元格宽度--&gt;</span><br><span class="hljs-comment">&lt;!--height  设置单元格高度--&gt;</span><br><span class="hljs-comment">&lt;!--bordercolor 设置表格边框颜色--&gt;</span><br><span class="hljs-comment">&lt;!--bgcolor   设置表格背景颜色--&gt;</span><br><span class="hljs-comment">&lt;!--background  设置表格背景图像--&gt;</span><br><span class="hljs-comment">&lt;!--align/valign   设置表格对齐方式--&gt;</span><br><span class="hljs-comment">&lt;!--cellspacing    设置单元格间距--&gt;</span><br><span class="hljs-comment">&lt;!--cellpadding    设置单元格边距--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 400px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>  1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> 2 <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>  3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> 4 <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--使用成对的&lt;iframe&gt;&lt;/iframe&gt;标记即可在网页中插入内嵌框架--&gt;</span><br><span class="hljs-comment">&lt;!--可内置进&lt;td&gt;中--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>&gt;</span>内嵌<span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-comment">&lt;!--内置框架属性--&gt;</span><br><br><span class="hljs-comment">&lt;!--src    设置源文件地址--&gt;</span><br><span class="hljs-comment">&lt;!--width   设置内嵌框架窗口宽度--&gt;</span><br><span class="hljs-comment">&lt;!--height  设置内置框架窗口高度--&gt;</span><br><span class="hljs-comment">&lt;!--bordercolor  设置边框颜色--&gt;</span><br><span class="hljs-comment">&lt;!--align    设置框架对齐方式 可选left、right、top、middle、bottom--&gt;</span><br><span class="hljs-comment">&lt;!--name   设置框架名称，是链接标记的target所需的参数--&gt;</span><br><span class="hljs-comment">&lt;!--scrolling 设置是否需要显示滚动条，默认为auto，表示根据需要自动出现，Yes/No--&gt;</span><br><span class="hljs-comment">&lt;!--frameborder  设置框架边框，1表示显示边框、0表示不显示--&gt;</span><br><span class="hljs-comment">&lt;!--framespacing   设置框架边框宽度--&gt;</span><br><span class="hljs-comment">&lt;!--marginheight    设置内容与窗口上下边缘的边距，默认为1--&gt;</span><br><span class="hljs-comment">&lt;!--marginwidth    设置内容与窗口左右边缘的距离，默认为1--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HTML5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Koa2、Vue3、Mysql服务器部署全流程</title>
    <link href="./2023/03/08/Koa2%E3%80%81Vue3%E3%80%81Mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
    <url>./2023/03/08/Koa2%E3%80%81Vue3%E3%80%81Mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Koa2、Vue3、Mysql服务器部署全流程"><a href="#Koa2、Vue3、Mysql服务器部署全流程" class="headerlink" title="Koa2、Vue3、Mysql服务器部署全流程"></a>Koa2、Vue3、Mysql服务器部署全流程</h1><p>在电脑上安装<a href="https://www.netsarang.com/zh/free-for-home-school/">xshell7、xftp</a>，个人使用有免费版本</p><p>连接服务器</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">快捷连接指令 ssh <span class="hljs-symbol">root@</span>服务器IP地址<br>重启服务器 reboot<br></code></pre></td></tr></table></figure><h2 id="一、Mysql服务器端安装"><a href="#一、Mysql服务器端安装" class="headerlink" title="一、Mysql服务器端安装"></a>一、Mysql服务器端安装</h2><p><a href="https://blog.csdn.net/wyg1973017714/article/details/106482176">参考mysql安装、配置流程</a></p><p><code>&lt;u&gt;</code><strong>重点：使用服务端的服务时，在服务器防火墙中打开相应的端口，mysql对应的端口为3306</strong><code>&lt;/u&gt;</code></p><h3 id="1、首先获取rpm源"><a href="#1、首先获取rpm源" class="headerlink" title="1、首先获取rpm源"></a>1、首先获取rpm源</h3><p>由于没有相应的源，故需要获取对应的mysql的rpm源文件<a href="https://dev.mysql.com/downloads/repo/yum/">https://dev.mysql.com/downloads/repo/yum/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">wget https://repo.mysql.com//mysql80-community-release-el7-3.noarch.rpm<br></code></pre></td></tr></table></figure><p>然后通过以下命令安装rpm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">rpm -ivh mysql80-community-release-el7-3.noarch.rpm<br></code></pre></td></tr></table></figure><p>最后通过yum命令安装mysql，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">yum install mysql-community-server<br></code></pre></td></tr></table></figure><p>经过这些命令完成了MySQL的安装;</p><p>注意：MySQL GPG 密钥已过期。有关案例的其他详细信息也可以在 MySQL 网站上找到： <a href="https://bugs.mysql.com/bug.php?id=106188">https 😕&#x2F;bugs.mysql.com&#x2F;bug.php?id&#x3D;106188</a></p><p>可以在运行安装程序之前导入密钥</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">rpm --<span class="hljs-keyword">import</span> https:<span class="hljs-comment">//repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br></code></pre></td></tr></table></figure><h3 id="2、启动MySQL"><a href="#2、启动MySQL" class="headerlink" title="2、启动MySQL"></a>2、启动MySQL</h3><p>首先设置MySQL开机自启动，通过如下命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> mysqld.service<br></code></pre></td></tr></table></figure><p>然后可以通过如下命令开启服务</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> mysqld.service<br></code></pre></td></tr></table></figure><h3 id="3、登录MySQL"><a href="#3、登录MySQL" class="headerlink" title="3、登录MySQL"></a>3、登录MySQL</h3><p>初次登录时需要登录密码，通过以下命令查看初始密码</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">grep <span class="hljs-string">&#x27;temporary password&#x27;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span>/mysqld.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>然后通过以下命令登录，并输入初始密码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -uroot -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>当通过初始密码首次登录MySQL以后，我们需要修改登录密码，不然无法进行数据库基本操作<br>修改密码通过如下命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;密码&#x27;</span>;<br></code></pre></td></tr></table></figure><p>通过以上密码可将登录密码初始化为root，identified by 后面的引号中包含的字符就是设置的登陆密码</p><p><code>&lt;u&gt;</code><strong>高版本mysql修改密码的坑、常见操作，如下：</strong><code>&lt;/u&gt;</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">若修改时出现错误，可能是版本过高，例如：将 validate_password_policy修改 validate_password.<span class="hljs-keyword">policy</span>，余者类似<br><br>mysql为了安全，有自己的策略要求，如果我们想将其设置为我们常用的root或者<span class="hljs-number">123456</span>这样的密码，需要修改策略要求，具体命令如下：<br>提示：初次登录必须重置密码，否则无法操作，但是规则未知；故提供示例(直接复制)：<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;@#123qweQWE&#x27;</span>;<br><br><span class="hljs-number">1.</span>设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可，<br>输入设值语句 “ <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> validate_password.<span class="hljs-keyword">policy</span>=LOW; ” 进行设值<br><br><span class="hljs-number">2.</span>当前密码长度为 <span class="hljs-number">8</span> ，如果不介意的话就不用修改了，按照通用的来讲，设置为 <span class="hljs-number">6</span> 位的密码，设置 validate_password_length 的全局参数为 <span class="hljs-number">6</span> 即可，<br>输入设值语句 “ <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> validate_password.length=<span class="hljs-number">6</span>; ” 进行设值<br><br><span class="hljs-number">3.</span>现在可以为 mysql 设置简单密码了，只要满足六位的长度即可，<br>输入修改语句 “ <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> ‘root’@‘localhost’ IDENTIFIED <span class="hljs-keyword">BY</span> ‘<span class="hljs-number">123456</span>’; ” 可以看到修改成功，表示密码策略修改成功了！！！<br><br>mysql基本指令<br><span class="hljs-keyword">show</span> databases 查看数据库<br>use testdb; 进入testdb数据库<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>; 查看数据库中的表<br>creat <span class="hljs-keyword">database</span> testdb 创建数据表<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名 查看数据表中的数据<br><br>本地数据表上传至服务器端数据库<br><span class="hljs-number">1</span>、数据表表上传至服务器<br><span class="hljs-number">2</span>、打开服务器端的数据库<br><span class="hljs-number">3</span>、输入命令<br>//导入前需建立一个数据库名<br>source /root/probe.<span class="hljs-keyword">sql</span> (/root/probe.<span class="hljs-keyword">sql</span>即<span class="hljs-keyword">sql</span>文件在服务器上的位置)<br></code></pre></td></tr></table></figure><h3 id="4、添加远程用户，赋予全部权限"><a href="#4、添加远程用户，赋予全部权限" class="headerlink" title="4、添加远程用户，赋予全部权限"></a>4、添加远程用户，赋予全部权限</h3><p>首先需要创建一个新的用户，使用如下命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> root identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;password&#x27;</span>; <span class="hljs-keyword">password</span>处输入你设置的密码<br></code></pre></td></tr></table></figure><p>然后将数据库的全部权限赋予该用户</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">option</span>;<br></code></pre></td></tr></table></figure><p>最后刷新权限表即可</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">flush privileges<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong><code>&lt;u&gt;</code>注释：完成到此处时，其实navicat中就可以直接成功连接啦，但是由于mysql对于新旧版本密码算法不同，会出现步骤5中的错误，故而需要将密码重新修改或者在创建远程用户时就将以对应的形式设置好<code>&lt;/u&gt;</code></strong></p><h3 id="5、navicat远程连接"><a href="#5、navicat远程连接" class="headerlink" title="5、navicat远程连接"></a>5、navicat远程连接</h3><p>Client does not support authentication protocol requested by server; conside 新旧版本密码算法不同引起的错误，只需要设置下密码方式为 mysql_native_password 就可。还是 navicat 做的好，新旧密码都支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -uroot -p<br>use mysql;<br>show tables;<br># 查看已经有的用户<br>select user, host from user;<br><br># 重新设置下密码，并使之生效(设置远程用户的密码)<br># 之前是 <br>alter user &#x27;xxx&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;xxxxxx&#x27;<br># 修改完后<br>alter user &#x27;xxx&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;xxxxxx&#x27;<br># 刷新权限表<br>flush privileges;<br></code></pre></td></tr></table></figure><h2 id="二、Node服务配置"><a href="#二、Node服务配置" class="headerlink" title="二、Node服务配置"></a>二、Node服务配置</h2><h3 id="1、获取最新的node包-node服务中包括node、npm"><a href="#1、获取最新的node包-node服务中包括node、npm" class="headerlink" title="1、获取最新的node包(node服务中包括node、npm)"></a>1、获取最新的node包(node服务中包括node、npm)</h3><p><a href="https://nodejs.org/en/download/">node官网查看最新版本</a></p><p>强烈建议：在下载安装包前，先执行：cd &#x2F;usr&#x2F;local，跳转至该路径，或者包解压的时候直接解压到&#x2F;usr&#x2F;local</p><p>原因：</p><ul><li><code>/usr</code>：系统级的目录，可以理解为 <code>C:/Windows/</code></li><li><code>/usr/lib</code>理解为 <code>C:/Windows/System32</code></li><li><code>                        /usr/local</code>：用户级的程序目录，可以理解为 <code>C:/Progrem Files/</code>。用户自己编译的软件默认会安装到这个目录下。</li><li><code>/opt</code>：用户级的程序目录，可以理解为 <code>D:/Software</code>，opt有可选的意思，这里可以用于放置第三方大型软件（或游    戏），当你不需要时，直接 <code>rm -rf</code>掉即可。在硬盘容量不够时，也可将&#x2F;opt单独挂载到其他磁盘上使用。</li></ul><p>源码放哪里？</p><ul><li><code>/usr/src</code>：系统级的源码目录。</li><li><code>/usr/local/src</code>：用户级的源码目录</li></ul><h4 id="1、在liunx上从node官网下载node的压缩包"><a href="#1、在liunx上从node官网下载node的压缩包" class="headerlink" title="1、在liunx上从node官网下载node的压缩包"></a>1、在liunx上从node官网下载node的压缩包</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://nodejs.org/dist/v14.<span class="hljs-number">17</span>.<span class="hljs-number">6</span>/node-v14.<span class="hljs-number">17</span>.<span class="hljs-number">6</span>-linux-x64.tar.xz<br></code></pre></td></tr></table></figure><h4 id="2、将压缩包解压"><a href="#2、将压缩包解压" class="headerlink" title="2、将压缩包解压:"></a>2、将压缩包解压:</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">(解压到当前目录)tar -xvf <span class="hljs-keyword">node</span><span class="hljs-title">-v14</span>.<span class="hljs-number">17.6</span>-linux-x64.tar.xz<br>或者<br>(解压到指定目录) (tar -xvf <span class="hljs-keyword">node</span><span class="hljs-title">-v14</span>.<span class="hljs-number">17.6</span>-linux-x64.tar.xz -C /usr/local)<br></code></pre></td></tr></table></figure><h4 id="3、改目录名："><a href="#3、改目录名：" class="headerlink" title="3、改目录名："></a>3、改目录名：</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">mv <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/node-v14.17.6-linux-x64 /u</span>sr<span class="hljs-regexp">/local/</span>node<br>mv命令用来修改名字或移动文件的<br></code></pre></td></tr></table></figure><h4 id="4、配环境变量（极度重要，此处将服务真正的运行起来）"><a href="#4、配环境变量（极度重要，此处将服务真正的运行起来）" class="headerlink" title="4、配环境变量（极度重要，此处将服务真正的运行起来）"></a>4、配环境变量（极度重要，此处将服务真正的运行起来）</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>profile<br>最后加上这句话：export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/node/</span>bin<br>让新加的配置生效：source <span class="hljs-regexp">/etc/</span>profile<br><br>(此处的路径就是node、npm服务所在的路径)<br></code></pre></td></tr></table></figure><h4 id="5、软连接"><a href="#5、软连接" class="headerlink" title="5、软连接"></a>5、软连接</h4><p>相当于全局变量，在任何文件夹都能查看版本信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">第一个路径为文件真正所在路径，虚拟出的路径<br>软链接：ln -s 源文件 目标文件,软链接可以理解成快捷方式。它和windows下的快捷方式的作用是一样的<br>(我目前以为在usr/local下软连接作用不明显)<br>ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/node/</span>bin<span class="hljs-regexp">/node /u</span>sr<span class="hljs-regexp">/local/</span>bin/node<br>ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/node/</span>bin<span class="hljs-regexp">/npm /u</span>sr<span class="hljs-regexp">/local/</span>bin/npm<br></code></pre></td></tr></table></figure><h4 id="6、检验是否成功"><a href="#6、检验是否成功" class="headerlink" title="6、检验是否成功"></a>6、检验是否成功</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure><h4 id="7、换成国内源"><a href="#7、换成国内源" class="headerlink" title="7、换成国内源"></a>7、换成国内源</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk">由于node服务在外网，故而npm下载会很慢，在国内使用需要换源<br>方法<span class="hljs-number">1</span>、<br><span class="hljs-regexp">//</span>查看源<br>npm config get registry<br><span class="hljs-regexp">//</span>更换源<br>npm config set registry https:<span class="hljs-regexp">//</span>registry.npmjs.org<br><span class="hljs-regexp">//</span>淘宝源<br>npm config set registry https:<span class="hljs-regexp">//</span>registry.npm.taobao.org<br><br>方法<span class="hljs-number">2</span>、(建议)<br><span class="hljs-regexp">//</span>可直接用源管理器nrm<br>npm install nrm -g<br><span class="hljs-regexp">//</span>源列表<br>nrm ls<br><span class="hljs-regexp">//</span>可先打开nrm ls查看，使用淘宝的源<br>npm use taobao<br><br>方法<span class="hljs-number">3</span>、<br>安装cnpm，其实与方法<span class="hljs-number">1</span>原理一样<br>npm install -g cnpm --registry=https:<span class="hljs-regexp">//</span>registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h2 id="三、Koa2项目上传"><a href="#三、Koa2项目上传" class="headerlink" title="三、Koa2项目上传"></a>三、Koa2项目上传</h2><p><strong><code>&lt;u&gt;</code>此处也要在防火墙中开启服务端端口<code>&lt;/u&gt;</code></strong></p><p>在云端运行koa2项目与在本地运行时几乎没有差异，服务器端有node环境，可直接运行koa2项目，当navicat可以远程连接mysql数据库，而koa项目不行连接时，参看上文Mysql</p><p><strong><code>&lt;u&gt;</code>在上传前可将node_modules先删除，然后通过xftp上传文档(上传后的路径可以任意选择，建议在&#x2F;root下)，然后进入koa2项目中，<code>&lt;/u&gt;</code></strong></p><p><strong><code>&lt;u&gt;</code>使用 <code>npm install</code>下载node_modules,然后通过 <code>node app.js</code>运行项目即可<code>&lt;/u&gt;</code></strong></p><p>缺点：打开后，该终端页面就无法继续操作，且退出终端后项目也停止运行</p><p><code>&lt;u&gt;</code><strong>为解决node单一运行的缺点，故而安装pm2</strong><code>&lt;/u&gt;</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>安装<br>npm install pm2 -g<br><span class="hljs-regexp">//</span>简单的运行项目<br>pm2 start app.js<br><span class="hljs-regexp">//</span>结束项目<br>pm2 stop app.js<br><span class="hljs-regexp">//</span>停止进程：<br>pm2 stop app_name|app_id|all<br><span class="hljs-regexp">//</span>删除进程：<br>pm2 <span class="hljs-keyword">delete</span> app_name|app_id|all<br><span class="hljs-regexp">//</span>重启进程：<br>pm2 restart/reload app_name|app_id|all<br><span class="hljs-regexp">//</span>查看某一个进程的信息：<br>pm2 show app_name|app_id<br><span class="hljs-regexp">//</span>查看日志：<br>pm2 logs<br><span class="hljs-regexp">//</span>监控所有进程：<br>pm2 monit<br><br>建立软链接，使pm2能全局使用<br>　　ln -s 软件安装的路径 目标路径<br>例子: ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/node/</span>bin<span class="hljs-regexp">/pm2 /u</span>sr<span class="hljs-regexp">/bin/</span>pm2<br><br>启动命令（start）还可以带参数<br>--name<br>给进程命名<br>--watch<br>是否开启自动重启--max-memory-restart<br>最大重启内存<br>--log<br>指定日志文件路径<br>-- arg1 arg2 arg3<br>其他参数<br></code></pre></td></tr></table></figure><h2 id="四、Nginx安装"><a href="#四、Nginx安装" class="headerlink" title="四、Nginx安装"></a>四、Nginx安装</h2><p>从<a href="http://nginx.org/en/download.html">Nginx官网</a>获取nginx包，其中Stable version是稳定版本，Mainline version是最新版本，版本中间的为liunx版本，建议下载稳定版本</p><p><a href="http://nginx.org/en/linux_packages.html#RHEL-CentOS">官网安装方式</a></p><p><a href="https://www.nginx.cn/install">参考nginx安装，很复杂，但详细，源码安装</a></p><p><a href="https://www.cnblogs.com/l-hh/p/10594415.html">参考链接</a></p><p>在安装nginx前首先要确认系统中安装了<strong>gcc、pcre-devel、zlib-devel、openssl-devel</strong>等库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、rpm包安装的，可以用 rpm -qa 看到，如果要查找某软件包是否安装，用 rpm -qa | grep <span class="hljs-string">&quot;软件或者包的名字&quot;</span><br><span class="hljs-number">2</span>、以deb包安装的，可以用 dpkg -l 看到。如果是查找指定软件包，用 dpkg -l | grep <span class="hljs-string">&quot;软件或者包的名字&quot;</span><br><span class="hljs-number">3</span>、yum方法安装的，可以用 yum list installed 查找，如果是查找指定包，用 yum list installed | grep <span class="hljs-string">&quot;软件名或者包名&quot;</span><br><br><span class="hljs-regexp">//</span>安装库<br>yum -y install gcc pcre-devel zlib-devel openssl openssl-devel gcc-c++ make zlib libtool <br><br><span class="hljs-regexp">//</span>跳转路径<br>cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/src/</span><br><br><span class="hljs-regexp">//</span>获取nginx包<br>wget http:<span class="hljs-regexp">//</span>nginx.org<span class="hljs-regexp">/download/</span>nginx-<span class="hljs-number">1.20</span>.<span class="hljs-number">1</span>.tar.gz<br><br>(解压到当前目录)tar -xvf nginx-<span class="hljs-number">1.20</span>.<span class="hljs-number">1</span>.tar.gz<br><br><span class="hljs-regexp">//</span>数字是相应的版本，需要根据版本看，此处参考复杂的安装方式的链接<br>.<span class="hljs-regexp">/configure --sbin-path=/u</span>sr<span class="hljs-regexp">/local/</span>nginx/nginx <br>--conf-path=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>nginx.conf <br>--with-http_stub_status_module<br>--with-http_ssl_module<br>--with-pcre=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/src/</span>pcre-<span class="hljs-number">8.44</span><br><br>make -j2<br>make install<br><br><span class="hljs-regexp">//</span>启动nginx<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>nginx<br><br>浏览器中打开网页会出现welcome nginx<br><br><span class="hljs-regexp">//</span>查看占用的端口<br>ps -ef|grep nginx<br><br><span class="hljs-regexp">//</span>或者直接关闭<br>./nginx -s stop<br><br><span class="hljs-regexp">//</span>开启<br>./nginx<br><br><span class="hljs-regexp">//</span>修改对应的文件指令<br>vim nginx.conf<br></code></pre></td></tr></table></figure><h2 id="五、Vue3项目上传"><a href="#五、Vue3项目上传" class="headerlink" title="五、Vue3项目上传"></a>五、Vue3项目上传</h2><h3 id="1、项目打包"><a href="#1、项目打包" class="headerlink" title="1、项目打包"></a>1、项目打包</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> build      生成dist文件夹<br></code></pre></td></tr></table></figure><p>将dist文件夹上传至服务器</p><h3 id="2、dist文件夹的位置"><a href="#2、dist文件夹的位置" class="headerlink" title="2、dist文件夹的位置"></a>2、dist文件夹的位置</h3><p><strong><code>&lt;u&gt;</code>dist文件夹可以有两种方式<code>&lt;/u&gt;</code></strong></p><ol><li>将dist文件夹导入&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;下，与原本的nginx中的html文件夹同级 (目前使用的)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">将nginx.conf中的localhost / 下的root 对应的 html 改成 dist 即可<br>不要更改端口，否则会链接不上，原因未知<br><br>修改完后执行指令<br>./nginx -s stop<br>./nginx<br></code></pre></td></tr></table></figure><ol start="2"><li><p>无论dist文件夹放置在那个位置，直接修改nginx.conf中root对应的 路径即可，但是目前不知道路径能不能使用绝对路径</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">假如server 中声明root    <span class="hljs-regexp">/usr/</span>share;<br>   那么此时声明 location /&#123;<br>        root <span class="hljs-regexp">/usr/</span>html/www<br>&#125;<br>  此时就会覆盖掉server root 中的路径<br>假如此时声明 location /app &#123;<br><br>&#125;<br>那么此时所有的操作就是基于路径<span class="hljs-regexp">/usr/</span>share/app<br></code></pre></td></tr></table></figure></li></ol><h3 id="3、页面部署完后，可以使用，但是刷新后会报错"><a href="#3、页面部署完后，可以使用，但是刷新后会报错" class="headerlink" title="3、页面部署完后，可以使用，但是刷新后会报错"></a>3、页面部署完后，可以使用，但是刷新后会报错</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">可能原因：<br><span class="hljs-keyword">mode</span>类型引起的错误<br>前端修改方式：将<span class="hljs-keyword">mode</span>类型由<span class="hljs-keyword">history</span>改成hash；<br>后端修改方式：<span class="hljs-keyword">mode</span>还是<span class="hljs-keyword">history</span>，后端配置nginx，设置映射关系<br></code></pre></td></tr></table></figure><p>我的解决方式</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs perl">location / &#123;<br>                root  dist<br>                try_files $uri $uri/ @router;<br>                <span class="hljs-keyword">index</span> index.html index.htm;<br>        &#125;<br><br>        location @router &#123;<br>                rewrite ^.*$ /index.html <span class="hljs-keyword">last</span>;<br>        &#125;<br> 完美解决刷新报错的问题<br> <br> <br> 以下为注释：<br>   server &#123;<br>        <span class="hljs-keyword">listen</span>       <span class="hljs-number">8081</span>;<span class="hljs-comment">#默认端口是80，如果端口没被占用可以不用修改</span><br>        server_name  myapp.com;<br>        root        D:<span class="hljs-regexp">/vue/m</span>y_app/dist;<span class="hljs-comment">#vue项目的打包后的dist</span><br>        location / &#123;<br>            try_files $uri $uri/ @router;<span class="hljs-comment">#需要指向下面的@router否则会出现vue的路由在nginx中刷新出现404</span><br>            <span class="hljs-keyword">index</span>  index.html index.htm;<br>        &#125;<br>        <span class="hljs-comment">#对应上面的@router，主要原因是路由的路径资源并不是一个真实的路径，所以无法找到具体的文件</span><br>        <span class="hljs-comment">#因此需要rewrite到index.html中，然后交给路由在处理请求资源</span><br>        location @router &#123;<br>            rewrite ^.*$ /index.html <span class="hljs-keyword">last</span>;<br>        &#125;<br>        <span class="hljs-comment">#.......其他部分省略</span><br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="注意：上传服务器时，需要将ip与域名更改成服务器的域名，可能一个空格和-x2F-就会报错"><a href="#注意：上传服务器时，需要将ip与域名更改成服务器的域名，可能一个空格和-x2F-就会报错" class="headerlink" title="注意：上传服务器时，需要将ip与域名更改成服务器的域名，可能一个空格和&#x2F;就会报错"></a>注意：上传服务器时，需要将ip与域名更改成服务器的域名，可能一个空格和&#x2F;就会报错</h2>]]></content>
    
    
    <categories>
      
      <category>koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nuxt入门总结</title>
    <link href="./2023/03/08/Nuxt%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <url>./2023/03/08/Nuxt%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Nuxt入门总结"><a href="#Nuxt入门总结" class="headerlink" title="Nuxt入门总结"></a>Nuxt入门总结</h1><h2 id="一、nuxt简介及安装"><a href="#一、nuxt简介及安装" class="headerlink" title="一、nuxt简介及安装"></a>一、nuxt简介及安装</h2><p>Nuxt.js 官方介绍：</p><blockquote><p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 <strong>UI 渲染</strong>。我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js，Nuxt.js 预设了利用 Vue.js 开发<strong>服务端渲染</strong>的应用所需要的各种配置。作为框架，Nuxt.js 为 <code>客户端/服务端</code> 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。</p></blockquote><h3 id="一、nuxt简介"><a href="#一、nuxt简介" class="headerlink" title="一、nuxt简介"></a>一、nuxt简介</h3><h4 id="1-那服务器端渲染的益处"><a href="#1-那服务器端渲染的益处" class="headerlink" title="1.那服务器端渲染的益处"></a>1.那服务器端渲染的益处</h4><p>nuxt.js简单的说是Vue.js的通用框架，最常用的就是用来作SSR（服务器端渲染）.Vue.js是开发SPA（单页应用）的,Nuxt.js这个框架，用Vue开发多页应用，并在服务端完成渲染，可以直接用命令把我们制作的vue项目生成为静态html。</p><p>主要的原因时SPA（单页应用）不利于搜索引擎的SEO操作，Nuxt.js适合作新闻、博客、电影、咨询这样的需要搜索引擎提供流量的项目。如果你要作移动端的项目，就没必要使用这个框架了。</p><h4 id="2-什么是SSR？"><a href="#2-什么是SSR？" class="headerlink" title="2.什么是SSR？"></a>2.什么是SSR？</h4><p><code>SSR</code> 就是 <code>服务器渲染</code>，什么是 <code>服务器渲染</code>？由 <code>服务器</code> 组装好 <code>DOM</code> 元素，生成 <code>HTML</code> 字符串给到浏览器，也就是在浏览器里面是可以看到整个页面的 <code>DOM</code> 源码的。</p><p><code>SSR</code> 解决的问题:</p><p><code>SEO</code>：搜索引擎的优先爬取级别是页面的 <code>HTML</code> 结构，当我们使用 <code>SSR</code> 的时候，服务端已经生成了与业务相关联的 <code>HTML</code>，这样的信息对于 <code>SEO</code> 是很友好的。</p><p><code>内容呈现</code>：客户端无需等待所有的 <code>JS</code> 文件加载完成即可看见渲染的业务相关视图（压力来到了服务端这边，这也是需要做权衡的地方，需要区分哪些由服务端渲染，哪些可以交给客户端）。</p><p><code>SSR</code> 相关的弊端:</p><p><code>代码兼容</code>：对于开发人员来讲，需要去兼容代码在不同环境的运行 <code>Vue SSR</code> 所需要的服务端环境是 <code>Node</code>，有一些客户端的对象，比如 <code>dom</code>、<code>windows</code> 之类的则无法使用。</p><p><code>服务器负载</code>：相对于前后端分离模式下服务器只需要提供静态资源来说，<code>SSR</code> 需要的服务器负载更大，所以在项目中使用 <code>SSR</code> 模式要慎重，比如一整套图表页面，相对于服务端渲染，可能用户不会在乎初始加载的前几秒，可以交由客户端使用类似于骨架屏，或者懒加载之类的提升用户体验。</p><p><code>Vue</code> 与 <code>Vue SSR</code> 与 <code>原生HTML</code> 页面源码区别对比，在网页上右键查看源码：</p><p><code>Vue SSR</code> 与 <code>原生HTML</code> 是可以看到源码标签的</p><p>在认识<code>SSR</code>之前，首先对<code>CSR</code>与<code>SSR</code>之间做个对比。</p><p>首先看一下传统的web开发，传统的web开发是，客户端向服务端发送请求，服务端查询数据库，拼接<code>HTML</code>字符串（模板），通过一系列的数据处理之后，把整理好的<code>HTML</code>返回给客户端,浏览器相当于打开了一个页面。这种比如我们经常听说过的<code>jsp</code>,<code>PHP</code>,<code>aspx</code>也就是传统的<code>MVC</code>的开发。</p><p><code>SPA</code>应用，到了<code>Vue</code>、<code>React</code>，单页面应用优秀的用户体验，逐渐成为了主流，页面整体式<code>javaScript</code>渲染出来的，称之为客户端渲染<code>CSR</code>。<code>SPA</code>渲染过程。由客户端访问<code>URL</code>发送请求到服务端，返回<code>HTML</code>结构（但是<code>SPA</code>的返回的<code>HTML</code>结构是非常的小的，只有一个基本的结构，如第一段代码所示）。客户端接收到返回结果之后，在客户端开始渲染<code>HTML</code>，渲染时执行对应<code>javaScript</code>，最后渲染<code>template</code>，渲染完成之后，再次向服务端发送数据请求，注意这里时数据请求，服务端返回<code>json</code>格式数据。客户端接收数据，然后完成最终渲染。（请求两次，百度搜索引擎不能抓取SPA页面的数据）</p><p><code>SPA</code>虽然给服务器减轻了压力，但是也是有缺点的：</p><ol><li>首屏渲染时间比较长：必须等待<code>JavaScript</code>加载完毕，并且执行完毕，才能渲染出首屏。</li><li><code>SEO</code>不友好：爬虫只能拿到一个<code>div</code>元素，认为页面是空的，不利于<code>SEO</code>。</li></ol><p>为了解决如上两个问题，出现了<code>SSR</code>解决方案，后端渲染出首屏的<code>DOM</code>结构返回，前端拿到内容带上首屏，后续的页面操作，再用单页面路由和渲染，称之为服务端渲染(<code>SSR</code>)。</p><p><code>SSR</code>渲染流程是这样的，客户端发送<code>URL</code>请求到服务端，服务端读取对应的<code>url</code>的模板信息，在服务端做出<code>html</code>和<code>数据</code>的渲染，渲染完成之后返回<code>html</code>结构，客户端这时拿到的之后首屏页面的<code>html</code>结构。所以用户在浏览首屏的时候速度会很快，因为客户端不需要再次发送<code>ajax</code>请求。并不是做了<code>SSR</code>我们的页面就不属于<code>SPA</code>应用了，它仍然是一个独立的<code>spa</code>应用。</p><p><code>SSR</code>是处于<code>CSR</code>与<code>SPA</code>应用之间的一个折中的方案，在渲染首屏的时候在服务端做出了渲染，注意仅仅是首屏，其他页面还是需要在客户端渲染的，在<code>服务端</code>接收到请求之后并且渲染出首屏页面，会携带着剩余的路由信息预留给<code>客户端</code>去渲染其他路由的页面。</p><p>Nuxt.js是特点（优点）：</p><ul><li>基于<code>Vue</code></li><li>自动代码分层</li><li>服务端渲染</li><li>强大的路由功能，支持异步数据</li><li>静态文件服务</li><li><code>EcmaScript6</code>和<code>EcmaScript7</code>的语法支持</li><li>打包和压缩<code>JavaScript</code>和<code>Css</code></li><li><code>HTML</code>头部标签管理</li><li>本地开发支持热加载</li><li>集成<code>ESLint</code></li><li>支持各种样式预编译器<code>SASS</code>、<code>LESS</code>等等</li><li>支持<code>HTTP/2</code>推送</li></ul><h3 id="二、nuxt安装"><a href="#二、nuxt安装" class="headerlink" title="二、nuxt安装"></a>二、nuxt安装</h3><h4 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h4><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">// 全局安装<span class="hljs-string">npx</span><br>// <span class="hljs-string">npx</span> 想要解决的主要问题，就是调用项目内部安装的模块<br><span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">npx</span> -<span class="hljs-string">g</span><br><br>// 使用<span class="hljs-string">npx</span>创建<span class="hljs-string">nuxt</span>项目，除了调用项目内部模块，<span class="hljs-string">npx</span> 还能避免全局安装的模块。比如，<span class="hljs-built_in">create-react-app这个模块是全局安装，npx</span> 可以运行它，而且不进行全局安装。下面代码运行时，<span class="hljs-string">npx</span> 将<span class="hljs-built_in">create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app</span><br><span class="hljs-string">npx</span> <span class="hljs-built_in">create-nuxt-app</span> 项目名<br><br><span class="hljs-string">Project</span> <span class="hljs-string">name</span>                                //  项目名称<br><span class="hljs-string">Project</span> <span class="hljs-string">description</span>                         //  项目描述<br><span class="hljs-string">Use</span> <span class="hljs-string">a</span> <span class="hljs-string">custom</span> <span class="hljs-string">server</span> <span class="hljs-string">framework</span>               //  选择服务器框架<br><span class="hljs-string">Choose</span> <span class="hljs-string">features</span> <span class="hljs-string">to</span> <span class="hljs-string">install</span>                  //  选择安装的特性<br><span class="hljs-string">Use</span> <span class="hljs-string">a</span> <span class="hljs-string">custom</span> <span class="hljs-string">UI</span> <span class="hljs-string">framework</span>                   //  选择<span class="hljs-string">UI</span>框架<br><span class="hljs-string">Use</span> <span class="hljs-string">a</span> <span class="hljs-string">custom</span> <span class="hljs-string">test</span> <span class="hljs-string">framework</span>                 //  测试框架<br><span class="hljs-string">Choose</span> <span class="hljs-string">rendering</span> <span class="hljs-string">mode</span>                       //  渲染模式<br><span class="hljs-string">Universal</span>                                   //  渲染所有连接页面<br><span class="hljs-string">Single</span> <span class="hljs-string">Page</span> <span class="hljs-string">App</span>                             //  只渲染当前页面<br></code></pre></td></tr></table></figure><p>​        当一个客户端请求进入的时候，服务端有通过<code>nuxtServerInit</code>这个命令执行在<code>Store</code>的<code>action</code>中，在这里接收到客户端请求的时候，可以将一些客户端信息存储到<code>Store</code>中，也就是说可以把在服务端存储的一些客户端的一些登录信息存储到<code>Store</code>中。之后使用了<code>中间件</code>机制，中间件其实就是一个函数，会在每个路由执行之前去执行，在这里可以做很多事情，或者说可以理解为是路由器的拦截器的作用。然后再<code>validate</code>执行的时候对客户端携带的参数进行校验，在<code>asyncData</code>与<code>fetch</code>进入正式的渲染周期，<code>asyncData</code>向服务端获取数据，把请求到的数据合并到<code>Vue</code>中的<code>data</code>中，</p><h4 id="二、目录结构介绍"><a href="#二、目录结构介绍" class="headerlink" title="二、目录结构介绍"></a>二、目录结构介绍</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">└─my-nuxt-demo<br>  ├─.nuxt               <span class="hljs-regexp">//</span> Nuxt自动生成，临时的用于编辑的文件，build<br>  ├─assets              <span class="hljs-regexp">//</span> 用于组织未编译的静态资源如LESS、SASS或JavaScript,对于不需要通过 Webpack 处理的静态资源文件，可以放置在 static 目录中<br>  ├─components          <span class="hljs-regexp">//</span> 用于自己编写的Vue组件，比如日历组件、分页组件<br>  ├─layouts             <span class="hljs-regexp">//</span> 布局目录，用于组织应用的布局组件，不可更改<br>  ├─middleware          <span class="hljs-regexp">//</span> 用于存放中间件<br>  ├─node_modules<br>  ├─pages               <span class="hljs-regexp">//</span> 用于组织应用的路由及视图,Nuxt.js根据该目录结构自动生成对应的路由配置，文件名不可更改<br>  ├─plugins             <span class="hljs-regexp">//</span> 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。<br>  ├─static              <span class="hljs-regexp">//</span> 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。 服务器启动的时                            候，该目录下的文件会映射至应用的根路径 / 下。文件夹名不可更改。<br>  └─store               <span class="hljs-regexp">//</span> 用于组织应用的Vuex 状态管理。文件夹名不可更改。<br>  ├─.editorconfig       <span class="hljs-regexp">//</span> 开发工具格式配置<br>  ├─.eslintrc.js        <span class="hljs-regexp">//</span> ESLint的配置文件，用于检查代码格式<br>  ├─.gitignore          <span class="hljs-regexp">//</span> 配置git忽略文件<br>  ├─nuxt.config.js      <span class="hljs-regexp">//</span> 用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。文件名不可更改。<br>  ├─package-lock.json   <span class="hljs-regexp">//</span> npm自动生成，用于帮助package的统一设置的，yarn也有相同的操作<br>  ├─package.json        <span class="hljs-regexp">//</span> npm 包管理配置文件<br>  ├─README.md<br></code></pre></td></tr></table></figure><h4 id="三、配置文件nuxt-config-js"><a href="#三、配置文件nuxt-config-js" class="headerlink" title="三、配置文件nuxt.config.js"></a>三、配置文件nuxt.config.js</h4><p><strong>注意：</strong></p><ul><li><em>export default在一个模块中只能有一个，当然也可以没有。export在一个模块中可以有多个。</em></li><li><em>export default的对象、变量、函数、类，可以没有名字。export的必须有名字。</em></li><li><em>export default对应的import和export有所区别</em></li><li><em>module变量代表当前模块。这个变量是一个对象，module对象会创建一个叫exports的属性，这个属性的默认值是一个空的对象</em></li></ul><p><em>Node为每个模块提供一个exports变量，指向module.exports，两个是相等的关系，但又不是绝对相当的关系，module.exports可以直接导出一个匿名函数或者一个值，但是export的必须有名字，故不行，export default或export 名字可以</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs awk">const pkg = require(<span class="hljs-string">&#x27;./package&#x27;</span>)<br>module.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;universal&#x27;</span>,    <span class="hljs-regexp">//</span>  当前渲染使用模式，分为universal和spa，既然是nuxt开发，那就是universal<br>  <span class="hljs-regexp">//</span> 全局页头配置 (https:<span class="hljs-regexp">//g</span>o.nuxtjs.dev/config-head)<br>  head: &#123;       <span class="hljs-regexp">//</span>  页面head配置信息<br>    title: pkg.name,        <span class="hljs-regexp">//</span>  title<br>    meta: [         <span class="hljs-regexp">//</span>  meat<br>      &#123; charset: <span class="hljs-string">&#x27;utf-8&#x27;</span> &#125;,<br>      &#123; name: <span class="hljs-string">&#x27;viewport&#x27;</span>, content: <span class="hljs-string">&#x27;width=device-width, initial-scale=1&#x27;</span> &#125;,<br>      &#123; hid: <span class="hljs-string">&#x27;description&#x27;</span>, name: <span class="hljs-string">&#x27;description&#x27;</span>, content: pkg.description &#125;<br>      <span class="hljs-regexp">//</span> 这里可以添加网站验证码信息<br>      <span class="hljs-regexp">//</span>  &#123; name: <span class="hljs-string">&#x27;google-site-verification&#x27;</span>, content: <span class="hljs-string">&#x27;xxx&#x27;</span> &#125;,<br>      <span class="hljs-regexp">//</span> 实测百度无法通过验证，此问题还没解决<br>      <span class="hljs-regexp">//</span> &#123; name: <span class="hljs-string">&#x27;baidu-site-verification&#x27;</span>, content: <span class="hljs-string">&#x27;code-xxx&#x27;</span> &#125;,<br>    ],<br>    link: [     <span class="hljs-regexp">//</span>  favicon，若引用css不会进行打包处理<br>      &#123; rel: <span class="hljs-string">&#x27;icon&#x27;</span>, type: <span class="hljs-string">&#x27;image/x-icon&#x27;</span>, href: <span class="hljs-string">&#x27;/favicon.ico&#x27;</span> &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-regexp">//</span> nuxt 加载进度条配置 (https:<span class="hljs-regexp">//</span>zh.nuxtjs.org<span class="hljs-regexp">/api/</span>configuration-loading)<br>  loading: &#123; color: <span class="hljs-string">&#x27;#fff&#x27;</span> &#125;,   <span class="hljs-regexp">//</span>  页面进度条<br>  <span class="hljs-regexp">//</span> 全局css (https:<span class="hljs-regexp">//g</span>o.nuxtjs.dev/config-css)<br>  css: [    <span class="hljs-regexp">//</span>  全局css（会进行webpack打包处理）<br>    <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>  <br>  ],<br>   <span class="hljs-regexp">//</span> 配置后，会在页面渲染之前加载 (https:<span class="hljs-regexp">//g</span>o.nuxtjs.dev/config-plugins)<br>  plugins: [        <span class="hljs-regexp">//</span>  插件<br>    <span class="hljs-string">&#x27;@/plugins/element-ui&#x27;</span><br>  ],<br>  <span class="hljs-regexp">//</span> 工具module (https:<span class="hljs-regexp">//g</span>o.nuxtjs.dev/config-modules)<br>  modules: [        <span class="hljs-regexp">//</span>  模块<br>    <span class="hljs-string">&#x27;@nuxtjs/axios&#x27;</span>,<br>  ],<br> <span class="hljs-regexp">//</span> 如果添加了@nuxt<span class="hljs-regexp">/axios则会需要此配置来覆盖默认的一些配置 (https:/</span><span class="hljs-regexp">/go.nuxtjs.dev/</span>config-axios)<br>  axios: &#123;<br>    https: true, <br>    progress: true, <span class="hljs-regexp">//</span> 是否显示加载进度条<br>    credentials: true, <span class="hljs-regexp">//</span> 请求携带cookie<br>    baseURL: <span class="hljs-string">&#x27;https://www.abeille.top/api&#x27;</span>,<br>    proxy: true <span class="hljs-regexp">//</span> 请求代理，开发中跨域问题解决方法<br>  &#125;,<br>  <span class="hljs-regexp">//</span> 打包配置 (https:<span class="hljs-regexp">//g</span>o.nuxtjs.dev/config-build)<br>  build: &#123;      <span class="hljs-regexp">//</span>  打包<br>    transpile: [<span class="hljs-regexp">/^element-ui/</span>],<br>    extend(config, ctx) &#123;       <span class="hljs-regexp">//</span>  webpack自定义配置<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="四、Nuxt运行命令"><a href="#四、Nuxt运行命令" class="headerlink" title="四、Nuxt运行命令"></a>四、Nuxt运行命令</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-regexp">//</span>  开发环境<br>    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;cross-env NODE_ENV=development nodemon server/index.js --watch server&quot;</span>,<br>    <span class="hljs-regexp">//</span>  打包<br>    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;nuxt build&quot;</span>,<br>    <span class="hljs-regexp">//</span>  在服务端运行<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;cross-env NODE_ENV=production node server/index.js&quot;</span>,<br>    <span class="hljs-regexp">//</span>  生成静态页面<br>    <span class="hljs-string">&quot;generate&quot;</span>: <span class="hljs-string">&quot;nuxt generate&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、nuxt常用配置"><a href="#二、nuxt常用配置" class="headerlink" title="二、nuxt常用配置"></a>二、nuxt常用配置</h2><h3 id="一、配置IP和端口"><a href="#一、配置IP和端口" class="headerlink" title="一、配置IP和端口"></a>一、配置IP和端口</h3><p>第一种 <code>nuxt.config.js</code> :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">8000</span>,<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种   <code>package.json</code> :</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;nuxt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;8000&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h3 id="二、配置全局CSS"><a href="#二、配置全局CSS" class="headerlink" title="二、配置全局CSS"></a>二、配置全局CSS</h3><p>在开发多页项目时，都会定义一个全局的CSS来初始化我们的页面渲染，比如把padding和margin设置成0，网上也有非常出名的开源css文件normailze.css。要定义这些配置，需要在nuxt.config.js里进行操作。</p><p>比如现在我们要把页面字体设置为红色，就可以在assets&#x2F;css&#x2F;common.css文件，然后把字体设置为红色。</p><p>&#x2F;assets&#x2F;css&#x2F;common.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>&#123;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;nuxt.config.js</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">css:[<span class="hljs-string">&#x27;~assets/css/normailze.css&#x27;</span>],<br></code></pre></td></tr></table></figure><p>设置好后，在终端输入npm run dev 。然后你会发现字体已经变成了红色。</p><h2 id="三、Nuxt的路由配置和参数传递"><a href="#三、Nuxt的路由配置和参数传递" class="headerlink" title="三、Nuxt的路由配置和参数传递"></a>三、Nuxt的路由配置和参数传递</h2><h3 id="一、基本路由"><a href="#一、基本路由" class="headerlink" title="一、基本路由"></a>一、基本路由</h3><p>Nuxt.js的路由并不复杂，它给我们进行了封装，让我们节省了很多配置环节。</p><p>Nuxt会自动生成路由，故而只需使用<code>&lt;nuxt-link :to=&quot;&quot;&gt; &lt;/nuxt-link&gt;</code>,而非<code>&lt;router-link :to=&quot;&quot;&gt; &lt;/router-link&gt;</code></p><p>页面跳转方式：</p><ol><li>不要写成a标签，因为是重新获取一个新的页面，并不是SPA</li><li><code>&lt;nuxt-link to=&quot;/users&quot;&gt;&lt;/nuxt-link&gt;</code></li><li>this.$router.push(‘&#x2F;users’)</li></ol><p>动态路由：</p><ul><li>在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的<strong>以下划线作为前缀</strong>的 Vue 文件 或 目录。</li><li>获取动态参数</li></ul><h3 id="二、路由传参"><a href="#二、路由传参" class="headerlink" title="二、路由传参"></a>二、路由传参</h3><p>this.$route.query.key的方式参数显示在地址栏上, 但是并不是我们想要的, :id?id&#x3D;&#96;&#96;?所以建议还是尽量使用router-link来实现跳转来解决地址栏的变化,更方便网站的优化</p><h4 id="一-nuxt-link中传递参数"><a href="#一-nuxt-link中传递参数" class="headerlink" title="一. nuxt-link中传递参数"></a>一. nuxt-link中传递参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs 方式一">方式一<br>传参：<br>&lt;nuxt-link :to=&quot;&#123;path:&#x27;/about&#x27;,query:&#123;index:id&#125;&#125;&quot; target=&quot;_blank&quot; &gt;&lt;nuxt-link&gt;<br>地址栏显示：<br>loaclhost:3000/about/id<br>接收地址栏参数：<br>this.$route.query.index<br> <br>方式二<br>传参： <br>&lt;nuxt-link target=&quot;_blank&quot; :to=&quot;&#123;name: &#x27;log-id&#x27;, params:&#123;id: n.id,key:value&#125;&#125;&quot;&gt;&lt;/nuxt-link&gt;<br>地址栏显示：<br>loaclhost:3000/about/id<br>接收：<br>async asyncData (&#123; params &#125;) &#123; //  params.id 就是我们传进来的值&#125;// 或者 created () &#123; this.$route.params.xxx&#125;`<br><br></code></pre></td></tr></table></figure><h4 id="二-在方法中传递"><a href="#二-在方法中传递" class="headerlink" title="二. 在方法中传递"></a>二. 在方法中传递</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs 跳转">方式一<br>跳转：<br>getDescribe(id) &#123;<br>    // 直接调用$router.push 实现携带参数的跳转<br>    this.$router.push(&#123;<br>      path: `/describe/$&#123;id&#125;`,<br>    &#125;)   <br>接收：<br>$route.params.id<br><br>方式 二<br>注意：<br>页面之间的跳转使用query 不然的话刷新页面后会找不到参数<br>跳转：<br> this.$router.push(&#123;<br>          path: &#x27;/describe&#x27;,<br>          query: &#123;<br>            id: id<br>          &#125;<br>&#125;)<br>接收：<br>$route.query.id<br></code></pre></td></tr></table></figure><h3 id="三、路由传参校验"><a href="#三、路由传参校验" class="headerlink" title="三、路由传参校验"></a>三、路由传参校验</h3><p>Nuxt.js 可以让你在动态路由对应的页面组件中配置一个<code>validate</code>方法用于校验动态路由参数的有效性。该函数有一个布尔类型的返回值，如果返回true则表示校验通过，如果返回false则表示校验未通过。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// nuxt中使用validate方法进行路由参数校验，这个方法必须返回一个布尔值，为true表示校验通过，为false表示校验失败。注意validate不能写到methods属性中。</span><br>  <span class="hljs-title function_">validate</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-comment">// console.log(obj);</span><br>    <span class="hljs-comment">// return true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^\d+$/</span>.<span class="hljs-title function_">test</span>(obj.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、路由嵌套"><a href="#四、路由嵌套" class="headerlink" title="四、路由嵌套"></a>四、路由嵌套</h3><p><strong>注意：</strong></p><p><em>在nuxt框架中，在 <code>nuxt.config.js</code>中<code>components: true</code>已开启了组件自动导入，故而不需要在vue文件中通过import和components来导入组件，只需在template中写入相应组件的组件名即可</em></p><ol><li>添加一个Vue文件，作为父组件</li><li>添加一个与父组件同名的文件夹来存放子视图组件</li><li>在父文件中，添加组件，用于展示匹配到的子视图</li></ol><h3 id="五、Nuxt的路由动画效果"><a href="#五、Nuxt的路由动画效果" class="headerlink" title="五、Nuxt的路由动画效果"></a>五、Nuxt的路由动画效果</h3><p>路由的动画效果，也叫作页面的更换效果。Nuxt.js提供两种方法为路由提供动画效果，一种是全局的，一种是针对单独页面制作。</p><h4 id="1-全局路由动画"><a href="#1-全局路由动画" class="headerlink" title="1.全局路由动画"></a>1.全局路由动画</h4><p>全局动画默认使用page来进行设置，例如现在我们为每个页面都设置一个进入和退出时的渐隐渐现的效果。我们可以先在根目录的assets&#x2F;css下建立一个normailze.css文件。</p><p>（1）添加样式文件</p><p>&#x2F;assets&#x2F;css&#x2F;normailze.css(没有请自行建立)</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nsis">.<span class="hljs-keyword">page</span>-enter-active, .<span class="hljs-keyword">page</span>-<span class="hljs-literal">leave</span>-active &#123;<br>    transition: opacity <span class="hljs-number">2</span>s<span class="hljs-comment">;</span><br>&#125;<br><br>.<span class="hljs-keyword">page</span>-enter, .<span class="hljs-keyword">page</span>-<span class="hljs-literal">leave</span>-active &#123;<br>    opacity: <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）文件配置</p><p>然后在nuxt.config.js里加入一个全局的css文件就可以了。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">css:[<span class="hljs-string">&#x27;assets/css/main.css&#x27;</span>],<br></code></pre></td></tr></table></figure><p>这时候在页面切换的时候就会有2秒钟的动画切换效果了，但是你会发现一些页面是没有效果的，这是因为你没有是<code>&lt;nuxt-link&gt;</code>组件来制作跳转链接。你需要进行更改。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;name:&#x27;news-id&#x27;,params:&#123;id:123&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&#125;&quot;</span>&gt;</span>News-1<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-单独设置页面动效"><a href="#2-单独设置页面动效" class="headerlink" title="2.单独设置页面动效"></a>2.单独设置页面动效</h4><p>想给一个页面单独设置特殊的效果时，我们只要在css里改变默认的page，然后在页面组件的配置中加入transition字段即可。例如，我们想给about页面加入一个字体放大然后缩小的效果，其他页面没有这个效果。</p><p>（1）在全局样式assets&#x2F;main.css 中添加以下内容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test-enter-active</span>, <span class="hljs-selector-class">.test-leave-active</span> &#123;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">2s</span>;<br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;<br>&#125;<br><span class="hljs-selector-class">.test-enter</span>, <span class="hljs-selector-class">.test-leave-active</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">40px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）然后在about&#x2F;index.vue组件中设置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span><span class="hljs-built_in"> default </span>&#123;<br>  transition:<span class="hljs-string">&#x27;test&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时候就有了页面的切换独特动效了。</p><p>总结：在需要使用的页面导入即可。</p><h2 id="四、Nuxt的默认模版和默认布局"><a href="#四、Nuxt的默认模版和默认布局" class="headerlink" title="四、Nuxt的默认模版和默认布局"></a>四、Nuxt的默认模版和默认布局</h2><p>在开发应用时，经常会用到一些公用的元素，比如网页的标题是一样的，每个页面都是一模一样的标题。这时候我们有两种方法，第一种方法是作一个公用的组件出来，第二种方法是修改默认模版。这两种方法各有利弊，比如公用组件更加灵活，但是每次都需要自己手动引入；模版比较方便，但是只能每个页面都引入。</p><h3 id="1-默认模板"><a href="#1-默认模板" class="headerlink" title="1.默认模板"></a>1.默认模板</h3><p>Nuxt为我们提供了超简单的默认模版订制方法，只要在根目录下创建一个app.html就可以实现了。现在我们希望每个页面的最上边都加入“ 学习nuxt.js” 这几个字，我们就可以使用默认模版来完成。</p><p>app.html中：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">   </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">HEAD</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>学习nuxt.js<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">APP</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这里的读取的是nuxt.config.js里的信息， 就是我们写的pages文件夹下的主体页面了。需要注意的是HEAD和APP都需要大写，如果小写会报错的。</p><p>注意：如果你建立了默认模板后，记得要重启服务器，否则显示不会成功；但是默认布局是不用重启服务器的。</p><h3 id="2-默认布局"><a href="#2-默认布局" class="headerlink" title="2.默认布局"></a>2.默认布局</h3><p>默认模板类似的功能还有默认布局，但是从名字上你就可以看出来，默认布局主要针对于页面的统一布局使用。它在位置根目录下的layouts&#x2F;default.vue。需要注意的是在默认布局里不要加入头部信息，只是关于<code>&lt;template&gt;</code>标签下的内容统一订制。</p><p>需求：我们在每个页面的最顶部放入“学习nuxt.js” 这几个字，看一下在默认布局里的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;学习nuxt.js&lt;/p&gt;<br>    &lt;nuxt/&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>这里的<code>&lt;nuxt/&gt;</code>就相当于我们每个页面的内容，你也可以把一些通用样式放入这个默认布局里，但会增加页面的复杂程度。</p><p>总结：要区分默认模版和默认布局的区别，模版可以订制很多头部信息，包括IE版本的判断；模版只能定制<code>&lt;template&gt;</code>里的内容，跟布局有关系。在工作中修改时要看情况来编写代码。</p><h2 id="五、Nuxt插件的使用"><a href="#五、Nuxt插件的使用" class="headerlink" title="五、Nuxt插件的使用"></a>五、Nuxt插件的使用</h2><h3 id="1-ElementUI使用"><a href="#1-ElementUI使用" class="headerlink" title="1.ElementUI使用"></a>1.ElementUI使用</h3><ol><li><p>下载npm i element-ui -S</p></li><li><p>在plugins文件夹下面，创建ElementUI.js文件</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> ElementUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br>Vue.use(ElementUI)<br></code></pre></td></tr></table></figure></li><li><p>在nuxt.config.js中添加配置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">css: [<br>  <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br>],<br>plugins: [<br>  &#123;<span class="hljs-attribute">src</span>: <span class="hljs-string">&#x27;~/plugins/ElementUI&#x27;</span>, ssr: true &#125;<br>],<br>build: &#123;<br>  vendor: [<span class="hljs-string">&#x27;element-ui&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-Element按需引入"><a href="#2-Element按需引入" class="headerlink" title="2.Element按需引入"></a>2.Element按需引入</h3><blockquote><p>第一步，下载依赖：</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 先下载element-ui</span><br><br>npm install <span class="hljs-keyword">element</span>-ui <span class="hljs-comment">--save</span><br><br><span class="hljs-comment"># 如果使用按需引入，必须安装babel-plugin-component(官网有需要下载说明，此插件根据官网规则不同，安装插件不同)</span><br><br>npm install babel-plugin-component <span class="hljs-comment">--save-dev</span><br></code></pre></td></tr></table></figure><p>安装好以后，按照<code>nuxt.js</code>中的规则，你需要在 <code>plugins/</code> 目录下创建相应的插件文件</p><p>在<strong>文件根目录</strong>创建(或已经存在)<code>plugins/</code>目录，创建名为：<code>element-ui.js</code>的文件，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>    <span class="hljs-comment">//引入Button按钮</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;&#123;<br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Button</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>第二步，引入插件</p></blockquote><p>在<code>nuxt.config.js</code>中，添加配置为：<code>plugins</code></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">css:[<br><span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br>],<br>plugins:[<br><span class="hljs-string">&#x27;~/plugins/element-ui&#x27;</span><br>]<br></code></pre></td></tr></table></figure><p>默认为：开启SSR,采用服务端渲染，也可以<strong>手动配置关闭SSR</strong>，配置为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">css:[<br><span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br>],<br>plugins:[<br>    &#123;<br>        <span class="hljs-attribute">src</span>:<span class="hljs-string">&#x27;~/plugins/element-ui&#x27;</span>,<br>        ssr:false    //关闭ssr<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><blockquote><p>第三步，配置<code>babel</code>选项</p></blockquote><p>在<code>nuxt.config.js</code>中，配置在<code>build</code>选项中，规则为官网规则：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gradle">build: &#123;<br>      babel:&#123;        <span class="hljs-comment">//配置按需引入规则</span><br>          <span class="hljs-string">&quot;plugins&quot;</span>:[<br>              [<br>                  <span class="hljs-string">&quot;component&quot;</span>,<br>                  &#123;<br>                      <span class="hljs-string">&quot;libraryName&quot;</span>:<span class="hljs-string">&quot;element-ui&quot;</span>,<br>                      <span class="hljs-string">&quot;styleLibraryName&quot;</span>:<span class="hljs-string">&quot;theme-chalk&quot;</span><br>                  &#125;<br>              ]<br>          ]<br>      &#125;,<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     ** Run ESLINT on save</span><br><span class="hljs-comment">     */</span><br>    extend (config, ctx) &#123;<br>      <span class="hljs-keyword">if</span> (ctx.isClient) &#123;<br>        config.module.rules.<span class="hljs-keyword">push</span>(&#123;<br>           enforce: <span class="hljs-string">&#x27;pre&#x27;</span>,<br>           test: <span class="hljs-regexp">/\.(js|vue)$/</span>,<br>           loader: <span class="hljs-string">&#x27;eslint-loader&#x27;</span>,<br>           <span class="hljs-keyword">exclude</span>: <span class="hljs-regexp">/(node_modules)/</span><br>        &#125;)<br>      &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="3-axios的使用"><a href="#3-axios的使用" class="headerlink" title="3.axios的使用"></a>3.axios的使用</h3><ol><li>安装<code>npm install --save axios</code></li><li>使用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-title function_">asyncData</span>(<span class="hljs-params">context, callback</span>) &#123;<br>  axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3301/in_theaters&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>      <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, &#123;<span class="hljs-attr">list</span>: res.<span class="hljs-property">data</span>&#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>为防止重复打包，在nuxt.config.js中配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  build: &#123;<br>    vendor: [<span class="hljs-string">&#x27;axios&#x27;</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-vuex的使用"><a href="#4-vuex的使用" class="headerlink" title="4.vuex的使用"></a>4.vuex的使用</h3><p>Nuxt.js 内置引用了 <code>vuex</code> 模块，所以不需要额外安装。</p><p>Nuxt.js 会找到应用根目录下的 <code>store</code> 目录，如果该目录存在，它将做以下的事情：</p><ol><li>引用 <code>vuex</code> 模块</li><li>将 <code>vuex</code> 模块 加到 vendors 构建配置中去</li><li>设置 <code>Vue</code> 根实例的 <code>store</code> 配置项</li></ol><p>Nuxt.js 支持两种使用 <code>store</code> 的方式，你可以择一使用：</p><ul><li>模块方式： <code>store</code> 目录下的每个 <code>.js</code> 文件会被转换成为状态树<a href="https://vuex.vuejs.org/guide/modules.html">指定命名的子模块</a> （当然，<code>index</code> 是根模块）</li><li>普通方式： <code>store/index.js</code> 返回一个 Vuex.Store 实例（官方不推荐）</li></ul><p>模块方式</p><p>状态树还可以拆分成为模块，<code>store</code> 目录下的每个 <code>.js</code> 文件会被转换成为状态树<a href="https://vuex.vuejs.org/guide/modules.html">指定命名的子模块</a></p><p>使用状态树模块化的方式，<code>store/index.js</code> 不需要返回 Vuex.Store 实例，而应该直接将 <code>state</code>、<code>mutations</code> 和 <code>actions</code> 暴露出来：</p><p><code>index.js</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">state</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<br>    <span class="hljs-attr">articleTitle</span>: [],<br>    <span class="hljs-attr">labelList</span>: []<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mutations = &#123;<br>    <span class="hljs-comment">// 设置热门文章标题</span><br>    <span class="hljs-title function_">updateArticleTitle</span>(<span class="hljs-params">state, action</span>) &#123;<br>        state.<span class="hljs-property">articleTitle</span> = action<br>    &#125;,<br>    <span class="hljs-comment">// 设置标签列表数据</span><br>    <span class="hljs-title function_">updateLabel</span>(<span class="hljs-params">state, action</span>)&#123;<br>        state.<span class="hljs-property">labelList</span> = action<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> actions = &#123;<br>    <span class="hljs-comment">// 获取热门文章标题</span><br>    <span class="hljs-title function_">fetchArticleTitle</span>(<span class="hljs-params">&#123; commit &#125;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$axios</span><br>            .$get(<span class="hljs-string">&#x27;http://localhost:3000/article/title&#x27;</span>)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>                <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;updateArticleTitle&#x27;</span>, response.<span class="hljs-property">data</span>)<br>            &#125;)<br>    &#125;,<br>    <span class="hljs-comment">// 获取标签</span><br>    <span class="hljs-title function_">fetchLabel</span>(<span class="hljs-params">&#123; commit &#125;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$axios</span><br>            .$get(<span class="hljs-string">&#x27;http://localhost:3000/label/list&#x27;</span>)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>                <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;updateLabel&#x27;</span>, response.<span class="hljs-property">data</span>)<br>            &#125;)<br>    &#125;,<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>index.vue</code><br> <code>fetch</code>方法中触发异步提交状态事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ArticleList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;~/components/archive/list&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Banner</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;~/components/archive/banner&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">ArticleList</span>,</span><br><span class="language-javascript">    <span class="hljs-title class_">Banner</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-keyword">async</span> <span class="hljs-title function_">asyncData</span>(<span class="hljs-params">&#123; app &#125;</span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-comment">//获取文章列表数据</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> article = <span class="hljs-keyword">await</span> app.<span class="hljs-property">$axios</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">`http://localhost:3000/article/list?pageNum=1&amp;pageSize=5`</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">articleList</span>: article.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>&#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">&#123; store &#125;</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([</span><br><span class="language-javascript">          store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;common/fetchArticleTitle&#x27;</span>),</span><br><span class="language-javascript">          store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;common/fetchLabel&#x27;</span>)</span><br><span class="language-javascript">      ])</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应组件中通过<code>computed</code> 方法获取状态数据</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">computed: &#123;<br>      labelList()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$store.state.common.labelList<br>      &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure><h2 id="六、Nuxt的错误页面和个性meta设置"><a href="#六、Nuxt的错误页面和个性meta设置" class="headerlink" title="六、Nuxt的错误页面和个性meta设置"></a>六、Nuxt的错误页面和个性meta设置</h2><p>当用户输入路由错误的时候，我们需要给他一个明确的指引，所以说在应用程序开发中404页面是必不可少的。Nuxt.js支持直接在默认布局文件夹里建立错误页面。</p><h3 id="1-建立错误页面"><a href="#1-建立错误页面" class="headerlink" title="1.建立错误页面"></a>1.建立错误页面</h3><p>在根目录下的layouts文件夹下建立一个error.vue文件，它相当于一个显示应用错误的组件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;error.statusCode==404&quot;</span>&gt;</span>404页面不存在<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-else</span>&gt;</span>500服务器错误<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>HOME<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;error&#x27;</span>],</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>代码用v-if进行判断错误类型，需要注意的是这个错误是你需要在<code>&lt;script&gt;</code>里进行声明的，如果不声明程序是找不到error.statusCode的。</p><p>这里我也用了一个<code>&lt;nuxt-link&gt;</code>的简单写法直接跟上路径就可以了。</p><h3 id="2-个性meta设置"><a href="#2-个性meta设置" class="headerlink" title="2.个性meta设置"></a>2.个性meta设置</h3><p>页面的Meta对于SEO的设置非常重要，比如你现在要作个新闻页面，那为了搜索引擎对新闻的收录，需要每个页面对新闻都有不同的title和meta设置。直接使用head方法来设置当前页面的头部信息就可以了。我们现在要把New-1这个页面设置成个性的meta和title。</p><p>1.我们先把<code>pages/news/index.vue</code>页面的链接进行修改一下，传入一个title，目的是为了在新闻具体页面进行接收title，形成文章的标题。</p><p>&#x2F;pages&#x2F;news&#x2F;index.vue</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;name:&#x27;news-id&#x27;,params:&#123;id:123,title:&#x27;nuxt.com&#x27;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&#125;&quot;</span>&gt;</span>News-1<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>2.第一步完成后，我们修改&#x2F;pages&#x2F;news&#x2F;_id.vue，让它根据传递值变成独特的meta和title标签。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>News-Content [</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$route.params.id</span>&#125;&#125;</span><span class="language-xml">]<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  validate (&#123; params &#125;) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// Must be a number</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^\d+$/</span>.<span class="hljs-title function_">test</span>(params.<span class="hljs-property">id</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">title</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">title</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//独立设置head信息</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">head</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">title</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">meta</span>:[</span></span><br><span class="language-javascript"><span class="language-xml">          &#123;<span class="hljs-attr">hid</span>:<span class="hljs-string">&#x27;description&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;news&#x27;</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;This is news page&#x27;</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">        ]</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>注意：为了避免子组件中的meta标签不能正确覆盖父组件中相同的标签而产生重复的现象，建议利用 hid 键为meta标签配一个唯一的标识编号。</p><h2 id="七、asyncData方法获取数据"><a href="#七、asyncData方法获取数据" class="headerlink" title="七、asyncData方法获取数据"></a>七、asyncData方法获取数据</h2><p>Nuxt.js贴心的为我们扩展了Vue.js的方法，增加了anyncData，异步请求数据。</p><h3 id="1-三种方式"><a href="#1-三种方式" class="headerlink" title="1.三种方式"></a>1.三种方式</h3><p>Nuxt.js 提供了几种不同的方法来使用 <code>asyncData</code> 方法，你可以选择自己熟悉的一种来用：</p><ol><li>返回一个 <code>Promise</code>, nuxt.js会等待该<code>Promise</code>被解析之后才会设置组件的数据，从而渲染组件.</li><li>使用 <code>async</code> 或 <code>await</code></li><li>使用回调函数</li></ol><p><strong>返回Promise</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">export default &#123;<br>  asyncData (&#123; params &#125;) &#123;<br>    return axios.get(`https://my-api/posts/$&#123;params.id&#125;`)<br>      .then((res) =&gt; &#123;<br>        return &#123; title: res.data.title &#125;<br>      &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用async或await</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">export default &#123;<br>  async asyncData (&#123; params &#125;) &#123;<br>    const &#123; data &#125; = await axios.get(`https://my-api/posts/$&#123;params.id&#125;`)<br>    return &#123; title: data.title &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用回调函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">export default &#123;<br>  asyncData (&#123; params &#125;, callback) &#123;<br>    axios.get(`https://my-api/posts/$&#123;params.id&#125;`)<br>      .then((res) =&gt; &#123;<br>        callback(null, &#123; title: res.data.title &#125;)<br>      &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>安装Axios</p><p>Vue.js官方推荐使用的远程数据获取方式就Axios，所以我们安装官方推荐，来使用Axios。这里我们使用npm 来安装 axios。 直接在终端中输入下面的命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install axios <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="2-ansycData的promise方法"><a href="#2-ansycData的promise方法" class="headerlink" title="2.ansycData的promise方法"></a>2.ansycData的promise方法</h3><p>我们在pages下面新建一个文件，叫做ansyData.vue。然后写入下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">         <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello World&#x27;</span>,</span><br><span class="language-javascript">     &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">asyncData</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;接口&#x27;</span>)</span><br><span class="language-javascript">      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">info</span>:res.<span class="hljs-property">data</span>&#125;</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>asyncData的方法会把值返回到data中。是组件创建（页面渲染）之前的动作，所以不能使用this.info,</p><p><strong># return的重要性</strong></p><p><em>一定要return出去获取到的对象，这样就可以在组件中使用，这里返回的数据会和组件中的data合并。这个函数不光在服务端会执行，在客户端同样也会执行。</em></p><h3 id="3-ansycData的promise并发应用"><a href="#3-ansycData的promise并发应用" class="headerlink" title="3.ansycData的promise并发应用"></a>3.ansycData的promise并发应用</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe">async asyncData(context) &#123;<br>  let [<span class="hljs-keyword">new</span><span class="hljs-type">DetailRes</span>, hotInformationRes, correlationRes] = await Promise.all([<br>    axios.post(<span class="hljs-string">&#x27;http://www.huanjingwuyou.com/eia/news/detail&#x27;</span>, &#123;<br>      <span class="hljs-keyword">new</span><span class="hljs-type">sCode</span>: <span class="hljs-keyword">new</span><span class="hljs-type">sCode</span><br>    &#125;),<br>    axios.post(<span class="hljs-string">&#x27;http://www.huanjingwuyou.com/eia/news/select&#x27;</span>, &#123;<br>      <span class="hljs-keyword">new</span><span class="hljs-type">sType</span>: <span class="hljs-keyword">new</span><span class="hljs-type">sType</span>, <span class="hljs-comment">// 资讯类型： 3环评资讯 4环评知识</span><br>      start: <span class="hljs-type">0</span>, <span class="hljs-comment">// 从第0条开始</span><br>      pageSize: <span class="hljs-type">10</span>,<br>      <span class="hljs-keyword">new</span><span class="hljs-type">sRecommend</span>: <span class="hljs-literal">true</span><br>    &#125;),<br>    axios.post(<span class="hljs-string">&#x27;http://www.huanjingwuyou.com/eia/news/select&#x27;</span>, &#123;<br>      <span class="hljs-keyword">new</span><span class="hljs-type">sType</span>: <span class="hljs-keyword">new</span><span class="hljs-type">sType</span>, <span class="hljs-comment">// 资讯类型： 3环评资讯 4环评知识</span><br>      start: <span class="hljs-type">0</span>, <span class="hljs-comment">// 从第0条开始</span><br>      pageSize: <span class="hljs-type">3</span>,<br>      <span class="hljs-keyword">new</span><span class="hljs-type">sRecommend</span>: <span class="hljs-literal">false</span><br>    &#125;)<br>  ])<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-keyword">new</span><span class="hljs-type">DetailList</span>: <span class="hljs-keyword">new</span><span class="hljs-type">DetailRes</span>.data.result,<br>    hotNewList: <span class="hljs-type">hotInformationRes</span>.data.result.data,<br>    <span class="hljs-keyword">new</span><span class="hljs-type">sList</span>: correlationRes.data.result.data,<br>    <span class="hljs-keyword">new</span><span class="hljs-type">sCode</span>: <span class="hljs-keyword">new</span><span class="hljs-type">sCode</span>,<br>    <span class="hljs-keyword">new</span><span class="hljs-type">sType</span>: <span class="hljs-keyword">new</span><span class="hljs-type">sType</span><br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="4-ansycData的await方法"><a href="#4-ansycData的await方法" class="headerlink" title="4.ansycData的await方法"></a>4.ansycData的await方法</h3><p>当然上面的方法稍显过时，现在都在用ansyc…await来解决异步,改写上面的代码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">     <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">         <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello World&#x27;</span>,</span><br><span class="language-javascript">     &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-keyword">async</span> <span class="hljs-title function_">asyncData</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> &#123;data&#125;=<span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;接口&#x27;</span>)</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">info</span>: data&#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-注意事项-生命周期："><a href="#5-注意事项-生命周期：" class="headerlink" title="5.注意事项+生命周期："></a>5.注意事项+生命周期：</h3><ol><li>asyncData 方法会在组件(限于页面组件)每次加载之前被调用</li><li>asyncData 可以在服务端或路由更新之前被调用</li><li>第一个参数被设定为当前页面的上下文对象</li><li>Nuxt会将 asyncData 返回的数据融合到组件的data方法返回的数据一并返回给组件使用</li><li>对于 asyncData 方式实在组件初始化前被调用的，所以在方法内饰没办法通过<code>this</code>来引用组件的实例对象</li></ol><h2 id="八、静态资源和打包"><a href="#八、静态资源和打包" class="headerlink" title="八、静态资源和打包"></a>八、静态资源和打包</h2><h3 id="1-静态资源"><a href="#1-静态资源" class="headerlink" title="1.静态资源"></a>1.静态资源</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">（<span class="hljs-number">1</span>）直接引入图片<br>在网上任意下载一个图片，放到项目中的<span class="hljs-keyword">static</span>文件夹下面，然后可以使用下面的引入方法进行引用<br>&lt;<span class="hljs-keyword">div</span>&gt;&lt;img src=<span class="hljs-string">&quot;~static/logo.png&quot;</span> <span class="hljs-regexp">/&gt;&lt;/</span><span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>“~”就相当于定位到了项目根目录，这时候图片路径就不会出现错误，就算打包也是正常的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">（2）CSS引入图片<br>如果在CSS中引入图片，方法和html中直接引入是一样的，也是用“~”符号引入。<br>复制代码<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.diss</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;~static/logo.png&#x27;</span>)</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这时候在npm run dev 下是完全正常的。</p><h3 id="2-打包"><a href="#2-打包" class="headerlink" title="2.打包"></a>2.打包</h3><p>用Nuxt.js制作完成后，你可以打包成静态文件并放在服务器上，进行运行。</p><p>在终端中输入：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">npm run <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>然后在dist文件夹下输入live-server就可以了。</p><p>总结：Nuxt.js框架非常简单，因为大部分的事情他都为我们做好了，我们只要安装它的规则来编写代码。</p><h2 id="九、nuxt的跨域解决-拦截器"><a href="#九、nuxt的跨域解决-拦截器" class="headerlink" title="九、nuxt的跨域解决+拦截器"></a>九、nuxt的跨域解决+拦截器</h2><h3 id="一、axios与-nuxtjs-x2F-axios"><a href="#一、axios与-nuxtjs-x2F-axios" class="headerlink" title="一、axios与@nuxtjs&#x2F;axios"></a>一、axios与@nuxtjs&#x2F;axios</h3><h4 id="一、了解"><a href="#一、了解" class="headerlink" title="一、了解"></a>一、了解</h4><p>nuxt.js 在创建项目的时候可以选择安装 axios。<br><strong><u>axios 与 @nuxtjs&#x2F;axios 可以共用 nuxt.config.js 中代理配置。</u></strong></p><p>使用的时候需要注意 asyncData() 中需要请求全链接或者服务器有配代理的接口，也就是在服务器渲染的时候需要拿到组装的数据，等到了浏览器本地之后，需要走代理请求，否则会出现跨域，支持加载更多跟其他接口请求操作，更换数据也是没问题的，但是到浏览器之后必须走代理请求，在服务器渲染的时候必须走全链接请求或者走服务器配置了代理的请求，没配置代理就走全链接请求，在服务器不存在跨域</p><h4 id="二、使用-nuxtjs-x2F-axios和"><a href="#二、使用-nuxtjs-x2F-axios和" class="headerlink" title="二、使用 @nuxtjs&#x2F;axios和"></a>二、使用 @nuxtjs&#x2F;axios和</h4><p>在创建项目的时候，就可以选择导入 @nuxtjs&#x2F;axios，它是对 axios 包装，更好在 nuxt.js 中使用，可以通过 this.$axios.get(url).then() 进行全局使用。</p><p>检查 package.json 文件中 dependencies 有没有存在 @nuxtjs&#x2F;axios，没有命令行安装(建议创建项目的时候就通过脚手架安装上), @nuxtjs&#x2F;proxy代理</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install --save @nuxtjs/axios @nuxtjs/proxy<br></code></pre></td></tr></table></figure><p><code>nuxt.config.js</code> 配置，代理配置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs awk">export default &#123;<br>  head: &#123; ... &#125;,<br>  css: [],<br><br>  modules: [<br>    <span class="hljs-string">&#x27;@nuxtjs/axios&#x27;</span>,<br>    <span class="hljs-string">&#x27;@nuxtjs/proxy&#x27;</span><br>  ],<br><br>  axios: &#123;<br>    <span class="hljs-regexp">//</span> 开启代理 (如果需要判断线上线下环境，可以通过 process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> 来判断)<br>    proxy: true,<br>    <span class="hljs-regexp">//</span> 给请求 url 加个前缀 /api，如果这项不配置，则需要手动添加到请求链接前面<br>    <span class="hljs-regexp">//</span> 如果是多个代理的时候，则不需要配置，走手动添加代理前缀<br>    prefix: <span class="hljs-string">&#x27;/api&#x27;</span>,<br>    <span class="hljs-regexp">//</span> 跨域请求时是否需要使用凭证<br>    credentials: true<br>  &#125;,<br><br>  proxy: &#123;<br>  <span class="hljs-regexp">//</span>当代理多个时，只需添加如下格式的数组对象即可<br>    <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;     <span class="hljs-regexp">//</span>  key(路由前缀)：value(target)(代理地址)<br>      <span class="hljs-regexp">//</span> 目标接口域   <br>      target: <span class="hljs-string">&#x27;http://test.dzm.com&#x27;</span>,<br>      <span class="hljs-regexp">//</span> 全局配置是否跨域<br>      changeOrigin: true,<br>      pathRewrite: &#123;<br>        <span class="hljs-regexp">//</span> 单个配置是否跨域<br>        <span class="hljs-regexp">//</span> changeOrigin: true<br>        <span class="hljs-regexp">//</span> 把 <span class="hljs-string">&#x27;/api&#x27;</span> 替换成 <span class="hljs-string">&#x27;/&#x27;</span>，具体需要替换为 <span class="hljs-string">&#x27;&#x27;</span> 还是 <span class="hljs-string">&#x27;/&#x27;</span> 看自己习惯<br>        <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;/&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;,<br><br>  build: &#123;<br>    <span class="hljs-regexp">//</span> 防止重复打包<br>    vendor: [<span class="hljs-string">&#x27;axios&#x27;</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在组件中使用，这样就可以在服务器渲染到页面之后，通过请求进行更换数据，因为到页面之后需要走代理的方式才能获取到数据，否则会报错跨域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">mounted() &#123;<br>    this.$axios.get(&quot;/index&quot;).then(res=&gt;&#123;<br>        console.log(res)<br>    &#125;)<br>    <br>    // axios 需要手动加上 &#x27;/api&#x27; 代理协议<br>    // @nuxtjs/axios 因为配置了 prefix: &#x27;/api&#x27; 会自动添加，否则也得手动添加<br>    // 访问的 url 地址为  http://x.x.x.x:3000/api/index<br>    // 然后根据上面代理转为 http://test.dzm.com/index<br>    // /api 会自动加到访问链接中<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三、使用-axios"><a href="#三、使用-axios" class="headerlink" title="三、使用 axios"></a>三、使用 <code>axios</code></h4><p>安装命令，默认一般 <code>nuxt.js</code> 自带 <code>axios</code>，是不需要手动安装的，在 <code>package.json</code> 文件中 <code>dependencies</code> 中可能并不体现出来，可以通过 <code>node_modules</code> 文件夹找到 <code>axios</code>。</p><p>安装<code>axios</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @nuxtjs/axios --save-dev<br></code></pre></td></tr></table></figure><p>如果找到了，就不要去安装了，直接使用即可，**<u>axios 与 @nuxtjs&#x2F;axios 可以共用 nuxt.config.js 中代理配置。</u>**可直接在vue组件中使用即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/index&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// axios 需要手动加上 &#x27;/api&#x27; 代理协议</span></span><br><span class="language-javascript">        <span class="hljs-comment">// @nuxtjs/axios 因为配置了 prefix: &#x27;/api&#x27; 会自动添加，否则也得手动添加</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 访问的 url 地址为  http://x.x.x.x:3000/api/index</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 然后根据上面代理转为 http://test.dzm.com/index</span></span><br><span class="language-javascript">        <span class="hljs-comment">// /api 会自动加到访问链接中</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong><code>axios</code> 可以进行封装使用，跟 <code>vue</code> 中一样</strong></p><p><code>axios.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-comment">// 请求地址，为空则请求的时候带上</span><br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-comment">// 请求超时时间</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">90000</span><br>&#125;)<br><br><span class="hljs-keyword">export</span> &#123;<br>  service <span class="hljs-keyword">as</span> axios<br>&#125;<br></code></pre></td></tr></table></figure><p><code>request.js</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs php">import &#123; axios &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./axios&#x27;</span><br><span class="hljs-comment">// 请求地址</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BASE_URL</span> = process.env.NODE_ENV === <span class="hljs-string">&#x27;production&#x27;</span> ? <span class="hljs-string">&#x27;http://dzm.com&#x27;</span> : <span class="hljs-string">&#x27;http://test.dzm.com&#x27;</span><br><br><span class="hljs-comment">// 这种带全链接用于放在 asyncData() 中进行 SEO 请求</span><br>export <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getxxx</span> (<span class="hljs-params">parameter</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: BASE_URL + `/<span class="hljs-keyword">list</span>`,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: parameter<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 这种带全链接用于放在 asyncData() 中进行 SEO 请求</span><br>export <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postxxx</span> (<span class="hljs-params">parameter</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: BASE_URL + `/reload`,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">data</span>: parameter<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 这种带全链接用于放在页面加载到浏览器之后，加载更多或者其他请求操作使用，不会出现跨域问题</span><br>export <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getxxx</span> (<span class="hljs-params">parameter</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/api&#x27;</span> + `/<span class="hljs-keyword">list</span>`,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: parameter<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 这种带全链接用于放在页面加载到浏览器之后，加载更多或者其他请求操作使用，不会出现跨域问题</span><br>export <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postxxx</span> (<span class="hljs-params">parameter</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/api&#x27;</span> + `/reload`,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">data</span>: parameter<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="四、拦截器"><a href="#四、拦截器" class="headerlink" title="四、拦截器"></a>四、拦截器</h4><p>安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @nuxtjs/axios @nuxtjs/proxy --save<br></code></pre></td></tr></table></figure><p><code>nuxt.config.js</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">module.expores&#123;<br>  plugins: [<br>    &#123;<br>      src: <span class="hljs-string">&quot;~/plugins/axios&quot;</span>,<br>      ssr: false<br>    &#125;,<br>  ],<br>  modules: [<br>    <span class="hljs-regexp">//</span> Doc: https:<span class="hljs-regexp">//</span>axios.nuxtjs.org/usage<br>    <span class="hljs-string">&#x27;@nuxtjs/axios&#x27;</span>,<br>  ],<br>&#125;<br></code></pre></td></tr></table></figure><p><code>plugins/axios.js</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade">export default (&#123; <span class="hljs-symbol">$a</span>xios, redirect &#125;) =&gt; &#123;<br>  <span class="hljs-symbol">$a</span>xios.onRequest(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Making request to &#x27;</span> + config.url)<br>  &#125;)<br><br>  <span class="hljs-symbol">$a</span>xios.onError(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    const code = parseInt(error.response &amp;&amp; error.response.status)<br>    <span class="hljs-keyword">if</span> (code === <span class="hljs-number">400</span>) &#123;<br>      redirect(<span class="hljs-string">&#x27;/400&#x27;</span>)<br>    &#125;<br>  &#125;)<br>&#125;<br><br>export default <span class="hljs-keyword">function</span> (<span class="hljs-params">app</span>) &#123;<br>  let axios = app.<span class="hljs-symbol">$a</span>xios; <br> <span class="hljs-comment">// 基本配置</span><br>  axios.defaults.timeout = <span class="hljs-number">10000</span><br>  axios.defaults.headers.post[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] = <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br><br>  <span class="hljs-comment">// 请求回调</span><br>  axios.onRequest(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;&#125;)<br><br>  <span class="hljs-comment">// 返回回调</span><br>  axios.onResponse(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;&#125;)<br><br>  <span class="hljs-comment">// 错误回调</span><br>  axios.onError(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十、-nuxtjs-x2F-toast模块"><a href="#十、-nuxtjs-x2F-toast模块" class="headerlink" title="十、@nuxtjs&#x2F;toast模块"></a>十、@nuxtjs&#x2F;toast模块</h2><p>nuxt中toast组件可参考element中的message，共四个状态</p><p>toast可以说是很常用的功能，一般的UI框架都会有这个功能。但如果你的站点没有使用UI框架，而alert又太丑，不妨引入该模块：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">npm install @nuxtjs/toast<br></code></pre></td></tr></table></figure><p>然后在<code>nuxt.config.js</code>中引入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">module.exports = &#123;<br>    modules: [<br>    &#x27;@nuxtjs/toast&#x27;,<br>    [&#x27;@nuxtjs/dotenv&#x27;, &#123; filename: &#x27;.env.prod&#x27; &#125;] // 指定打包时使用的dotenv<br>  ],<br>  toast: &#123;// toast模块的配置<br>    position: &#x27;top-center&#x27;, <br>    duration: 2000<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，nuxt就会在全局注册<code>$toast</code>方法供你使用，非常方便：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">this.$toast.error(&#x27;服务器开小差啦~~&#x27;)<br>this.$toast.error(&#x27;请求成功~~&#x27;)<br></code></pre></td></tr></table></figure><h2 id="十一、生命周期延展"><a href="#十一、生命周期延展" class="headerlink" title="十一、生命周期延展"></a>十一、生命周期延展</h2><p>Nuxt扩展了Vue的生命周期，大概如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">export default &#123;<br>  middleware () &#123;&#125;, //服务端<br>  validate () &#123;&#125;, // 服务端<br>  asyncData () &#123;&#125;, //服务端<br>  fetch () &#123;&#125;, // store数据加载<br>  beforeCreate () &#123;  // 服务端和客户端都会执行&#125;,<br>  created () &#123; // 服务端和客户端都会执行 &#125;,<br>  beforeMount () &#123;&#125;, <br>  mounted () &#123;&#125; // 客户端<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一、asyncData"><a href="#一、asyncData" class="headerlink" title="一、asyncData"></a>一、asyncData</h3><p>该方法是Nuxt最大的一个卖点，服务端渲染的能力就在这里，首次渲染时务必使用该方法。<br>asyncData会传进一个context参数，通过该参数可以获得一些信息，如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">export default &#123;<br>  asyncData (ctx) &#123;<br>    ctx.app // 根实例<br>    ctx.route // 路由实例<br>    ctx.params  //路由参数<br>    ctx.query  // 路由问号后面的参数<br>    ctx.error   // 错误处理方法<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、渲染出错和ajax请求出错的处理"><a href="#二、渲染出错和ajax请求出错的处理" class="headerlink" title="二、渲染出错和ajax请求出错的处理"></a>二、渲染出错和ajax请求出错的处理</h3><ul><li>asyncData渲染出错</li></ul><p>使用<code>asyncData</code>钩子时可能会由于服务器错误或api错误导致无法渲染，此时页面还未渲染出来，需要针对这种情况做一些处理，当遇到asyncData错误时，跳转到错误页面，nuxt提供了<code>context.error</code>方法用于错误处理，在asyncData中调用该方法即可跳转到错误页面。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">export default &#123;<br>    async asyncData (ctx) &#123;<br>        // 尽量使用try catch的写法，将所有异常都捕捉到<br>        try &#123;<br>            throw new Error()<br>        &#125; catch &#123;<br>            ctx.error(&#123;statusCode: 500, message: &#x27;服务器开小差了~&#x27; &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，当出现异常时会跳转到<a href="https://nuxtjs.org/docs/concepts/views/#%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2">默认的错误页</a>，错误页面可以通过<code>/layout/error.vue</code>自定义。</p><p>这里会遇到一个问题，<code>context.error</code>的参数必须是类似<code>&#123; statusCode: 500, message: &#39;服务器开小差了~&#39; &#125;</code>，<code>statusCode</code>必须是http状态码，<br>而我们服务端返回的错误往往有一些其他的自定义代码，如<code>&#123;resultCode: 10005, resultInfo: &#39;服务器内部错误&#39; &#125;</code>，此时需要对返回的api错误进行转换一下。</p><p>为了方便，我引入了<code>/plugins/ctx-inject.js</code>为context注册一个全局的错误处理方法： <code>context.$errorHandler(err)</code>。注入方法可以参考：<a href="https://nuxtjs.org/docs/directory-structure/plugins/#%E6%B3%A8%E5%85%A5-vue-%E5%AE%9E%E4%BE%8B">注入 $root 和 context</a>，<code>ctx-inject.js</code>:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">// 为context注册全局的错误处理事件<br>export default (ctx, inject) =&gt; &#123;<br>  ctx.$errorHandler = err =&gt; &#123;<br>    try &#123;<br>      const res = err.data<br>      if (res) &#123;<br>        // 由于nuxt的错误页面只能识别http的状态码，因此statusCode统一传500，表示服务器异常。<br>        ctx.error(&#123; statusCode: 500, message: res.resultInfo &#125;)<br>      &#125; else &#123;<br>        ctx.error(&#123; statusCode: 500, message: &#x27;服务器开小差了~&#x27; &#125;)<br>      &#125;<br>    &#125; catch &#123;<br>      ctx.error(&#123; statusCode: 500, message: &#x27;服务器开小差了~&#x27; &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>nuxt.config.js</code>使用该插件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">export default &#123;<br>  plugins: [<br>    &#x27;~/plugins/ctx-inject.js&#x27;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>注入完毕，我们就可以在<code>asyncData</code>介个样子使用了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">export default &#123;<br>    async asyncData (ctx) &#123;<br>        // 尽量使用try catch的写法，将所有异常都捕捉到<br>        try &#123;<br>            throw new Error()<br>        &#125; catch(err) &#123;<br>            ctx.$errorHandler(err)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ajax请求出错</li></ul><p>对于ajax的异常，此时页面已经渲染，出现错误时不必跳转到错误页，可以通过<code>this.$toast.error(res.message)</code> toast出来即可。</p><h3 id="三、loading方法"><a href="#三、loading方法" class="headerlink" title="三、loading方法"></a>三、loading方法</h3><p>nuxt内置了页面顶部<a href="https://nuxtjs.org/docs/configuration-glossary/configuration-loading/#loading-%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE">loading进度条的样式</a><br>推荐使用，提供页面跳转体验。<br>打开： <code>this.$nuxt.$loading.start()</code><br>完成： <code>this.$nuxt.$loading.finish()</code></p><h2 id="十二、注意事项"><a href="#十二、注意事项" class="headerlink" title="十二、注意事项"></a>十二、注意事项</h2><h3 id="1-如何在-head-里面引入js文件"><a href="#1-如何在-head-里面引入js文件" class="headerlink" title="1. 如何在 head 里面引入js文件?"></a>1. 如何在 head 里面引入js文件?</h3><blockquote><p>背景: 在<code>&lt;head&gt;</code>标签中，以inline的形式引入<code>flexible.js</code>文件。本项目主要为移动端项目，引入<code>flexible.js</code> 实现移动端适配问题。</p></blockquote><p>Nuxt.js 通过 <code>vue-meta</code> 实现头部标签管理，通过查看文档发现，可以按照如下方式配置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">head: &#123;<br>  script: [&#123; innerHTML: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./assets/js/flexible&#x27;</span>), type: <span class="hljs-string">&#x27;text/javascript&#x27;</span>, charset: <span class="hljs-string">&#x27;utf-8&#x27;</span>&#125;],<br>  __dangerouslyDisableSanitizers: [<span class="hljs-string">&#x27;script&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-nuxt使用less-sass等预处理器"><a href="#2-nuxt使用less-sass等预处理器" class="headerlink" title="2.nuxt使用less,sass等预处理器"></a>2.nuxt使用less,sass等预处理器</h3><blockquote><p>背景：在组件中的<code>&lt;template&gt;</code>， <code>&lt;script&gt;</code> 或 <code>&lt;style&gt;</code> 上使用各种预处理器，加上处理器后，控制台报错。</p></blockquote><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install --save-dev <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> sass-loader<br></code></pre></td></tr></table></figure><p>但是解决过程并不是很顺利的，在阅读中文文档时，忽略版本号，按照上面的提示进行操作，发现不能成功，后来各种debug，最后发现了该解决方案。后知后觉的发现了中文文档的版本号过低，如果需要查看文档，一定要看最新版本的英文文档！</p><h3 id="3-如何使用px2rem"><a href="#3-如何使用px2rem" class="headerlink" title="3. 如何使用px2rem"></a>3. 如何使用px2rem</h3><blockquote><p>背景：在css中，写入px，通过<code>px2rem loader</code>，将px转换成rem</p></blockquote><p>在以前的项目中，是通过 <code>px2rem loader</code>实现的，但是在Nuxt.js项目下，添加 css loader 还是很费力的，因为涉及到<code>vue-loader</code>。</p><p>想到了一个其他方案，可以使用 <code>postcss</code> 处理。可以在 <code>nuxt.config.js</code> 文件中添加配置，也可以在<code>postcss.conf.js</code>文件中添加。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">build: &#123;<br>  postcss: [<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;postcss-px2rem&#x27;</span>)(&#123;<br>      remUnit: <span class="hljs-number">75</span> // 转换基本单位<br>    &#125;)<br>  ]<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="4-如何拓展-webpack-配置"><a href="#4-如何拓展-webpack-配置" class="headerlink" title="4. 如何拓展 webpack 配置"></a>4. 如何拓展 webpack 配置</h3><blockquote><p>背景：给 utils 目录添加别名</p></blockquote><p>刚刚说到，Nuxt.js内置了 <code>webpack</code> 配置，如果想要拓展配置，可以在 <code>nuxt.config.js</code> 文件中添加。同时也可以在该文件中，将配置信息打印出来。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">extend (config, ctx) &#123;<br>  console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;webpack config:&#x27;</span>, config)<br>  <span class="hljs-keyword">if</span> (ctx.isClient) &#123;<br>    <span class="hljs-comment">// 添加 alias 配置</span><br>    Object<span class="hljs-selector-class">.assign</span>(config<span class="hljs-selector-class">.resolve</span><span class="hljs-selector-class">.alias</span>, &#123;<br>      <span class="hljs-string">&#x27;utils&#x27;</span>: path<span class="hljs-selector-class">.resolve</span>(__dirname, <span class="hljs-string">&#x27;utils&#x27;</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-如何添加-vue-plugin"><a href="#5-如何添加-vue-plugin" class="headerlink" title="5. 如何添加 vue plugin"></a>5. 如何添加 vue plugin</h3><blockquote><p>背景：自己封装了一个 toast vue plugin，由于 vue 实例化的过程没有暴露出来，不知道在哪个时机注入进去。</p></blockquote><p>可以在 <code>nuxt.config.js</code> 中添加 plugins 配置，这样插件就会在 Nuxt.js 应用初始化之前被加载导入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  plugins: [<span class="hljs-string">&#x27;~plugins/toast&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>~plugins/toast.js</code> 文件：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> toast <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/toast&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../assets/css/toast.css&#x27;</span><br><br>Vue.use(toast)<br></code></pre></td></tr></table></figure><p>​     <a href="https://www.nuxtjs.cn/guide/installation">nuxt官网</a></p><p>本文参考:</p><p>​          <a href="https://juejin.cn/post/6844903833840123912">Nuxt爬坑</a></p><p>​         <a href="https://www.bilibili.com/video/BV1654y1r7rM">B站nuxt入门视频</a></p><p>​          <a href="https://juejin.cn/post/6844904160324747278#heading-18">点亮你的Vue技术栈，万字Nuxt.js实践笔记来了</a></p>]]></content>
    
    
    <categories>
      
      <category>Nuxt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nuxt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习指南</title>
    <link href="./2023/03/08/typeScript%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <url>./2023/03/08/typeScript%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript学习指南"><a href="#TypeScript学习指南" class="headerlink" title="TypeScript学习指南"></a>TypeScript学习指南</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> Vue2 和 TS 的结合总感觉不是很丝滑 ,<strong>react hook+ts</strong> 这一套组合拳 然后在重新认真学习并在项目里用上了 ts 之后 ,最直观的感受就是可以帮我们规避很多类型错误 更友好的提示 甚至有些方法我们根据定义的类型大概就知道作用是什么了（去掉了写注释的麻烦）况且如今大火的 <strong>Vue3</strong> 也是 TS 重构的 然后 react 和 ts 的结合就更不必说</p><h3 id="1-ts-安装和编译"><a href="#1-ts-安装和编译" class="headerlink" title="1 ts 安装和编译"></a>1 ts 安装和编译</h3><ul><li>第一步 新建一个空文件夹用来学习 ts</li><li>第二步 全局安装 ts 和 ts-node</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm i typescript -g //全局安装ts<br>cnpm i -g ts-node //全局安装ts-node<br></code></pre></td></tr></table></figure><ul><li>第三步 生成 tsconfig.js 配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tsc --init<br></code></pre></td></tr></table></figure><p>我们就先按照自动生成的 tsconfig 配置项去使用 里面的配置咱们可以先不去管他 后续熟练了再去配置</p><ul><li>第四步 在项目下新建一个 <code>index.ts</code> 直接写入</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br></code></pre></td></tr></table></figure><ul><li>第五步 编译 ts 为 js 在控制台（终端）输入命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tsc index.ts<br></code></pre></td></tr></table></figure><p>神奇的事情发生了 项目下出现了一个同名的 index.js 文件 至此我们已经可以把 ts 文件编译成 js 文件了</p><p>不过到这里聪明的小伙伴就会发现了 我们全局安装的 <strong>ts-node</strong> 有什么作用呢 其实这个包是帮助我们在不需要编译成 js 的前提下就可以直接执行 ts 代码 比如 我们在控制台输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ts-node index.ts<br></code></pre></td></tr></table></figure><p>可以看到我们打印的 <code>hello</code>已经输出了</p><p>那可能 还有的小伙伴会发现 我们每次改动都要手动去执行编译 这样很麻烦 其实我们可以加一个参数来实现每次文件变动 ts 帮我们<strong>自动编译成 js</strong> 的效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tsc --watch index.ts<br></code></pre></td></tr></table></figure><p>好了 环境安装完毕了 接下来出发去学习 ts 核心吧</p><h3 id="2-TS-类型"><a href="#2-TS-类型" class="headerlink" title="2 TS 类型"></a>2 TS 类型</h3><h5 id="2-1-布尔类型-boolean"><a href="#2-1-布尔类型-boolean" class="headerlink" title="2.1 布尔类型(boolean)"></a>2.1 布尔类型(boolean)</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">flag</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h5 id="2-2-Number-类型"><a href="#2-2-Number-类型" class="headerlink" title="2.2 Number 类型"></a>2.2 Number 类型</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">flag</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h5 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">flag</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-4-Enum-类型"><a href="#2-4-Enum-类型" class="headerlink" title="2.4 Enum 类型"></a>2.4 Enum 类型</h5><p>使用枚举我们可以很好的描述一些特定的业务场景，比如一年中的春、夏、秋、冬，还有每周的周一到周天，还有各种颜色，以及可以用它来描述一些状态信息，比如错误码等</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 普通枚举 初始值默认为 0 其余的成员会会按顺序自动增长 可以理解为数组下标</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>  <span class="hljs-variable constant_">RED</span>,<br>  <span class="hljs-variable constant_">PINK</span>,<br>  <span class="hljs-variable constant_">BLUE</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">pink</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">PINK</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pink); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 设置初始值</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>  <span class="hljs-variable constant_">RED</span> = <span class="hljs-number">10</span>,<br>  <span class="hljs-variable constant_">PINK</span>,<br>  <span class="hljs-variable constant_">BLUE</span>,<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">pink</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">PINK</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pink); <span class="hljs-comment">// 11</span><br><br><span class="hljs-comment">// 字符串枚举 每个都需要声明</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>  <span class="hljs-variable constant_">RED</span> = <span class="hljs-string">&quot;红色&quot;</span>,<br>  <span class="hljs-variable constant_">PINK</span> = <span class="hljs-string">&quot;粉色&quot;</span>,<br>  <span class="hljs-variable constant_">BLUE</span> = <span class="hljs-string">&quot;蓝色&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">pink</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">PINK</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pink); <span class="hljs-comment">// 粉色</span><br><br><span class="hljs-comment">// 常量枚举 它是使用 const 关键字修饰的枚举，常量枚举与普通枚举的区别是，整个枚举会在编译阶段被删除 我们可以看下编译之后的效果</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>  <span class="hljs-variable constant_">RED</span>,<br>  <span class="hljs-variable constant_">PINK</span>,<br>  <span class="hljs-variable constant_">BLUE</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>[] = [<span class="hljs-title class_">Color</span>.<span class="hljs-property">RED</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">PINK</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">BLUE</span>];<br><br><span class="hljs-comment">//编译之后的js如下：</span><br><span class="hljs-keyword">var</span> color = [<span class="hljs-number">0</span> <span class="hljs-comment">/* RED */</span>, <span class="hljs-number">1</span> <span class="hljs-comment">/* PINK */</span>, <span class="hljs-number">2</span> <span class="hljs-comment">/* BLUE */</span>];<br><span class="hljs-comment">// 可以看到我们的枚举并没有被编译成js代码 只是把color这个数组变量编译出来了</span><br>复制代码<br></code></pre></td></tr></table></figure><h5 id="2-5-数组类型-array"><a href="#2-5-数组类型-array" class="headerlink" title="2.5 数组类型(array)"></a>2.5 数组类型(array)</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">flag1</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-attr">flag2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h5 id="2-6-元组类型-tuple"><a href="#2-6-元组类型-tuple" class="headerlink" title="2.6 元组类型(tuple)"></a>2.6 元组类型(tuple)</h5><p>在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知<strong>数量</strong>和<strong>类型</strong>的数组 其实可以理解为他是一种特殊的数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">flag</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h5 id="2-7-Symbol"><a href="#2-7-Symbol" class="headerlink" title="2.7 Symbol"></a>2.7 Symbol</h5><p>我们在使用 Symbol 的时候，必须添加 es6 的编译辅助库 需要在 tsconfig.json 的 <code>libs</code> 字段加上 <code>ES2015</code> Symbol 的值是唯一不变的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> sym1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">const</span> sym2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;hello&quot;</span>) === <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br></code></pre></td></tr></table></figure><h5 id="2-8-任意类型-any"><a href="#2-8-任意类型-any" class="headerlink" title="2.8 任意类型(any)"></a>2.8 任意类型(any)</h5><p>任何类型都可以被归为 <code>any</code> 类型 这让 <code>any</code> 类型成为了类型系统的 顶级类型 (也被称作 全局超级类型) TypeScript 允许我们对 <code>any</code> 类型的值执行任何操作 而无需事先执行任何形式的检查</p><p>一般使用场景： 第三方库没有提供类型文件时可以使用 <code>any</code> 类型转换遇到困难或者数据结构太复杂难以定义 不过不要太依赖 <code>any</code> 否则就失去了 ts 的意义了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">flag</span>: <span class="hljs-built_in">any</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="2-9-null-和-undefined"><a href="#2-9-null-和-undefined" class="headerlink" title="2.9 null 和 undefined"></a>2.9 null 和 undefined</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">undefined</span><span class="hljs-string">` 和 `</span><span class="hljs-literal">null</span><span class="hljs-string">` 两者有各自的类型分别为 `</span><span class="hljs-literal">undefined</span><span class="hljs-string">` 和 `</span><span class="hljs-literal">null</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h5 id="2-10-Unknown-类型"><a href="#2-10-Unknown-类型" class="headerlink" title="2.10 Unknown 类型"></a>2.10 Unknown 类型</h5><p><code>unknown</code> 和 <code>any</code> 的主要区别是 <code>unknown</code> 类型会更加严格 在对 <code>unknown</code> 类型的值执行大多数操作之前 我们必须进行某种形式的检查 而在对 <code>any</code> 类型的值执行操作之前 我们不必进行任何检查 所有类型都可以被归为 <code>unknown</code> 但 <code>unknown</code>类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身 而 <code>any</code> 啥都能分配和被分配</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>;<br><br>value = <span class="hljs-literal">true</span>; <span class="hljs-comment">// OK</span><br>value = <span class="hljs-number">42</span>; <span class="hljs-comment">// OK</span><br>value = <span class="hljs-string">&quot;Hello World&quot;</span>; <span class="hljs-comment">// OK</span><br>value = []; <span class="hljs-comment">// OK</span><br>value = &#123;&#125;; <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">value1</span>: <span class="hljs-built_in">unknown</span> = value; <span class="hljs-comment">// OK</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">value2</span>: <span class="hljs-built_in">any</span> = value; <span class="hljs-comment">// OK</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">value3</span>: <span class="hljs-built_in">boolean</span> = value; <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">value4</span>: <span class="hljs-built_in">number</span> = value; <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">value5</span>: <span class="hljs-built_in">string</span> = value; <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">value6</span>: <span class="hljs-built_in">object</span> = value; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><h5 id="2-11-void-类型"><a href="#2-11-void-类型" class="headerlink" title="2.11 void 类型"></a>2.11 void 类型</h5><p><code>void</code> 表示没有任何类型 当一个函数没有返回值时 TS 会认为它的返回值是 <code>void</code> 类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h5 id="2-12-never-类型"><a href="#2-12-never-类型" class="headerlink" title="2.12 never 类型"></a>2.12 never 类型</h5><p><code>never</code> 一般表示用户无法达到的类型 例如 <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">neverReach</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;an error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思考:never 和 void 的区别 void 可以被赋值为 null 和 undefined 的类型。 never 则是一个不包含值的类型。 拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。</p></blockquote><h5 id="2-13-BigInt-大数类型"><a href="#2-13-BigInt-大数类型" class="headerlink" title="2.13 BigInt 大数类型"></a>2.13 BigInt 大数类型</h5><p>使用 <code>BigInt</code> 可以安全地存储和操作大整数 我们在使用 <code>BigInt</code> 的时候 必须添加 <code>ESNext</code> 的编译辅助库 需要在 tsconfig.json 的 <code>libs</code> 字段加上 <code>ESNext</code> 要使用 <code>1n</code>需要 <code>&quot;target&quot;: &quot;ESNext&quot;</code> <code>number</code> 和 <code>BigInt</code> 类型不一样 不兼容</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> max1 = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>; <span class="hljs-comment">// 2**53-1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(max1 + <span class="hljs-number">1</span> === max1 + <span class="hljs-number">2</span>); <span class="hljs-comment">//true</span><br><br><span class="hljs-keyword">const</span> max2 = <span class="hljs-title class_">BigInt</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(max2 + <span class="hljs-number">1n</span> === max2 + <span class="hljs-number">2n</span>); <span class="hljs-comment">//false</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">bar</span>: <span class="hljs-built_in">bigint</span>;<br>foo = bar; <span class="hljs-comment">//error</span><br>bar = foo; <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><h5 id="2-14-object-Object-和-类型"><a href="#2-14-object-Object-和-类型" class="headerlink" title="2.14 object, Object 和 {} 类型"></a>2.14 object, Object 和 {} 类型</h5><p><strong>object</strong> 类型用于表示非原始类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">objectCase</span>: <span class="hljs-built_in">object</span>;<br>objectCase = <span class="hljs-number">1</span>; <span class="hljs-comment">// error</span><br>objectCase = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// error</span><br>objectCase = <span class="hljs-literal">true</span>; <span class="hljs-comment">// error</span><br>objectCase = <span class="hljs-literal">null</span>; <span class="hljs-comment">// error</span><br>objectCase = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// error</span><br>objectCase = &#123;&#125;; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p><strong>大 Object</strong> 代表所有拥有 toString、hasOwnProperty 方法的类型 所以所有原始类型、非原始类型都可以赋给 Object(严格模式下 <code>null</code> 和 <code>undefined</code> 不可以)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-title class_">ObjectCase</span>: <span class="hljs-title class_">Object</span>;<br><span class="hljs-title class_">ObjectCase</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// ok</span><br><span class="hljs-title class_">ObjectCase</span> = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// ok</span><br><span class="hljs-title class_">ObjectCase</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ok</span><br><span class="hljs-title class_">ObjectCase</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// error</span><br><span class="hljs-title class_">ObjectCase</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// error</span><br><span class="hljs-title class_">ObjectCase</span> = &#123;&#125;; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p><strong>{}</strong> 空对象类型和大 Object 一样 也是表示原始类型和非原始类型的集合</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">simpleCase</span>: &#123;&#125;;<br>simpleCase = <span class="hljs-number">1</span>; <span class="hljs-comment">// ok</span><br>simpleCase = <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// ok</span><br>simpleCase = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ok</span><br>simpleCase = <span class="hljs-literal">null</span>; <span class="hljs-comment">// error</span><br>simpleCase = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// error</span><br>simpleCase = &#123;&#125;; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><h5 id="2-15-类型推论"><a href="#2-15-类型推论" class="headerlink" title="2.15 类型推论"></a>2.15 类型推论</h5><p>指编程语言中能够自动推导出值的类型的能力 它是一些强静态类型语言中出现的特性 定义时未赋值就会推论成 <code>any</code> 类型 如果定义的时候就赋值就能利用到类型推论</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> flag; <span class="hljs-comment">//推断为any</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">123</span>; <span class="hljs-comment">//为number类型</span><br><span class="hljs-keyword">let</span> hello = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">//为string类型</span><br></code></pre></td></tr></table></figure><h5 id="2-16-联合类型"><a href="#2-16-联合类型" class="headerlink" title="2.16 联合类型"></a>2.16 联合类型</h5><p>联合类型（Union Types）表示取值可以为多种类型中的一种 未赋值时联合类型上只能访问两个类型共有的属性和方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-title function_">toString</span>());<br>name = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));<br>name = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-property">length</span>);<br></code></pre></td></tr></table></figure><h5 id="2-17-类型断言"><a href="#2-17-类型断言" class="headerlink" title="2.17 类型断言"></a>2.17 类型断言</h5><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。其实就是你需要手动告诉 ts 就按照你断言的那个类型通过编译（这一招很关键 有时候可以帮助你解决很多编译报错）</p><p>类型断言有两种形式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 尖括号 语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// as 语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><blockquote><p>以上两种方式虽然没有任何区别，但是尖括号格式会与 react 中 JSX 产生语法冲突，因此我们更推荐使用 as 语法。</p></blockquote><p><strong>非空断言</strong> 在上下文中当类型检查器无法断定类型时 一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 <code>null</code> 和非 <code>undefined</code> 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">flag</span>: <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">string</span>;<br>flag!.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// ok</span><br>flag.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><h5 id="2-18-字面量类型"><a href="#2-18-字面量类型" class="headerlink" title="2.18 字面量类型"></a>2.18 字面量类型</h5><p>在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。 目前，TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型，对应的字符串字面量、数字字面量、布尔字面量分别拥有与其值一样的字面量类型，具体示例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">flag1</span>: <span class="hljs-string">&quot;hello&quot;</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">flag2</span>: <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">flag3</span>: <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h5 id="2-19-类型别名"><a href="#2-19-类型别名" class="headerlink" title="2.19 类型别名"></a>2.19 类型别名</h5><p>类型别名用来给一个类型起个新名字</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> flag = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">value: flag</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><h5 id="2-20-交叉类型"><a href="#2-20-交叉类型" class="headerlink" title="2.20 交叉类型"></a>2.20 交叉类型</h5><p>交叉类型是将多个类型合并为一个类型。通过 &amp; 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Flag1</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Flag2</span> = <span class="hljs-title class_">Flag1</span> &amp; &#123; <span class="hljs-attr">y</span>: <span class="hljs-built_in">string</span> &#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">flag3</span>: <span class="hljs-title class_">Flag2</span> = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>  henb,<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="2-21-类型保护"><a href="#2-21-类型保护" class="headerlink" title="2.21 类型保护"></a>2.21 类型保护</h5><p>类型保护就是一些表达式，他们在编译的时候就能通过类型信息确保某个作用域内变量的类型 其主要思想是尝试检测属性、方法或原型，以确定如何处理值</p><p><strong>typeof 类型保护</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> input === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> input + input;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> input === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> input * <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> !input;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>in 关键字</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bird</span> &#123;<br>  <span class="hljs-attr">fly</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-attr">leg</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNumber</span>(<span class="hljs-params">value: Bird | Dog</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;fly&quot;</span> <span class="hljs-keyword">in</span> value) &#123;<br>    <span class="hljs-keyword">return</span> value.<span class="hljs-property">fly</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> value.<span class="hljs-property">leg</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>instanceof 类型保护</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  name!: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  fly!: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">animal: Animal</span>) &#123;<br>  <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Bird</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-property">fly</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义类型保护</strong></p><p>通过 <code>type is xxx</code>这样的类型谓词来进行类型保护</p><p>例如下面的例子 <code>value is object</code>就会认为如果函数返回 true 那么定义的 value 就是 object 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>): value is <span class="hljs-built_in">object</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; value !== <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">object</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(x)) &#123;<br>    <span class="hljs-comment">// ....</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// .....</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h3><h5 id="3-1-函数的定义"><a href="#3-1-函数的定义" class="headerlink" title="3.1 函数的定义"></a>3.1 函数的定义</h5><p>可以指定参数的类型和返回值的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>, name);<br>&#125;<br><span class="hljs-title function_">hello</span>(<span class="hljs-string">&quot;hahaha&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="3-2-函数表达式"><a href="#3-2-函数表达式" class="headerlink" title="3.2 函数表达式"></a>3.2 函数表达式</h5><p>定义函数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">SumFunc</span> = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">countNumber</span>: <span class="hljs-title class_">SumFunc</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="3-3-可选参数"><a href="#3-3-可选参数" class="headerlink" title="3.3 可选参数"></a>3.3 可选参数</h5><p>在 TS 中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是<strong>最后一个参数</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">print</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age);<br>&#125;<br><span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;hahaha&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="3-4-默认参数"><a href="#3-4-默认参数" class="headerlink" title="3.4 默认参数"></a>3.4 默认参数</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url: <span class="hljs-built_in">string</span>, method: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;GET&quot;</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url, method);<br>&#125;<br><span class="hljs-title function_">ajax</span>(<span class="hljs-string">&quot;/users&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="3-5-剩余参数"><a href="#3-5-剩余参数" class="headerlink" title="3.5 剩余参数"></a>3.5 剩余参数</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...numbers: <span class="hljs-built_in">number</span>[]</span>) &#123;<br>  <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">val, item</span>) =&gt;</span> (val += item), <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><h5 id="3-6-函数重载"><a href="#3-6-函数重载" class="headerlink" title="3.6 函数重载"></a>3.6 函数重载</h5><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。 在 TypeScript 中，表现为给同一个函数提供多个函数类型定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-built_in">any</span> = &#123;&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">attr</span>(<span class="hljs-params">val: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">attr</span>(<span class="hljs-params">val: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">attr</span>(<span class="hljs-params">val: <span class="hljs-built_in">any</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    obj.<span class="hljs-property">name</span> = val;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    obj.<span class="hljs-property">age</span> = val;<br>  &#125;<br>&#125;<br><span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;hahaha&quot;</span>);<br><span class="hljs-title function_">attr</span>(<span class="hljs-number">9</span>);<br><span class="hljs-title function_">attr</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<br></code></pre></td></tr></table></figure><blockquote><p>注意：函数重载真正执行的是同名函数最后定义的函数体 在最后一个函数体定义之前全都属于函数类型定义 不能写具体的函数实现方法 只能定义类型</p></blockquote><h3 id="4-类"><a href="#4-类" class="headerlink" title="4 类"></a>4 类</h3><h5 id="4-1-类的定义"><a href="#4-1-类的定义" class="headerlink" title="4.1 类的定义"></a>4.1 类的定义</h5><p>在 TypeScript 中，我们可以通过 <code>Class</code> 关键字来定义一个类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  name!: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//如果初始属性没赋值就需要加上!</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">_name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = _name;<br>  &#125;<br>  <span class="hljs-title function_">getName</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>p1.<span class="hljs-title function_">getName</span>();<br></code></pre></td></tr></table></figure><p>当然 如果我们图省事 我们也可以把属性定义直接写到构造函数的参数里面去(不过一般不建议这样写 因为会让代码增加阅读难度)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>  <span class="hljs-title function_">getName</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>p1.<span class="hljs-title function_">getName</span>();<br></code></pre></td></tr></table></figure><blockquote><p>注意：当我们定义一个类的时候,会得到 <strong>2 个类型</strong> 一个是构造函数类型的函数类型(当做普通构造函数的类型) 另一个是类的实例类型（代表实例）</p></blockquote><p>具体看例子</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-attr">myName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;静态名称属性&quot;</span>;<br>  <span class="hljs-attr">myName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;实例名称属性&quot;</span>;<br>&#125;<br><span class="hljs-comment">//ts 一个类型 一个叫值</span><br><span class="hljs-comment">//放在=后面的是值</span><br><span class="hljs-keyword">let</span> com = <span class="hljs-title class_">Component</span>; <span class="hljs-comment">//这里是代表构造函数</span><br><span class="hljs-comment">//冒号后面的是类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Component</span>(); <span class="hljs-comment">//这里是代表实例类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">f</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Component</span> = com;<br></code></pre></td></tr></table></figure><h5 id="4-2-存取器"><a href="#4-2-存取器" class="headerlink" title="4.2 存取器"></a>4.2 存取器</h5><p>在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">myname</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">myname: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myname</span> = myname;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">myname</span>;<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myname</span> = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>user.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><p>其实我们可以看看翻译成 es5 的代码 原理很简单 就是使用了 Object.defineProperty 在类的原型上面拦截了属性对应的 get 和 set 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">User</span> = <span class="hljs-comment">/** <span class="hljs-doctag">@class</span> */</span> (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">myname</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myname</span> = myname;<br>  &#125;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">myname</span>;<br>    &#125;,<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">myname</span> = value;<br>    &#125;,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">User</span>;<br>&#125;)();<br><span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>user.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><h5 id="4-3-readonly-只读属性"><a href="#4-3-readonly-只读属性" class="headerlink" title="4.3 readonly 只读属性"></a>4.3 readonly 只读属性</h5><p>readonly 修饰的变量只能在<strong>构造函数</strong>中初始化 TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly readonly 实际上只是在编译阶段进行代码检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <span class="hljs-title function_">changeName</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">//这个ts是报错的</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="4-4-继承"><a href="#4-4-继承" class="headerlink" title="4.4 继承"></a>4.4 继承</h5><p>子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性</p><p>将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑</p><p>super 可以调用父类上的方法和属性</p><p>在 TypeScript 中，我们可以通过 extends 关键字来实现继承</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//定义实例的属性，默认省略public修饰符</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-title function_">getName</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>  <span class="hljs-title function_">setName</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-attr">no</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>, no: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">no</span> = no;<br>  &#125;<br>  <span class="hljs-title function_">getNo</span>(): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">no</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1);<br></code></pre></td></tr></table></figure><h5 id="4-5-类里面的修饰符"><a href="#4-5-类里面的修饰符" class="headerlink" title="4.5 类里面的修饰符"></a>4.5 类里面的修饰符</h5><p><strong>public</strong> 类里面 子类 其它任何地方外边都可以访问 <strong>protected</strong> 类里面 子类 都可以访问,其它任何地方不能访问 <strong>private</strong> 类里面可以访问，子类和其它任何地方都不可以访问</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">car</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>, car: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span> = car;<br>  &#125;<br>  <span class="hljs-title function_">getName</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>  <span class="hljs-title function_">setName</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>, car: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age, car);<br>  &#125;<br>  <span class="hljs-title function_">desc</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.car&#125;</span>`</span>); <span class="hljs-comment">//car访问不到 会报错</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">age</span>); <span class="hljs-comment">//age访问不到 会报错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">car</span>); <span class="hljs-comment">//car访问不到 会报错</span><br></code></pre></td></tr></table></figure><h5 id="4-6-静态属性-静态方法"><a href="#4-6-静态属性-静态方法" class="headerlink" title="4.6 静态属性 静态方法"></a>4.6 静态属性 静态方法</h5><p>类的静态属性和方法是直接定义在类本身上面的 所以也只能通过直接调用类的方法和属性来访问</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-keyword">static</span> mainName = <span class="hljs-string">&quot;Parent&quot;</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getmainName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//注意静态方法里面的this指向的是类本身 而不是类的实例对象 所以静态方法里面只能访问类的静态属性和方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">mainName</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property">mainName</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">getmainName</span>());<br></code></pre></td></tr></table></figure><h5 id="4-7-抽象类和抽象方法"><a href="#4-7-抽象类和抽象方法" class="headerlink" title="4.7 抽象类和抽象方法"></a>4.7 抽象类和抽象方法</h5><p>抽象类，无法被实例化，只能被继承并且无法创建抽象类的实例 子类可以对抽象类进行不同的实现</p><p>抽象方法只能出现在抽象类中并且抽象方法不能在抽象类中被具体实现，只能在抽象类的子类中实现（必须要实现）</p><p>使用场景： 我们一般用抽象类和抽象方法抽离出事物的共性 以后所有继承的子类必须按照规范去实现自己的具体逻辑 这样可以增加代码的可维护性和复用性</p><p>使用 <code>abstract</code> 关键字来定义抽象类和抽象方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  name!: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;喵喵喵&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">//直接报错 无法创建抽象类的实例</span><br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>cat.<span class="hljs-title function_">speak</span>();<br></code></pre></td></tr></table></figure><blockquote><p>思考 1:重写(override)和重载(overload)的区别</p></blockquote><p><strong>重写</strong>是指子类重写继承自父类中的方法 <strong>重载</strong>是指为同一个函数提供多个类型定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-attr">word</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;动物:&quot;</span> + word;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-attr">word</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;猫:&quot;</span> + word;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat.<span class="hljs-title function_">speak</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br><span class="hljs-comment">// 上面是重写</span><br><span class="hljs-comment">//--------------------------------------------</span><br><span class="hljs-comment">// 下面是重载</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">val: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">val: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">val: <span class="hljs-built_in">any</span></span>): <span class="hljs-built_in">any</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val == <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> val * <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> val + val;<br>&#125;<br><br><span class="hljs-keyword">let</span> r = <span class="hljs-title function_">double</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r);<br></code></pre></td></tr></table></figure><blockquote><p>思考 2:什么是<strong>多态</strong></p></blockquote><p>在父类中定义一个方法，在子类中有多个实现，在程序运行的时候，根据不同的对象执行不同的操作，实现运行时的绑定。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-comment">// 声明抽象的方法，让子类去实现</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">sleep</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;dog sleep&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;cat sleep&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-attr">animals</span>: <span class="hljs-title class_">Animal</span>[] = [dog, cat];<br>animals.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> &#123;<br>  i.<span class="hljs-title function_">sleep</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="5-接口"><a href="#5-接口" class="headerlink" title="5 接口"></a>5 接口</h3><p>接口既可以在面向对象编程中表示为行为的抽象，也可以用来描述对象的形状</p><p>我们用 <code>interface</code> 关键字来定义接口 在接口中可以用分号或者逗号分割每一项，也可以什么都不加</p><h5 id="5-1-对象的形状"><a href="#5-1-对象的形状" class="headerlink" title="5.1 对象的形状"></a>5.1 对象的形状</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//接口可以用来描述`对象的形状`</span><br><span class="hljs-comment">//接口可以用来描述`对象的形状`</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Speakable</span> &#123;<br>  <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">lng</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//readonly表示只读属性 后续不可以更改</span><br>  name?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//？表示可选属性</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">speakman</span>: <span class="hljs-title class_">Speakable</span> = &#123;<br>  <span class="hljs-comment">//   speak() &#123;&#125;, //少属性会报错</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>  <span class="hljs-attr">lng</span>: <span class="hljs-string">&quot;en&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">111</span>, <span class="hljs-comment">//多属性也会报错</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="5-2-行为的抽象"><a href="#5-2-行为的抽象" class="headerlink" title="5.2 行为的抽象"></a>5.2 行为的抽象</h5><p>接口可以把一些类中共有的属性和方法抽象出来,可以用来约束实现此接口的类</p><p>一个类可以实现多个接口，一个接口也可以被多个类实现</p><p>我们用 <code>implements</code>关键字来代表 实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//接口可以在面向对象编程中表示为行为的抽象</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Speakable</span> &#123;<br>  <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Eatable</span> &#123;<br>  <span class="hljs-title function_">eat</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-comment">//一个类可以实现多个接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Speakable</span>, <span class="hljs-title class_">Eatable</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Person说话&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//   eat() &#123;&#125; //需要实现的接口包含eat方法 不实现会报错</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-3-定义任意属性"><a href="#5-3-定义任意属性" class="headerlink" title="5.3 定义任意属性"></a>5.3 定义任意属性</h5><p>如果我们在定义接口的时候无法预先知道有哪些属性的时候,可以使用 <code>[propName:string]:any</code>,propName 名字是任意的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个接口表示 必须要有 id 和 name 这两个字段 然后还可以新加其余的未知字段</p><h5 id="5-4-接口的继承"><a href="#5-4-接口的继承" class="headerlink" title="5.4 接口的继承"></a>5.4 接口的继承</h5><p>我们除了类可以继承 接口也可以继承 同样的使用 <code>extends</code>关键字</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Speakable</span> &#123;<br>  <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SpeakChinese</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Speakable</span> &#123;<br>  <span class="hljs-title function_">speakChinese</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SpeakChinese</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Person&quot;</span>);<br>  &#125;<br>  <span class="hljs-title function_">speakChinese</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;speakChinese&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-5-函数类型接口"><a href="#5-5-函数类型接口" class="headerlink" title="5.5 函数类型接口"></a>5.5 函数类型接口</h5><p>可以用接口来定义函数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> discount &#123;<br>  (<span class="hljs-attr">price</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">cost</span>: discount = <span class="hljs-keyword">function</span> (<span class="hljs-params">price: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.8</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="5-6-构造函数的类型接口"><a href="#5-6-构造函数的类型接口" class="headerlink" title="5.6 构造函数的类型接口"></a>5.6 构造函数的类型接口</h5><p>使用特殊的 new()关键字来描述类的构造函数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>&#125;<br><span class="hljs-comment">//不加new是修饰函数的,加new是修饰类的</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">WithNameClass</span> &#123;<br>  <span class="hljs-keyword">new</span> (<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Animal</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAnimal</span>(<span class="hljs-params">clazz: WithNameClass, name: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">clazz</span>(name);<br>&#125;<br><span class="hljs-keyword">let</span> a = <span class="hljs-title function_">createAnimal</span>(<span class="hljs-title class_">Animal</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><p>其实这样的用法一般出现在 当我们需要把一个类作为参数的时候 我们需要对传入的类的构造函数类型进行约束 所以需要使用 new 关键字代表是类的构造函数类型 用以和普通函数进行区分</p><hr><blockquote><p>思考：接口和类型别名的区别 这个题目是经典的 <strong>ts 面试题</strong></p></blockquote><p>实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。</p><p>1.基础数据类型 与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// primitive</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = <span class="hljs-built_in">string</span>;<br><br><span class="hljs-comment">// union</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPoint</span> = <span class="hljs-title class_">PartialPointX</span> | <span class="hljs-title class_">PartialPointY</span>;<br><br><span class="hljs-comment">// tuple</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Data</span> = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>];<br><br><span class="hljs-comment">// dom</span><br><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">type</span> B = <span class="hljs-keyword">typeof</span> div;<br></code></pre></td></tr></table></figure><p>2.重复定义</p><p>接口可以定义多次 会被自动合并为单个接口 类型别名不可以重复定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br></code></pre></td></tr></table></figure><p>3.扩展 接口可以扩展类型别名，同理，类型别名也可以扩展接口。但是两者实现扩展的方式不同</p><p>接口的扩展就是继承，通过 extends 来实现。类型别名的扩展就是交叉类型，通过 &amp; 来实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 接口扩展接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PointX</span> &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PointX</span> &#123;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">// ----</span><br><span class="hljs-comment">// 类型别名扩展类型别名</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PointX</span> = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PointX</span> &amp; &#123;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br><span class="hljs-comment">// ----</span><br><span class="hljs-comment">// 接口扩展类型别名</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PointX</span> = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PointX</span> &#123;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">// ----</span><br><span class="hljs-comment">// 类型别名扩展接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PointX</span> &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PointX</span> &amp; &#123;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>4.实现 这里有一个特殊情况 类无法实现定义了联合类型的类型别名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPoint</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> &#125; | &#123; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> &#125;;<br><br><span class="hljs-comment">// A class can only implement an object type or</span><br><span class="hljs-comment">// intersection of object types with statically known members.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePartialPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PartialPoint</span> &#123;<br>  <span class="hljs-comment">// Error</span><br>  x = <span class="hljs-number">1</span>;<br>  y = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6 泛型"></a>6 泛型</h3><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p><p>为了更好的了解泛型的作用 我们可以看下面的一个例子</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createArray</span>(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: <span class="hljs-built_in">any</span></span>): <span class="hljs-built_in">any</span>[] &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    result[i] = value;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-title function_">createArray</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;x&quot;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></code></pre></td></tr></table></figure><p>上述这段代码用来生成一个长度为 length 值为 value 的数组 但是我们其实可以发现一个问题 不管我们传入什么类型的 value 返回值的数组永远是 any 类型 如果我们想要的效果是 我们预先不知道会传入什么类型 但是我们希望不管我们传入什么类型 我们的返回的数组的指里面的类型应该和参数保持一致 那么这时候 泛型就登场了</p><p>使用<strong>泛型</strong>改造</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> createArray&lt;T&gt;(<span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">value</span>: T): <span class="hljs-title class_">Array</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: T[] = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    result[i] = value;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;x&quot;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></code></pre></td></tr></table></figure><p>我们可以使用&lt;&gt;的写法 然后再面传入一个变量 T 用来表示后续函数需要用到的类型 当我们真正去调用函数的时候再传入 T 的类型就可以解决很多预先无法确定类型相关的问题</p><h5 id="6-1-多个类型参数"><a href="#6-1-多个类型参数" class="headerlink" title="6.1 多个类型参数"></a>6.1 多个类型参数</h5><p>如果我们需要有多个未知的类型占位 那么我们可以定义任何的字母来表示不同的类型参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> swap&lt;T, U&gt;(<span class="hljs-attr">tuple</span>: [T, U]): [U, T] &#123;<br>  <span class="hljs-keyword">return</span> [tuple[<span class="hljs-number">1</span>], tuple[<span class="hljs-number">0</span>]];<br>&#125;<br><br><span class="hljs-title function_">swap</span>([<span class="hljs-number">7</span>, <span class="hljs-string">&quot;seven&quot;</span>]); <span class="hljs-comment">// [&#x27;seven&#x27;, 7]</span><br></code></pre></td></tr></table></figure><h5 id="6-2-泛型约束"><a href="#6-2-泛型约束" class="headerlink" title="6.2 泛型约束"></a>6.2 泛型约束</h5><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> loggingIdentity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-comment">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.</span><br></code></pre></td></tr></table></figure><p>上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。</p><p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是<strong>泛型约束</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lengthwise</span> &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Lengthwise</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：我们在泛型里面使用 <code>extends</code>关键字代表的是泛型约束 需要和类的继承区分开</p></blockquote><h5 id="6-3-泛型接口"><a href="#6-3-泛型接口" class="headerlink" title="6.3 泛型接口"></a>6.3 泛型接口</h5><p>定义接口的时候也可以指定泛型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cart</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">list</span>: T[];<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">cart</span>: <span class="hljs-title class_">Cart</span>&lt;&#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">price</span>: <span class="hljs-built_in">number</span> &#125;&gt; = &#123;<br>  <span class="hljs-attr">list</span>: [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">10</span> &#125;],<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cart.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>, cart.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>].<span class="hljs-property">price</span>);<br></code></pre></td></tr></table></figure><p>我们定义了接口传入的类型 T 之后返回的对象数组里面 T 就是当时传入的参数类型</p><h5 id="6-4-泛型类"><a href="#6-4-泛型类" class="headerlink" title="6.4 泛型类"></a>6.4 泛型类</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">list</span>: T[] = [];<br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">value: T</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(value);<br>  &#125;<br>  <span class="hljs-title function_">getMax</span>(): T &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[i] &gt; result) &#123;<br>        result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[i];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>();<br>arr.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>arr.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> ret = arr.<span class="hljs-title function_">getMax</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);<br></code></pre></td></tr></table></figure><p>上诉例子我们实现了一个在数组里面添加数字并且获取最大值的泛型类</p><h5 id="6-5-泛型类型别名"><a href="#6-5-泛型类型别名" class="headerlink" title="6.5 泛型类型别名"></a>6.5 泛型类型别名</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Cart</span>&lt;T&gt; = &#123; <span class="hljs-attr">list</span>: T[] &#125; | T[];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c1</span>: <span class="hljs-title class_">Cart</span>&lt;<span class="hljs-built_in">string</span>&gt; = &#123; <span class="hljs-attr">list</span>: [<span class="hljs-string">&quot;1&quot;</span>] &#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c2</span>: <span class="hljs-title class_">Cart</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h5 id="6-6-泛型参数的默认类型"><a href="#6-6-泛型参数的默认类型" class="headerlink" title="6.6 泛型参数的默认类型"></a>6.6 泛型参数的默认类型</h5><p>我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> createArray&lt;T = <span class="hljs-built_in">string</span>&gt;(<span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">value</span>: T): <span class="hljs-title class_">Array</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: T[] = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    result[i] = value;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-实用技巧"><a href="#7-实用技巧" class="headerlink" title="7 实用技巧"></a>7 实用技巧</h3><h5 id="7-1-typeof-关键词"><a href="#7-1-typeof-关键词" class="headerlink" title="7.1 typeof 关键词"></a>7.1 typeof 关键词</h5><p><code>typeof</code> 关键词除了做类型保护 还可以从实现推出类型，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//先定义变量，再定义类型</span><br><span class="hljs-keyword">let</span> p1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span>,<br>&#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">People</span> = <span class="hljs-keyword">typeof</span> p1;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">p: People</span>): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">return</span> p.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-title function_">getName</span>(p1);<br></code></pre></td></tr></table></figure><p>上面的例子就是使用 typeof 获取一个变量的类型</p><h5 id="7-2-keyof-关键词"><a href="#7-2-keyof-关键词" class="headerlink" title="7.2 keyof 关键词"></a>7.2 keyof 关键词</h5><p><code>keyof</code> 可以用来取得一个对象接口的所有 key 值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span> | <span class="hljs-string">&quot;female&quot;</span>;<br>&#125;<br><span class="hljs-comment">//type PersonKey = &#x27;name&#x27;|&#x27;age&#x27;|&#x27;gender&#x27;;</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonKey</span> = keyof <span class="hljs-title class_">Person</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getValueByKey</span>(<span class="hljs-params">p: Person, key: PersonKey</span>) &#123;<br>  <span class="hljs-keyword">return</span> p[key];<br>&#125;<br><span class="hljs-keyword">let</span> val = <span class="hljs-title function_">getValueByKey</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span> &#125;, <span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<br></code></pre></td></tr></table></figure><h5 id="7-3-索引访问操作符"><a href="#7-3-索引访问操作符" class="headerlink" title="7.3 索引访问操作符"></a>7.3 索引访问操作符</h5><p>使用 [] 操作符可以进行索引访问</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> x = <span class="hljs-title class_">Person</span>[<span class="hljs-string">&quot;name&quot;</span>]; <span class="hljs-comment">// x is string</span><br></code></pre></td></tr></table></figure><h5 id="7-4-映射类型-in"><a href="#7-4-映射类型-in" class="headerlink" title="7.4 映射类型 in"></a>7.4 映射类型 in</h5><p>在定义的时候用 in 操作符去批量定义类型中的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span> | <span class="hljs-string">&quot;female&quot;</span>;<br>&#125;<br><span class="hljs-comment">//批量把一个接口中的属性都变成可选的</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartPerson</span> = &#123;<br>  [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Person</span>]?: <span class="hljs-title class_">Person</span>[<span class="hljs-title class_">Key</span>];<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">p1</span>: <span class="hljs-title class_">PartPerson</span> = &#123;&#125;;<br></code></pre></td></tr></table></figure><h5 id="7-5-infer-关键字"><a href="#7-5-infer-关键字" class="headerlink" title="7.5 infer 关键字"></a>7.5 infer 关键字</h5><p>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;<br></code></pre></td></tr></table></figure><p>以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><h5 id="7-6-内置工具类型"><a href="#7-6-内置工具类型" class="headerlink" title="7.6 内置工具类型"></a>7.6 内置工具类型</h5><ol><li>Exclude&lt;T,U&gt; 从 T 可分配给的类型中排除 U</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Exclude</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? <span class="hljs-built_in">never</span> : T;<br><br><span class="hljs-keyword">type</span> E = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">e</span>: E = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ol><li>Extract&lt;T,U&gt; 从 T 可分配给的类型中提取 U</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Extract</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? T : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">type</span> E = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">e</span>: E = <span class="hljs-string">&quot;1&quot;</span>;<br></code></pre></td></tr></table></figure><ol><li>NonNullable 从 T 中排除 <code>null</code> 和 <code>undefined</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">NonNullable</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">never</span> : T;<br><br><span class="hljs-keyword">type</span> E = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>&gt;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">e</span>: E = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><ol><li>ReturnType <code>infer</code> 最早出现在此 PR 中，表示在 <code>extends</code> 条件语句中待推断的类型变量</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> (<br>  ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]<br>) =&gt; infer R<br>  ? R<br>  : <span class="hljs-built_in">any</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInfo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;;<br>&#125;<br><br><span class="hljs-comment">// 通过 ReturnType 将 getUserInfo 的返回值类型赋给了 UserInfo</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">UserInfo</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> getUserInfo&gt;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">userA</span>: <span class="hljs-title class_">UserInfo</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见 该工具类型主要是获取函数类型的返回类型</p><ol><li>Parameters 该工具类型主要是获取函数类型的参数类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameters</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: infer R) =&gt; <span class="hljs-built_in">any</span> ? R : <span class="hljs-built_in">any</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// []</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;; <span class="hljs-comment">// [string]</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Parameters</span>&lt;&lt;T&gt;<span class="hljs-function">(<span class="hljs-params">arg: T</span>) =&gt;</span> T&gt;; <span class="hljs-comment">// [unknown]</span><br></code></pre></td></tr></table></figure><ol><li>Partial Partial 可以将传入的属性由非可选变为可选</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = &#123; [P <span class="hljs-keyword">in</span> keyof T]?: T[P] &#125;;<br><span class="hljs-keyword">interface</span> A &#123;<br>  <span class="hljs-attr">a1</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">a2</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">a3</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-keyword">type</span> aPartial = <span class="hljs-title class_">Partial</span>&lt;A&gt;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: aPartial = &#123;&#125;; <span class="hljs-comment">// 不会报错</span><br></code></pre></td></tr></table></figure><ol><li>Required Required 可以将传入的属性中的可选项变为必选项，这里用了 -? 修饰符来实现。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  gender?: <span class="hljs-string">&quot;male&quot;</span> | <span class="hljs-string">&quot;female&quot;</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Required</span>&lt;<span class="hljs-title class_">Person</span>&gt; = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>Readonly Readonly 通过为传入的属性每一项都加上 readonly 修饰符来实现。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  gender?: <span class="hljs-string">&quot;male&quot;</span> | <span class="hljs-string">&quot;female&quot;</span>;<br>&#125;<br><span class="hljs-comment">//type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-title class_">Person</span>&gt; = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span>,<br>&#125;;<br>p.<span class="hljs-property">age</span> = <span class="hljs-number">11</span>; <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><ol><li>Pick&lt;T,K&gt; Pick 能够帮助我们从传入的属性中摘取某些返回</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">done</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * From T pick a set of properties K</span><br><span class="hljs-comment"> * type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P] &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoBase</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">Todo</span>, <span class="hljs-string">&quot;title&quot;</span> | <span class="hljs-string">&quot;done&quot;</span>&gt;;<br><br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoBase</span> = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">done</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>Record&lt;K,T&gt; 构造一个类型，该类型具有一组属性 K，每个属性的类型为 T。可用于将一个类型的属性映射为另一个类型。Record 后面的泛型就是对象键和值的类型。</li></ol><p>简单理解：K 对应对应的 key，T 对应对象的 value，返回的就是一个声明好的对象 但是 K 对应的泛型约束是 <code>keyof any</code> 也就意味着只能传入 <code>string|number|symbol</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// type Record&lt;K extends keyof any, T&gt; = &#123;</span><br><span class="hljs-comment">// [P in K]: T;</span><br><span class="hljs-comment">// &#125;;</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-string">&quot;x&quot;</span> | <span class="hljs-string">&quot;y&quot;</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PointList</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Point</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span> &#125;&gt;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">cars</span>: <span class="hljs-title class_">PointList</span> = &#123;<br>  <span class="hljs-attr">x</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">10</span> &#125;,<br>  <span class="hljs-attr">y</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">20</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>Omit&lt;K,T&gt; 基于已经声明的类型进行属性剔除获得新类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// type Omit=Pick&lt;T,Exclude&lt;keyof T,K&gt;&gt;</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br><span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;<br>&#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">UserWithoutEmail</span> = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&quot;email&quot;</span>&gt;;<span class="hljs-comment">// UserWithoutEmail =&#123;id: string;name: string;&#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-TypeScript-装饰器"><a href="#8-TypeScript-装饰器" class="headerlink" title="8 TypeScript 装饰器"></a>8 TypeScript 装饰器</h3><p>装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为</p><p>常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器</p><p>装饰器的写法分为普通装饰器和装饰器工厂</p><p>使用@装饰器的写法需要把 tsconfig.json 的 <code>experimentalDecorators</code> 字段设置为 true</p><h5 id="8-1-类装饰器"><a href="#8-1-类装饰器" class="headerlink" title="8.1 类装饰器"></a>8.1 类装饰器</h5><p>类装饰器在类声明之前声明，用来监视、修改或替换类定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">namespace</span> a &#123;<br>  <span class="hljs-comment">//当装饰器作为修饰类的时候，会把构造器传递进去</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addNameEat</span>(<span class="hljs-params">constructor: <span class="hljs-built_in">Function</span></span>) &#123;<br>    constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>    constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eat&quot;</span>);<br>    &#125;;<br>  &#125;<br>  <span class="hljs-meta">@addNameEat</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    name!: <span class="hljs-built_in">string</span>;<br>    eat!: <span class="hljs-title class_">Function</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  &#125;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);<br>  p.<span class="hljs-title function_">eat</span>();<br>&#125;<br><br><span class="hljs-keyword">namespace</span> b &#123;<br>  <span class="hljs-comment">//还可以使用装饰器工厂 这样可以传递额外参数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addNameEatFactory</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">constructor: <span class="hljs-built_in">Function</span></span>) &#123;<br>      constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = name;<br>      constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eat&quot;</span>);<br>      &#125;;<br>    &#125;;<br>  &#125;<br>  <span class="hljs-meta">@addNameEatFactory</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    name!: <span class="hljs-built_in">string</span>;<br>    eat!: <span class="hljs-title class_">Function</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  &#125;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);<br>  p.<span class="hljs-title function_">eat</span>();<br>&#125;<br><br><span class="hljs-keyword">namespace</span> c &#123;<br>  <span class="hljs-comment">//还可以替换类,不过替换的类要与原类结构相同</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">enhancer</span>(<span class="hljs-params">constructor: <span class="hljs-built_in">Function</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;jiagou&quot;</span>;<br>      <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;吃饭饭&quot;</span>);<br>      &#125;<br>    &#125;;<br>  &#125;<br>  <span class="hljs-meta">@enhancer</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    name!: <span class="hljs-built_in">string</span>;<br>    eat!: <span class="hljs-title class_">Function</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  &#125;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);<br>  p.<span class="hljs-title function_">eat</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8-2-属性装饰器"><a href="#8-2-属性装饰器" class="headerlink" title="8.2 属性装饰器"></a>8.2 属性装饰器</h5><p>属性装饰器表达式会在运行时当作函数被调用，传入 2 个参数 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 第二个参数是属性的名称</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//修饰实例属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">upperCase</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">let</span> value = target[propertyKey];<br>  <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;;<br>  <span class="hljs-comment">// 用来替换的setter</span><br>  <span class="hljs-keyword">const</span> setter = <span class="hljs-keyword">function</span> (<span class="hljs-params">newVal: <span class="hljs-built_in">string</span></span>) &#123;<br>    value = newVal.<span class="hljs-title function_">toUpperCase</span>();<br>  &#125;;<br>  <span class="hljs-comment">// 替换属性，先删除原先的属性，再重新定义属性</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">delete</span> target[propertyKey]) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, propertyKey, &#123;<br>      <span class="hljs-attr">get</span>: getter,<br>      <span class="hljs-attr">set</span>: setter,<br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@upperCase</span><br>  name!: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><h5 id="8-3-方法装饰器"><a href="#8-3-方法装饰器" class="headerlink" title="8.3 方法装饰器"></a>8.3 方法装饰器</h5><p>方法装饰器顾名思义，用来装饰类的方法。它接收三个参数： target: Object - 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 propertyKey: string | symbol - 方法名 descriptor: TypePropertyDescript - 属性描述符</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//修饰实例方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">noEnumerable</span>(<span class="hljs-params"></span><br><span class="hljs-params">  target: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">  property: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  descriptor: PropertyDescriptor</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;target.getName&quot;</span>, target.<span class="hljs-property">getName</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;target.getAge&quot;</span>, target.<span class="hljs-property">getAge</span>);<br>  descriptor.<span class="hljs-property">enumerable</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//重写方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toNumber</span>(<span class="hljs-params"></span><br><span class="hljs-params">  target: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">  methodName: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  descriptor: PropertyDescriptor</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> oldMethod = descriptor.<span class="hljs-property">value</span>;<br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    args = args.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-built_in">parseFloat</span>(item));<br>    <span class="hljs-keyword">return</span> oldMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-meta">@noEnumerable</span><br>  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>  <span class="hljs-meta">@toNumber</span><br>  <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accu: <span class="hljs-built_in">number</span>, item: <span class="hljs-built_in">number</span></span>) =&gt;</span> accu + item, <span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> attr <span class="hljs-keyword">in</span> p) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;attr=&quot;</span>, attr);<br>&#125;<br>p.<span class="hljs-title function_">getName</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">sum</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>));<br></code></pre></td></tr></table></figure><h5 id="8-4-参数装饰器"><a href="#8-4-参数装饰器" class="headerlink" title="8.4 参数装饰器"></a>8.4 参数装饰器</h5><p>参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：</p><p>target: Object - 被装饰的类 propertyKey: string | symbol - 方法名 parameterIndex: number - 方法中参数的索引值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Log</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span>, key: <span class="hljs-built_in">string</span>, parameterIndex: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">let</span> functionLogged = key || target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The parameter in position <span class="hljs-subst">$&#123;parameterIndex&#125;</span> at <span class="hljs-subst">$&#123;functionLogged&#125;</span> has</span><br><span class="hljs-string">been decorated`</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Log</span> phrase: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = phrase;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码成功运行后，控制台会输出以下结果： <code>&quot;The parameter in position 0 at Greeter has been decorated&quot; </code></p><h5 id="8-5-装饰器执行顺序"><a href="#8-5-装饰器执行顺序" class="headerlink" title="8.5 装饰器执行顺序"></a>8.5 装饰器执行顺序</h5><p>有多个参数装饰器时：从最后一个参数依次向前执行</p><p>方法和方法参数中参数装饰器先执行。 方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行</p><p>类装饰器总是最后执行</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Class1Decorator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target: <span class="hljs-built_in">any</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;类1装饰器&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Class2Decorator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target: <span class="hljs-built_in">any</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;类2装饰器&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MethodDecorator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">    target: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">    methodName: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    descriptor: PropertyDescriptor</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;方法装饰器&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Param1Decorator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target: <span class="hljs-built_in">any</span>, methodName: <span class="hljs-built_in">string</span>, paramIndex: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;参数1装饰器&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Param2Decorator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target: <span class="hljs-built_in">any</span>, methodName: <span class="hljs-built_in">string</span>, paramIndex: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;参数2装饰器&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PropertyDecorator</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyName: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name + <span class="hljs-string">&quot;属性装饰器&quot;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@Class1Decorator</span>()<br><span class="hljs-meta">@Class2Decorator</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@PropertyDecorator</span>(<span class="hljs-string">&quot;name&quot;</span>)<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>  <span class="hljs-meta">@PropertyDecorator</span>(<span class="hljs-string">&quot;age&quot;</span>)<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>;<br>  <span class="hljs-meta">@MethodDecorator</span>()<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-meta">@Param1Decorator</span>() p1: <span class="hljs-built_in">string</span>, <span class="hljs-meta">@Param2Decorator</span>() p2: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">name属性装饰器</span><br><span class="hljs-comment">age属性装饰器</span><br><span class="hljs-comment">参数2装饰器</span><br><span class="hljs-comment">参数1装饰器</span><br><span class="hljs-comment">方法装饰器</span><br><span class="hljs-comment">类2装饰器</span><br><span class="hljs-comment">类1装饰器</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="9-编译"><a href="#9-编译" class="headerlink" title="9 编译"></a>9 编译</h3><h5 id="9-1-tsconfig-json-的作用"><a href="#9-1-tsconfig-json-的作用" class="headerlink" title="9.1 tsconfig.json 的作用"></a>9.1 tsconfig.json 的作用</h5><ul><li>用于标识 TypeScript 项目的根路径；</li><li>用于配置 TypeScript 编译器；</li><li>用于指定编译的文件。</li></ul><h5 id="9-2-tsconfig-json-重要字段"><a href="#9-2-tsconfig-json-重要字段" class="headerlink" title="9.2 tsconfig.json 重要字段"></a>9.2 tsconfig.json 重要字段</h5><ul><li>files - 设置要编译的文件的名称；</li><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li><li>compilerOptions - 设置与编译流程相关的选项。</li></ul><h5 id="9-3-compilerOptions-选项"><a href="#9-3-compilerOptions-选项" class="headerlink" title="9.3 compilerOptions 选项"></a>9.3 compilerOptions 选项</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs ts">&#123;<br>  <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br><br>    <span class="hljs-comment">/* 基本选项 */</span><br>    <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,                       <span class="hljs-comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br>    <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,                  <span class="hljs-comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br>    <span class="hljs-string">&quot;lib&quot;</span>: [],                             <span class="hljs-comment">// 指定要包含在编译中的库文件</span><br>    <span class="hljs-string">&quot;allowJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 允许编译 javascript 文件</span><br>    <span class="hljs-string">&quot;checkJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 报告 javascript 文件中的错误</span><br>    <span class="hljs-string">&quot;jsx&quot;</span>: <span class="hljs-string">&quot;preserve&quot;</span>,                     <span class="hljs-comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br>    <span class="hljs-string">&quot;declaration&quot;</span>: <span class="hljs-literal">true</span>,                   <span class="hljs-comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span><br>    <span class="hljs-string">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,                     <span class="hljs-comment">// 生成相应的 &#x27;.map&#x27; 文件</span><br>    <span class="hljs-string">&quot;outFile&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 将输出文件合并为一个文件</span><br>    <span class="hljs-string">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                        <span class="hljs-comment">// 指定输出目录</span><br>    <span class="hljs-string">&quot;rootDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用来控制输出目录结构 --outDir.</span><br>    <span class="hljs-string">&quot;removeComments&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 删除编译后的所有的注释</span><br>    <span class="hljs-string">&quot;noEmit&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 不生成输出文件</span><br>    <span class="hljs-string">&quot;importHelpers&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 从 tslib 导入辅助工具函数</span><br>    <span class="hljs-string">&quot;isolatedModules&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><br>    <span class="hljs-comment">/* 严格的类型检查选项 */</span><br>    <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 启用所有严格类型检查选项</span><br>    <span class="hljs-string">&quot;noImplicitAny&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 在表达式和声明上有隐含的 any类型时报错</span><br>    <span class="hljs-string">&quot;strictNullChecks&quot;</span>: <span class="hljs-literal">true</span>,              <span class="hljs-comment">// 启用严格的 null 检查</span><br>    <span class="hljs-string">&quot;noImplicitThis&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span><br>    <span class="hljs-string">&quot;alwaysStrict&quot;</span>: <span class="hljs-literal">true</span>,                  <span class="hljs-comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><br>    <span class="hljs-comment">/* 额外的检查 */</span><br>    <span class="hljs-string">&quot;noUnusedLocals&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 有未使用的变量时，抛出错误</span><br>    <span class="hljs-string">&quot;noUnusedParameters&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-comment">// 有未使用的参数时，抛出错误</span><br>    <span class="hljs-string">&quot;noImplicitReturns&quot;</span>: <span class="hljs-literal">true</span>,             <span class="hljs-comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span><br>    <span class="hljs-string">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><br>    <span class="hljs-comment">/* 模块解析选项 */</span><br>    <span class="hljs-string">&quot;moduleResolution&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,            <span class="hljs-comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br>    <span class="hljs-string">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用于解析非相对模块名称的基目录</span><br>    <span class="hljs-string">&quot;paths&quot;</span>: &#123;&#125;,                           <span class="hljs-comment">// 模块名到基于 baseUrl 的路径映射的列表</span><br>    <span class="hljs-string">&quot;rootDirs&quot;</span>: [],                        <span class="hljs-comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br>    <span class="hljs-string">&quot;typeRoots&quot;</span>: [],                       <span class="hljs-comment">// 包含类型声明的文件列表</span><br>    <span class="hljs-string">&quot;types&quot;</span>: [],                           <span class="hljs-comment">// 需要包含的类型声明文件名列表</span><br>    <span class="hljs-string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 允许从没有设置默认导出的模块中默认导入。</span><br><br>    <span class="hljs-comment">/* Source Map Options */</span><br>    <span class="hljs-string">&quot;sourceRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                    <span class="hljs-comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br>    <span class="hljs-string">&quot;mapRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span><br>    <span class="hljs-string">&quot;inlineSourceMap&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br>    <span class="hljs-string">&quot;inlineSources&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><br>    <span class="hljs-comment">/* 其他选项 */</span><br>    <span class="hljs-string">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-comment">// 启用装饰器</span><br>    <span class="hljs-string">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span>          <span class="hljs-comment">// 为装饰器提供元数据的支持</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-模块和声明文件"><a href="#10-模块和声明文件" class="headerlink" title="10 模块和声明文件"></a>10 模块和声明文件</h3><h5 id="10-1-全局模块"><a href="#10-1-全局模块" class="headerlink" title="10.1 全局模块"></a>10.1 全局模块</h5><p>在默认情况下，当你开始在一个新的 TypeScript 文件中写下代码时，它处于全局命名空间中</p><p>使用全局变量空间是危险的，因为它会与文件内的代码命名冲突。我们推荐使用下文中将要提到的文件模块</p><p>foo.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> foo = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>bar.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> bar = foo; <span class="hljs-comment">// allowed</span><br></code></pre></td></tr></table></figure><h5 id="10-2-文件模块"><a href="#10-2-文件模块" class="headerlink" title="10.2 文件模块"></a>10.2 文件模块</h5><ul><li>文件模块也被称为外部模块。如果在你的 TypeScript 文件的根级别位置含有 import 或者 export，那么它会在这个文件中创建一个本地的作用域</li><li>模块是 TS 中外部模块的简称，侧重于代码和复用</li><li>模块在其自身的作用域里执行，而不是在全局作用域里</li><li>一个模块里的变量、函数、类等在外部是不可见的，除非你把它导出</li><li>如果想要使用一个模块里导出的变量，则需要导入</li></ul><p>foo.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> foo = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">export</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p>bar.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> bar = foo; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><h5 id="10-3-声明文件"><a href="#10-3-声明文件" class="headerlink" title="10.3 声明文件"></a>10.3 声明文件</h5><ul><li>我们可以把类型声明放在一个单独的类型声明文件中</li><li>文件命名规范为*.d.ts</li><li>查看类型声明文件有助于了解库的使用方式</li></ul><p>typings\jquery.d.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">$</span>: <span class="hljs-function">(<span class="hljs-params">selector: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">click</span>(): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-title function_">width</span>(<span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="10-4-第三方声明文件"><a href="#10-4-第三方声明文件" class="headerlink" title="10.4 第三方声明文件"></a>10.4 第三方声明文件</h5><ul><li>可以安装使用第三方的声明文件</li><li>@types 是一个约定的前缀，所有的第三方声明的类型库都会带有这样的前缀</li><li>JavaScript 中有很多内置对象，它们可以在 TypeScript 中被当做声明好了的类型</li><li>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准</li><li>这些内置对象的类型声明文件，就包含在 TypeScript 核心库的类型声明文件中,具体可以查看<a href="https://link.juejin.cn/?target=https://github.com/Microsoft/TypeScript/tree/main/src/lib">ts 核心声明文件</a></li></ul><h5 id="10-5-查找声明文件"><a href="#10-5-查找声明文件" class="headerlink" title="10.5 查找声明文件"></a>10.5 查找声明文件</h5><ul><li>如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别</li><li>给 package.json 中的 types 或 typings 字段指定一个类型声明文件地址</li><li>在项目根目录下，编写一个 index.d.ts 文件</li><li>针对入口文件（package.json 中的 main 字段指定的入口文件），编写一个同名不同后缀的 .d.ts 文件</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts">&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;myLib&quot;</span>,<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;lib/index.js&quot;</span>,<br>    <span class="hljs-string">&quot;types&quot;</span>: <span class="hljs-string">&quot;myLib.d.ts&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>查找过程如下：</p><p>1.先找 myLib.d.ts</p><p>2.没有就再找 index.d.ts</p><p>3.还没有再找 lib&#x2F;index.d.js</p><p>4.还找不到就认为没有类型声明了</p><p>转载：<a href="https://juejin.cn/post/7031787942691471396#heading-59">最全的TypeScript学习指南</a></p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript介绍</title>
    <link href="./2023/03/08/typeScript%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <url>./2023/03/08/typeScript%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="typescript介绍"><a href="#typescript介绍" class="headerlink" title="typescript介绍"></a>typescript介绍</h1><h2 id="什么是typescript"><a href="#什么是typescript" class="headerlink" title="什么是typescript?"></a>什么是typescript?</h2><blockquote><p>TypeScript简称TS<br>TS和JS之间的关系其实就是Less&#x2F;Sass和CSS之间的关系<br>就像Less&#x2F;Sass是对CSS进行扩展一样, TS也是对JS进行扩展<br>就像Less&#x2F;Sass最终会转换成CSS一样, 我们编写好的TS代码最终也会换成JS<br>TypeScript是JavaScript的超集，因为它扩展了JavaScript，有JavaScript没有的东西。<br>硬要以父子类关系来说的话，TypeScript是JavaScript子类，继承的基础上去扩展。</p></blockquote><h2 id="为什么需要TypeScript"><a href="#为什么需要TypeScript" class="headerlink" title="为什么需要TypeScript?"></a>为什么需要TypeScript?</h2><blockquote><p>简单来说就是因为JavaScript是弱类型, 很多错误只有在运行时才会被发现<br>而TypeScript提供了一套静态检测机制, 可以帮助我们在编译时就发现错误</p></blockquote><h2 id="TypeScript特点"><a href="#TypeScript特点" class="headerlink" title="TypeScript特点"></a>TypeScript特点</h2><blockquote><p>支持最新的JavaScript新特特性<br>支持代码静态检查<br>支持诸如C,C++,Java,Go等后端语言中的特性 (枚举、泛型、类型转换、命名空间、声明文件、类、接口等)</p></blockquote><h1 id="搭建typescript学习环境"><a href="#搭建typescript学习环境" class="headerlink" title="搭建typescript学习环境"></a>搭建typescript学习环境</h1><h2 id="安装最新版typescript"><a href="#安装最新版typescript" class="headerlink" title="安装最新版typescript"></a>安装最新版typescript</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i -g typescript<br></code></pre></td></tr></table></figure><h2 id="安装ts-node"><a href="#安装ts-node" class="headerlink" title="安装ts-node"></a>安装ts-node</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i -g ts-node<br></code></pre></td></tr></table></figure><h2 id="创建一个-tsconfig-json-文件"><a href="#创建一个-tsconfig-json-文件" class="headerlink" title="创建一个 tsconfig.json 文件"></a>创建一个 tsconfig.json 文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">tsc --init<br></code></pre></td></tr></table></figure><p><strong>然后新建index.ts,输入相关练习代码，然后执行 ts-node index.ts</strong></p><h2 id="官方playground"><a href="#官方playground" class="headerlink" title="官方playground"></a>官方playground</h2><p>官方也提供了一个在线开发 TypeScript 的云环境——<a href="https://link.juejin.cn/?target=https://www.typescriptlang.org/zh/play">Playground</a>。</p><p>基于它，我们无须在本地安装环境，只需要一个浏览器即可随时学习和编写 TypeScript，同时还可以方便地选择 TypeScript 版本、配置 tsconfig，并对 TypeScript 实时静态类型检测、转译输出 JavaScript 和在线执行。</p><p>而且在体验上，它也一点儿不逊色于任何本地的 IDE，对于刚刚学习 TypeScript 的我们来说，算是一个不错的选择。</p><h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><h2 id="JS的八种内置类型"><a href="#JS的八种内置类型" class="headerlink" title="JS的八种内置类型"></a>JS的八种内置类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: string = <span class="hljs-string">&quot;jimmy&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: number = <span class="hljs-number">24</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">bool</span>: boolean = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: object = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">big</span>: bigint = <span class="hljs-number">100n</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">sym</span>: symbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;me&quot;</span>); <br></code></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给其他类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// null和undefined赋值给string</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>:string = <span class="hljs-string">&quot;666&quot;</span>;<br>str = <span class="hljs-literal">null</span><br>str= <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// null和undefined赋值给number</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>:number = <span class="hljs-number">666</span>;<br>num = <span class="hljs-literal">null</span><br>num= <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// null和undefined赋值给object</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>:object =&#123;&#125;;<br>obj = <span class="hljs-literal">null</span><br>obj= <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// null和undefined赋值给Symbol</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">sym</span>: symbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;me&quot;</span>); <br>sym = <span class="hljs-literal">null</span><br>sym= <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// null和undefined赋值给boolean</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: boolean = <span class="hljs-literal">false</span>;<br>isDone = <span class="hljs-literal">null</span><br>isDone= <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// null和undefined赋值给bigint</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">big</span>: bigint =  <span class="hljs-number">100n</span>;<br>big = <span class="hljs-literal">null</span><br>big= <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>如果你在tsconfig.json指定了 <code>&quot;strictNullChecks&quot;:true</code> ，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自的类型。</p><h3 id="number和bigint"><a href="#number和bigint" class="headerlink" title="number和bigint"></a>number和bigint</h3><p>虽然 <code>number</code>和 <code>bigint</code>都表示数字，但是这两个类型不兼容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">big</span>: bigint =  <span class="hljs-number">100n</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: number = <span class="hljs-number">6</span>;<br>big = num;<br>num = big;<br></code></pre></td></tr></table></figure><p>会抛出一个类型不兼容的 ts(2322) 错误。</p><h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>对数组类型的定义有两种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:string[] = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>:<span class="hljs-title class_">Array</span>&lt;string&gt; = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>]；<br></code></pre></td></tr></table></figure><p>定义联合类型数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:(number | string)[];<br><span class="hljs-comment">// 表示定义了一个名称叫做arr的数组, </span><br><span class="hljs-comment">// 这个数组中将来既可以存储数值类型的数据, 也可以存储字符串类型的数据</span><br>arr3 = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br></code></pre></td></tr></table></figure><p>定义指定对象成员的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// interface是接口,后面会讲到</span><br>interface <span class="hljs-title class_">Arrobj</span>&#123;<br>    <span class="hljs-attr">name</span>:string,<br>    <span class="hljs-attr">age</span>:number<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr3</span>:<span class="hljs-title class_">Arrobj</span>[]=[&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jimmy&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">22</span>&#125;]<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">x: number, y: number</span>): number &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">mySum</span>: <span class="hljs-function">(<span class="hljs-params">x: number, y: number</span>) =&gt;</span> number = <span class="hljs-keyword">function</span> (<span class="hljs-params">x: number, y: number</span>): number &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="用接口定义函数类型"><a href="#用接口定义函数类型" class="headerlink" title="用接口定义函数类型"></a>用接口定义函数类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">SearchFunc</span>&#123;<br>  (<span class="hljs-attr">source</span>: string, <span class="hljs-attr">subString</span>: string): boolean;<br>&#125;<br></code></pre></td></tr></table></figure><p>采用函数表达式接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: string, lastName?: string</span>) &#123;<br>    <span class="hljs-keyword">if</span> (lastName) &#123;<br>        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> firstName;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> tom = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure><p>注意点：可选参数后面不允许再出现必需参数</p><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: string, lastName: string = <span class="hljs-string">&#x27;Cat&#x27;</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> tom = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">array: any[], ...items: any[]</span>) &#123;<br>    items.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>        array.<span class="hljs-title function_">push</span>(item);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">let</span> a = [];<br><span class="hljs-title function_">push</span>(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>由于 JavaScript 是一个动态语言，我们通常会使用不同类型的参数来调用同一个函数，该函数会根据不同的参数而返回不同的类型的调用结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br> <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">//&quot;12&quot;</span><br></code></pre></td></tr></table></figure><p>由于 TypeScript 是 JavaScript 的超集，因此以上的代码可以直接在 TypeScript 中使用，但当 TypeScript 编译器开启 <code>noImplicitAny</code> 的配置项时，以上代码会提示以下错误信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Parameter</span> <span class="hljs-string">&#x27;x&#x27;</span> implicitly has an <span class="hljs-string">&#x27;any&#x27;</span> type.<br><span class="hljs-title class_">Parameter</span> <span class="hljs-string">&#x27;y&#x27;</span> implicitly has an <span class="hljs-string">&#x27;any&#x27;</span> type.<br></code></pre></td></tr></table></figure><p>该信息告诉我们参数 x 和参数 y 隐式具有 <code>any</code> 类型。为了解决这个问题，我们可以为参数设置一个类型。因为我们希望 <code>add</code> 函数同时支持 string 和 number 类型，因此我们可以定义一个 <code>string | number</code> 联合类型，同时我们为该联合类型取个别名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Combinable</span> = string | number;<br></code></pre></td></tr></table></figure><p>在定义完 Combinable 联合类型后，我们来更新一下 <code>add</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: Combinable, b: Combinable</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>     <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">toString</span>() + b.<span class="hljs-title function_">toString</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>为 <code>add</code> 函数的参数显式设置类型之后，之前错误的提示消息就消失了。那么此时的 <code>add</code> 函数就完美了么，我们来实际测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;Semlinker&#x27;</span>, <span class="hljs-string">&#x27; Kakuqo&#x27;</span>);<br>result.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br></code></pre></td></tr></table></figure><p>在上面代码中，我们分别使用 <code>&#39;Semlinker&#39;</code> 和 <code>&#39; Kakuqo&#39;</code> 这两个字符串作为参数调用 add 函数，并把调用结果保存到一个名为 <code>result</code> 的变量上，这时候我们想当然的认为此时 result 的变量的类型为 string，所以我们就可以正常调用字符串对象上的 <code>split</code> 方法。但这时 TypeScript 编译器又出现以下错误信息了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Property</span> <span class="hljs-string">&#x27;split&#x27;</span> does not exist on type <span class="hljs-string">&#x27;number&#x27;</span>.<br></code></pre></td></tr></table></figure><p>很明显 <code>number</code> 类型的对象上并不存在 <code>split</code> 属性。问题又来了，那如何解决呢？这时我们就可以利用 TypeScript 提供的函数重载特性。</p><blockquote><p><strong>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。</strong> 要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Types</span> = number | string<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a:number,b:number</span>):number;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: string, b: string</span>): string;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: string, b: number</span>): string;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: number, b: string</span>): string;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a:Types, b:Types</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">toString</span>() + b.<span class="hljs-title function_">toString</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;Semlinker&#x27;</span>, <span class="hljs-string">&#x27; Kakuqo&#x27;</span>);<br>result.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br></code></pre></td></tr></table></figure><p>在以上代码中，我们为 add 函数提供了多个函数类型定义，从而实现函数的重载。之后，可恶的错误消息又消失了，因为这时 result 变量的类型是 <code>string</code> 类型。</p><h2 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple(元组)"></a>Tuple(元组)</h2><h3 id="元祖定义"><a href="#元祖定义" class="headerlink" title="元祖定义"></a>元祖定义</h3><p>众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。</p><p>元组最重要的特性是可以限制 <code>数组元素的个数和类型</code>，它特别适合用来实现多值返回。</p><p>元祖用于保存定长、定数据类型的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [string, number]; <br><span class="hljs-comment">// 类型必须匹配且个数必须为2</span><br><br>x = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// OK </span><br>x = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">10</span>]; <span class="hljs-comment">// Error </span><br>x = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>注意，元组类型只能表示一个已知元素数量和类型的数组，长度已指定，越界访问会提示错误。<code>&lt;u&gt;</code><strong>如果一个数组中可能有多种类型，数量和类型都不确定，那就直接 <code>any[]</code></strong><code>&lt;/u&gt;</code>，也可以使用剩余元素 <code>[number, ...string[]]</code> 表示带有一个 <code>number</code> 元素和任意数量 <code>string</code> 类型元素的元组类型</p><h3 id="元祖类型的解构赋值"><a href="#元祖类型的解构赋值" class="headerlink" title="元祖类型的解构赋值"></a>元祖类型的解构赋值</h3><p>我们可以通过下标的方式来访问元组中的元素，当元组中的元素较多时，这种方式并不是那么便捷。其实元组也是支持解构赋值的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">employee</span>: [number, string] = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Semlinker&quot;</span>];<br><span class="hljs-keyword">let</span> [id, username] = employee;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`id: <span class="hljs-subst">$&#123;id&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`username: <span class="hljs-subst">$&#123;username&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>以上代码成功运行后，控制台会输出以下消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">id</span>: <span class="hljs-number">1</span><br><span class="hljs-attr">username</span>: <span class="hljs-title class_">Semlinker</span><br></code></pre></td></tr></table></figure><p>这里需要注意的是，在解构赋值时，如果解构数组元素的个数是不能超过元组中元素的个数，否则也会出现错误，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">employee</span>: [number, string] = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Semlinker&quot;</span>];\<br><span class="hljs-keyword">let</span> [id, username, age] = employee;<br></code></pre></td></tr></table></figure><p>在以上代码中，我们新增了一个 age 变量，但此时 TypeScript 编译器会提示以下错误信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Tuple</span> type <span class="hljs-string">&#x27;[number, string]&#x27;</span> <span class="hljs-keyword">of</span> length <span class="hljs-string">&#x27;2&#x27;</span> has no element at index <span class="hljs-string">&#x27;2&#x27;</span>.<br></code></pre></td></tr></table></figure><p>很明显元组类型 <code>[number, string]</code> 的长度是 <code>2</code>，在位置索引 <code>2</code> 处不存在任何元素。</p><h3 id="元组类型的可选元素"><a href="#元组类型的可选元素" class="headerlink" title="元组类型的可选元素"></a>元组类型的可选元素</h3><p>与函数签名类型，在定义元组类型时，我们也可以通过 <code>?</code> 号来声明元组类型的可选元素，具体的示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">optionalTuple</span>: [string, boolean?];<br>optionalTuple = [<span class="hljs-string">&quot;Semlinker&quot;</span>, <span class="hljs-literal">true</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`optionalTuple : <span class="hljs-subst">$&#123;optionalTuple&#125;</span>`</span>);<br>optionalTuple = [<span class="hljs-string">&quot;Kakuqo&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`optionalTuple : <span class="hljs-subst">$&#123;optionalTuple&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>在上面代码中，我们定义了一个名为 <code>optionalTuple</code> 的变量，该变量的类型要求包含一个必须的字符串属性和一个可选布尔属性，该代码正常运行后，控制台会输出以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">optionalTuple : <span class="hljs-title class_">Semlinker</span>,<span class="hljs-literal">true</span><br>optionalTuple : <span class="hljs-title class_">Kakuqo</span><br></code></pre></td></tr></table></figure><p>那么在实际工作中，声明可选的元组元素有什么作用？这里我们来举一个例子，在三维坐标轴中，一个坐标点可以使用 <code>(x, y, z)</code> 的形式来表示，对于二维坐标轴来说，坐标点可以使用 <code>(x, y)</code> 的形式来表示，而对于一维坐标轴来说，只要使用 <code>(x)</code> 的形式来表示即可。针对这种情形，在 TypeScript 中就可以利用元组类型可选元素的特性来定义一个元组类型的坐标点，具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Point</span> = [number, number?, number?];<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>: <span class="hljs-title class_">Point</span> = [<span class="hljs-number">10</span>]; <span class="hljs-comment">// 一维坐标点</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">xy</span>: <span class="hljs-title class_">Point</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>]; <span class="hljs-comment">// 二维坐标点</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">xyz</span>: <span class="hljs-title class_">Point</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// 三维坐标点</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x.<span class="hljs-property">length</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xy.<span class="hljs-property">length</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xyz.<span class="hljs-property">length</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="元组类型的剩余元素"><a href="#元组类型的剩余元素" class="headerlink" title="元组类型的剩余元素"></a>元组类型的剩余元素</h3><p>元组类型里最后一个元素可以是剩余元素，形式为 <code>...X</code>，这里 <code>X</code> 是数组类型。<strong>剩余元素代表元组类型是开放的，可以有零个或多个额外的元素。</strong> 例如，<code>[number, ...string[]]</code> 表示带有一个 <code>number</code> 元素和任意数量 <code>string</code> 类型元素的元组类型。为了能更好的理解，我们来举个具体的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">RestTupleType</span> = [number, ...string[]];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">restTuple</span>: <span class="hljs-title class_">RestTupleType</span> = [<span class="hljs-number">666</span>, <span class="hljs-string">&quot;Semlinker&quot;</span>, <span class="hljs-string">&quot;Kakuqo&quot;</span>, <span class="hljs-string">&quot;Lolo&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restTuple[<span class="hljs-number">0</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(restTuple[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><h3 id="只读的元组类型"><a href="#只读的元组类型" class="headerlink" title="只读的元组类型"></a>只读的元组类型</h3><p>TypeScript 3.4 还引入了对只读元组的新支持。我们可以<strong>为任何元组类型加上 <code>readonly</code> 关键字前缀，以使其成为只读元组</strong>。具体的示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: readonly [number, number] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>];<br></code></pre></td></tr></table></figure><p>在使用 <code>readonly</code> 关键字修饰元组类型之后，任何企图修改元组中元素的操作都会抛出异常：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Cannot assign to &#x27;0&#x27; because it is a read-only property.</span><br>point[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// Property &#x27;push&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span><br>point.<span class="hljs-title function_">push</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// Property &#x27;pop&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span><br>point.<span class="hljs-title function_">pop</span>();<br><span class="hljs-comment">// Property &#x27;splice&#x27; does not exist on type &#x27;readonly [number, number]&#x27;.</span><br>point.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p><code>void</code>表示没有任何类型，和其他类型是平等关系，不能直接赋值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-keyword">void</span>; <br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: number = a; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>你只能为它赋予 <code>null</code>和 <code>undefined</code>（在 <code>strictNullChecks</code>未指定为true时）。声明一个 <code>void</code>类型的变量没有什么大用，我们一般也只有在函数没有返回值时去声明。</p><p>值得注意的是，方法没有返回值将得到 <code>undefined</code>，但是我们需要定义成 <code>void</code>类型，而不是 <code>undefined</code>类型。否则将报错:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>): <span class="hljs-literal">undefined</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;this is TypeScript&quot;</span>);<br>&#125;;<br><span class="hljs-title function_">fun</span>(); <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><code>never</code>类型表示的是那些永不存在的值的类型。</p><p>值会永不存在的两种情况：</p><ol><li>如果一个函数执行时抛出了<strong>异常</strong>，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）；</li><li>函数中执行无限循环的代码（<strong>死循环</strong>），使得程序永远无法运行到函数返回值那一步，永不存在返回。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 异常</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">err</span>(<span class="hljs-params">msg: string</span>): never &#123; <span class="hljs-comment">// OK</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(msg); <br>&#125;<br><br><span class="hljs-comment">// 死循环</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loopForever</span>(<span class="hljs-params"></span>): never &#123; <span class="hljs-comment">// OK</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>never</code>类型同 <code>null</code>和 <code>undefined</code>一样，也是任何类型的子类型，也可以赋值给任何类型。</p><p>但是没有类型是 <code>never</code>的子类型或可以赋值给 <code>never</code>类型（除了 <code>never</code>本身之外），即使 <code>any</code>也不可以赋值给 <code>never</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">ne</span>: never;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">nev</span>: never;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">an</span>: any;<br><br>ne = <span class="hljs-number">123</span>; <span class="hljs-comment">// Error</span><br>ne = nev; <span class="hljs-comment">// OK</span><br>ne = an; <span class="hljs-comment">// Error</span><br>ne = (<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;异常&quot;</span>); &#125;)(); <span class="hljs-comment">// OK</span><br>ne = (<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;&#125; &#125;)(); <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Foo</span> = string | number;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">controlFlowAnalysisWithNever</span>(<span class="hljs-params">foo: Foo</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">// 这里 foo 被收窄为 string 类型</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    <span class="hljs-comment">// 这里 foo 被收窄为 number 类型</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// foo 在这里是 never</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">check</span>: never = foo;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Foo</span> = string | number | boolean;<br></code></pre></td></tr></table></figure><p>然而他忘记同时修改 <code>controlFlowAnalysisWithNever</code> 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 <code>boolean</code> 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保 <code>controlFlowAnalysisWithNever</code> 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：<strong>使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</strong></p><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型.</p><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: string = <span class="hljs-string">&#x27;seven&#x27;</span>;<br>a = <span class="hljs-number">7</span>;<br><span class="hljs-comment">// TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></code></pre></td></tr></table></figure><p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: any = <span class="hljs-number">666</span>;<br>a = <span class="hljs-string">&quot;Semlinker&quot;</span>;<br>a = <span class="hljs-literal">false</span>;<br>a = <span class="hljs-number">66</span><br>a = <span class="hljs-literal">undefined</span><br>a = <span class="hljs-literal">null</span><br>a = []<br>a = &#123;&#125;<br></code></pre></td></tr></table></figure><p>在any上访问任何属性都是允许的,也允许调用任何方法.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">anyThing</span>: any = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anyThing.<span class="hljs-property">myName</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anyThing.<span class="hljs-property">myName</span>.<span class="hljs-property">firstName</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">anyThing</span>: any = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>anyThing.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br>anyThing.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;Jerry&#x27;</span>).<span class="hljs-title function_">sayHello</span>();<br>anyThing.<span class="hljs-property">myName</span>.<span class="hljs-title function_">setFirstName</span>(<span class="hljs-string">&#x27;Cat&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> something;<br>something = <span class="hljs-string">&#x27;seven&#x27;</span>;<br>something = <span class="hljs-number">7</span>;<br>something.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">something</span>: any;<br>something = <span class="hljs-string">&#x27;seven&#x27;</span>;<br>something = <span class="hljs-number">7</span>;<br>something.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在许多场景下，这太宽松了。使用 <code>any</code> 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 <code>any</code> 类型，就无法使用 TypeScript 提供的大量的保护机制。请记住，<code>any 是魔鬼！</code>尽量不要用any。</p><p>为了解决 <code>any</code> 带来的问题，TypeScript 3.0 引入了 <code>unknown</code> 类型。</p><h2 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h2><p><code>unknown</code>与 <code>any</code>一样，所有类型都可以分配给 <code>unknown</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: unknown = <span class="hljs-number">4</span>;<br>notSure = <span class="hljs-string">&quot;maybe a string instead&quot;</span>; <span class="hljs-comment">// OK</span><br>notSure = <span class="hljs-literal">false</span>; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p><code>unknown</code>与 <code>any</code>的最大区别是： 任何类型的值可以赋值给 <code>any</code>，同时 <code>any</code>类型的值也可以赋值给任何类型。<code>unknown</code> 任何类型的值都可以赋值给它，但它只能赋值给 <code>unknown</code>和 <code>any</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">uncertain</span>: <span class="hljs-built_in">any</span> = notSure; <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">uncertain</span>: <span class="hljs-built_in">unknown</span> = notSure; <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">uncertain</span>: <span class="hljs-built_in">number</span> = notSure; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>如果不缩小类型，就无法对 <code>unknown</code>类型执行任何操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDog</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;123&#x27;</span><br>&#125;<br> <br><span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: unknown = &#123;<span class="hljs-attr">hello</span>: getDog&#125;;<br>dog.<span class="hljs-title function_">hello</span>(); <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>这种机制起到了很强的预防性，更安全，这就要求我们必须缩小类型，我们可以使用 <code>typeof</code>、<code>类型断言</code>等方式来缩小未知范围：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDogName</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: unknown;<br> <span class="hljs-keyword">return</span> x;<br>&#125;;<br><span class="hljs-keyword">const</span> dogName = <span class="hljs-title function_">getDogName</span>();<br><span class="hljs-comment">// 直接使用</span><br><span class="hljs-keyword">const</span> upName = dogName.<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// Error</span><br><span class="hljs-comment">// typeof</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> dogName === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>  <span class="hljs-keyword">const</span> upName = dogName.<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// OK</span><br>&#125;<br><span class="hljs-comment">// 类型断言 </span><br><span class="hljs-keyword">const</span> upName = (dogName <span class="hljs-keyword">as</span> string).<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><h2 id="Number、String、Boolean、Symbol"><a href="#Number、String、Boolean、Symbol" class="headerlink" title="Number、String、Boolean、Symbol"></a>Number、String、Boolean、Symbol</h2><p>首先，我们来回顾一下初学 TypeScript 时，很容易和原始类型 number、string、boolean、symbol 混淆的首字母大写的 Number、String、Boolean、Symbol 类型，后者是相应原始类型的 <code>包装对象</code>，姑且把它们称之为对象类型。</p><p>从类型兼容性上看，原始类型兼容对应的对象类型，反过来对象类型不兼容对应的原始类型。</p><p>下面我们看一个具体的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: number;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Num</span>: <span class="hljs-title class_">Number</span>;<br><span class="hljs-title class_">Num</span> = num; <span class="hljs-comment">// ok</span><br>num = <span class="hljs-title class_">Num</span>; <span class="hljs-comment">// ts(2322)报错</span><br></code></pre></td></tr></table></figure><p>在示例中的第 3 行，我们可以把 number 赋给类型 Number，但在第 4 行把 Number 赋给 number 就会提示 ts(2322) 错误。</p><p><strong>因此，我们需要铭记不要使用对象类型来注解值的类型，因为这没有任何意义。</strong></p><h2 id="object、Object-和"><a href="#object、Object-和" class="headerlink" title="object、Object 和 {}"></a>object、Object 和 {}</h2><p>另外，object（首字母小写，以下称“小 object”）、Object（首字母大写，以下称“大 Object”）和 {}（以下称“空对象”）</p><p><strong>小 object 代表的是所有非原始类型，也就是说我们不能把 number、string、boolean、symbol等 原始类型赋值给 object。在严格模式下，<code>null</code> 和 <code>undefined</code> 类型也不能赋给 object。</strong></p><blockquote><p>JavaScript 中以下类型被视为原始类型：<code>string</code>、<code>boolean</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>、<code>null</code> 和 <code>undefined</code>。</p></blockquote><p>下面我们看一个具体示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">lowerCaseObject</span>: object;<br>lowerCaseObject = <span class="hljs-number">1</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = &#123;&#125;; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>在示例中的第 2~6 行都会提示 ts(2322) 错误，但是我们在第 7 行把一个空对象赋值给 object 后，则可以通过静态类型检测。</p><p>大Object 代表所有拥有 toString、hasOwnProperty 方法的类型，所以所有原始类型、非原始类型都可以赋给 Object。同样，<strong>在严格模式下，null 和 undefined 类型也不能赋给 Object。</strong></p><p>下面我们也看一个具体的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">upperCaseObject</span>: <span class="hljs-title class_">Object</span>;<br>upperCaseObject = <span class="hljs-number">1</span>; <span class="hljs-comment">// ok</span><br>upperCaseObject = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// ok</span><br>upperCaseObject = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ok</span><br>upperCaseObject = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ts(2322)</span><br>upperCaseObject = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// ts(2322)</span><br>upperCaseObject = &#123;&#125;; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>在示例中的第 2到4 行、第 7 行都可以通过静态类型检测，而第 5~6 行则会提示 ts(2322) 错误。</p><p>从上面示例可以看到，大 Object 包含原始类型，小 object 仅包含非原始类型，所以大 Object 似乎是小 object 的父类型。实际上，大 Object 不仅是小 object 的父类型，同时也是小 object 的子类型。</p><p>下面我们还是通过一个具体的示例进行说明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">type isLowerCaseObjectExtendsUpperCaseObject = object <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <span class="hljs-comment">// true</span><br>type isUpperCaseObjectExtendsLowerCaseObject = <span class="hljs-title class_">Object</span> <span class="hljs-keyword">extends</span> object ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <span class="hljs-comment">// true</span><br>upperCaseObject = lowerCaseObject; <span class="hljs-comment">// ok</span><br>lowerCaseObject = upperCaseObject; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>在示例中的第 1 行和第 2 行返回的类型都是 true，第3 行和第 4 行的 upperCaseObject 与 lowerCaseObject 可以互相赋值。</p><blockquote><p><strong>注意：尽管官方文档说可以使用小 object 代替大 Object，但是我们仍要明白大 Object 并不完全等价于小 object。</strong></p></blockquote><p>{}空对象类型和大 Object 一样，也是表示原始类型和非原始类型的集合，并且在严格模式下，null 和 undefined 也不能赋给 {} ，如下示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title class_">ObjectLiteral</span>: &#123;&#125;;<br><span class="hljs-title class_">ObjectLiteral</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// ok</span><br><span class="hljs-title class_">ObjectLiteral</span> = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// ok</span><br><span class="hljs-title class_">ObjectLiteral</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ok</span><br><span class="hljs-title class_">ObjectLiteral</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ts(2322)</span><br><span class="hljs-title class_">ObjectLiteral</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// ts(2322)</span><br><span class="hljs-title class_">ObjectLiteral</span> = &#123;&#125;; <span class="hljs-comment">// ok</span><br>type isLiteralCaseObjectExtendsUpperCaseObject = &#123;&#125; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <span class="hljs-comment">// true</span><br>type isUpperCaseObjectExtendsLiteralCaseObject = <span class="hljs-title class_">Object</span> <span class="hljs-keyword">extends</span> &#123;&#125; ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <span class="hljs-comment">// true</span><br>upperCaseObject = <span class="hljs-title class_">ObjectLiteral</span>;<br><span class="hljs-title class_">ObjectLiteral</span> = upperCaseObject;<br></code></pre></td></tr></table></figure><p>在示例中的第 8 行和第 9 行返回的类型都是 true，第10 行和第 11 行的 ObjectLiteral 与 upperCaseObject 可以互相赋值，第2~4 行、第 7 行的赋值操作都符合静态类型检测；而第5 行、第 6 行则会提示 ts(2322) 错误。</p><p><strong>综上结论：{}、大 Object 是比小 object 更宽泛的类型（least specific），{} 和大 Object 可以互相代替，用来表示原始类型（null、undefined 除外）和非原始类型；而小 object 则表示非原始类型。</strong></p><h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: string = <span class="hljs-string">&#x27;this is string&#x27;</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: number = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">bool</span>: boolean = <span class="hljs-literal">true</span>;<br>&#125;<br>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: string = <span class="hljs-string">&#x27;this is string&#x27;</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">num</span>: number = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">bool</span>: boolean = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看着上面的示例，可能你已经在嘀咕了：定义基础类型的变量都需要写明类型注解，TypeScript 太麻烦了吧？在示例中，使用 let 定义变量时，我们写明类型注解也就罢了，毕竟值可能会被改变。可是，使用 <code>const</code> 常量时还需要写明类型注解，那可真的很麻烦。</p><p>实际上，TypeScript 早就考虑到了这么简单而明显的问题。</p><p>在很多情况下，TypeScript 会根据上下文环境自动推断出变量的类型，无须我们再写明类型注解。因此，上面的示例可以简化为如下所示内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// 等价</span><br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>; <span class="hljs-comment">// 等价</span><br>  <span class="hljs-keyword">let</span> bool = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 等价</span><br>&#125;<br>&#123;<br>  <span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// 不等价</span><br>  <span class="hljs-keyword">const</span> num = <span class="hljs-number">1</span>; <span class="hljs-comment">// 不等价</span><br>  <span class="hljs-keyword">const</span> bool = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 不等价</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们把 TypeScript 这种基于赋值表达式推断类型的能力称之为 <code>类型推断</code>。</p><p>在 TypeScript 中，具有初始化值的变量、有默认值的函数参数、函数返回的类型都可以根据上下文推断出来。比如我们能根据 return 语句推断函数返回的类型，如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-comment">/** 根据参数的类型，推断出返回值的类型也是 number */</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">a: number, b: number</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>  <span class="hljs-keyword">const</span> x1= <span class="hljs-title function_">add1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 推断出 x1 的类型也是 number</span><br>  <br>  <span class="hljs-comment">/** 推断参数 b 的类型是数字或者 undefined，返回值的类型也是数字 */</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add2</span>(<span class="hljs-params">a: number, b = <span class="hljs-number">1</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>  <span class="hljs-keyword">const</span> x2 = <span class="hljs-title function_">add2</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> x3 = <span class="hljs-title function_">add2</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-comment">// ts(2345) Argument of type &quot;1&quot; is not assignable to parameter of type &#x27;number | undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myFavoriteNumber;<br>myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;<br>myFavoriteNumber = <span class="hljs-number">7</span>;<br></code></pre></td></tr></table></figure><h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p><p>TypeScript 类型检测无法做到绝对智能，毕竟程序不能像人一样思考。有时会碰到我们比 TypeScript 更清楚实际类型的情况，比如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">arrayNumber</span>: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-attr">greaterThan2</span>: number = arrayNumber.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// 提示 ts(2322)</span><br></code></pre></td></tr></table></figure><p>其中，greaterThan2 一定是一个数字（确切地讲是 3），因为 arrayNumber 中明显有大于 2 的成员，但静态类型对运行时的逻辑无能为力。</p><p>在 TypeScript 看来，greaterThan2 的类型既可能是数字，也可能是 undefined，所以上面的示例中提示了一个 ts(2322) 错误，此时我们不能把类型 undefined 分配给类型 number。</p><p>不过，我们可以使用一种笃定的方式——<strong>类型断言</strong>（类似仅作用在类型层面的强制类型转换）告诉 TypeScript 按照我们的方式做类型检查。</p><p>比如，我们可以使用 as 语法做类型断言，如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">arrayNumber</span>: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-attr">greaterThan2</span>: number = arrayNumber.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> number;<br></code></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 尖括号 语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: any = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: number = (&lt;string&gt;someValue).<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// as 语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: any = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: number = (someValue <span class="hljs-keyword">as</span> string).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><p>以上两种方式虽然没有任何区别，但是尖括号格式会与react中JSX产生语法冲突，因此我们更推荐使用 as 语法。</p><h2 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h2><p>在上下文中当类型检查器无法断定类型时，<strong>一个新的后缀表达式操作符 <code>!</code> 可以用于断言操作对象是非 null 和非 undefined 类型</strong>。具体而言，<strong>x! 将从 x 值域中排除 null 和 undefined</strong> 。</p><p>具体看以下示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">mayNullOrUndefinedOrString</span>: <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> | string;<br><span class="hljs-comment">//表示mayNullOrUndefinedOrString不为空，故而类型为string</span><br>mayNullOrUndefinedOrString!.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// ok</span><br>mayNullOrUndefinedOrString.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// ts(2531)</span><br>type <span class="hljs-title class_">NumGenerator</span> = <span class="hljs-function">() =&gt;</span> number;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">numGenerator: NumGenerator | <span class="hljs-literal">undefined</span></span>) &#123;<br>  <span class="hljs-comment">// Object is possibly &#x27;undefined&#x27;.(2532)</span><br>  <span class="hljs-comment">// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)</span><br>  <span class="hljs-keyword">const</span> num1 = <span class="hljs-title function_">numGenerator</span>(); <span class="hljs-comment">// Error</span><br>  <span class="hljs-keyword">const</span> num2 = numGenerator!(); <span class="hljs-comment">//OK</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h2><p>允许在实例属性和变量声明后面放置一个 <code>!</code> 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: number;<br><span class="hljs-title function_">initialize</span>();<br><br><span class="hljs-comment">// Variable &#x27;x&#x27; is used before being assigned.(2454)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params"></span>) &#123;<br>  x = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x!: number;<br><span class="hljs-title function_">initialize</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Ok</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params"></span>) &#123;<br>  x = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>let x!: number;</code> 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</p><h1 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h1><p>在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。</p><p>目前，TypeScript 支持 3 种字面量类型：<strong>字符串字面量类型、数字字面量类型、布尔字面量类型</strong>，对应的字符串字面量、数字字面量、布尔字面量分别拥有与其值一样的字面量类型，具体示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedStr</span>: <span class="hljs-string">&#x27;this is string&#x27;</span> = <span class="hljs-string">&#x27;this is string&#x27;</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedNum</span>: <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedBoolean</span>: <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如 ‘this is string’ （这里表示一个字符串字面量类型）类型是 string 类型（确切地说是 string 类型的子类型），而 string 类型不一定是 ‘this is string’（这里表示一个字符串字面量类型）类型，如下具体示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedStr</span>: <span class="hljs-string">&#x27;this is string&#x27;</span> = <span class="hljs-string">&#x27;this is string&#x27;</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: string = <span class="hljs-string">&#x27;any string&#x27;</span>;<br>  specifiedStr = str; <span class="hljs-comment">// ts(2322) 类型 &#x27;&quot;string&quot;&#x27; 不能赋值给类型 &#x27;this is string&#x27;</span><br>  str = specifiedStr; <span class="hljs-comment">// ok </span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如说我们用“马”比喻 string 类型，即“黑马”代指 ‘this is string’ 类型，“黑马”肯定是“马”，但“马”不一定是“黑马”，它可能还是“白马”“灰马”。因此，’this is string’ 字面量类型可以给 string 类型赋值，但是 string 类型不能给 ‘this is string’ 字面量类型赋值，这个比喻同样适合于形容数字、布尔等其他字面量和它们父类的关系。</p><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>一般来说，我们可以使用一个字符串字面量类型作为变量的类型，如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">hello</span>: <span class="hljs-string">&#x27;hello&#x27;</span> = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>hello = <span class="hljs-string">&#x27;hi&#x27;</span>; <span class="hljs-comment">// ts(2322) Type &#x27;&quot;hi&quot;&#x27; is not assignable to type &#x27;&quot;hello&quot;&#x27;</span><br></code></pre></td></tr></table></figure><p>实际上，定义单个的字面量类型并没有太大的用处，它真正的应用场景是可以把多个字面量类型组合成一个联合类型（后面会讲解），用来描述拥有明确成员的实用的集合。</p><p>如下代码所示，我们使用字面量联合类型描述了一个明确、可 ‘up’ 可 ‘down’ 的集合，这样就能清楚地知道需要的数据结构了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Direction</span> = <span class="hljs-string">&#x27;up&#x27;</span> | <span class="hljs-string">&#x27;down&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">dir: Direction</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-title function_">move</span>(<span class="hljs-string">&#x27;up&#x27;</span>); <span class="hljs-comment">// ok</span><br><span class="hljs-title function_">move</span>(<span class="hljs-string">&#x27;right&#x27;</span>); <span class="hljs-comment">// ts(2345) Argument of type &#x27;&quot;right&quot;&#x27; is not assignable to parameter of type &#x27;Direction&#x27;</span><br></code></pre></td></tr></table></figure><p>通过使用字面量类型组合的联合类型，我们可以限制函数的参数为指定的字面量类型集合，然后编译器会检查参数是否是指定的字面量类型集合里的成员。</p><p>因此，相较于使用 string 类型，使用字面量类型（组合的联合类型）可以将函数的参数限定为更具体的类型。这不仅提升了程序的可读性，还保证了函数的参数类型，可谓一举两得。</p><h2 id="数字字面量类型及布尔字面量类型"><a href="#数字字面量类型及布尔字面量类型" class="headerlink" title="数字字面量类型及布尔字面量类型"></a>数字字面量类型及布尔字面量类型</h2><p>数字字面量类型和布尔字面量类型的使用与字符串字面量类型的使用类似，我们可以使用字面量组合的联合类型将函数的参数限定为更具体的类型，比如声明如下所示的一个类型 Config：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Config</span> &#123;<br>    <span class="hljs-attr">size</span>: <span class="hljs-string">&#x27;small&#x27;</span> | <span class="hljs-string">&#x27;big&#x27;</span>;<br>    <span class="hljs-attr">isEnable</span>:  <span class="hljs-literal">true</span> | <span class="hljs-literal">false</span>;<br>    <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span> | <span class="hljs-number">2</span> | <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:<span class="hljs-title class_">Config</span> = &#123;<br>    <span class="hljs-attr">size</span>:<span class="hljs-string">&#x27;big&#x27;</span>,<br>    <span class="hljs-attr">isEnable</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">margin</span>:<span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br></code></pre></td></tr></table></figure><p>在上述代码中，我们限定了 size 属性为字符串字面量类型 ‘small’ | ‘big’，isEnable 属性为布尔字面量类型 true | false（布尔字面量只包含 true 和 false，true | false 的组合跟直接使用 boolean 没有区别），margin 属性为数字字面量类型 0 | 2 | 4。</p><h2 id="let和const分析"><a href="#let和const分析" class="headerlink" title="let和const分析"></a>let和const分析</h2><p>我们先来看一个 const 示例，如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-comment">//由于const定义常量，此处定义的类型为this is string，尽管typeof的结果为string，但其实其类型推断为&#x27;this is string&#x27;</span><br>  <span class="hljs-comment">//下方类似</span><br>  <span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// str: &#x27;this is string&#x27;</span><br>  <span class="hljs-keyword">const</span> num = <span class="hljs-number">1</span>; <span class="hljs-comment">// num: 1</span><br>  <span class="hljs-keyword">const</span> bool = <span class="hljs-literal">true</span>; <span class="hljs-comment">// bool: true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<strong>我们将 const 定义为一个不可变更的常量，在缺省类型注解的情况下，TypeScript 推断出它的类型直接由赋值字面量的类型决定，这也是一种比较合理的设计</strong>。</p><p>接下来我们看看如下所示的 let 示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-comment">//let为变量，故缺省显式类型注解的可变更的变量的类型转换为了赋值字面量类型的父类型，类型显示正常</span><br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// str: string</span><br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>; <span class="hljs-comment">// num: number</span><br>  <span class="hljs-keyword">let</span> bool = <span class="hljs-literal">true</span>; <span class="hljs-comment">// bool: boolean</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，缺省显式类型注解的可变更的变量的类型转换为了赋值字面量类型的父类型，比如 str 的类型是 ‘this is string’ 类型（这里表示一个字符串字面量类型）的父类型 string，num 的类型是 1 类型的父类型 number。</p><p>这种设计符合编程预期，意味着我们可以分别赋予 str 和 num 任意值（只要类型是 string 和 number 的子集的变量）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">str = <span class="hljs-string">&#x27;any string&#x27;</span>;<br>num = <span class="hljs-number">2</span>;<br>bool = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p><strong>我们将 TypeScript 的字面量子类型转换为父类型的这种设计称之为 “literal widening”，也就是字面量类型的拓宽</strong>，比如上面示例中提到的字符串字面量类型转换成 string 类型，下面我们着重介绍一下。</p><h1 id="类型拓宽-Type-Widening"><a href="#类型拓宽-Type-Widening" class="headerlink" title="类型拓宽(Type Widening)"></a>类型拓宽(Type Widening)</h1><p>所有通过 let 或 var 定义的变量、函数的形参、对象的非只读属性，如果满足指定了<strong>初始值且未显式添加类型注解的条件，那么它们推断出来的类型就是指定的初始值字面量类型拓宽后的类型，这就是字面量类型拓宽</strong>。</p><p>下面我们通过字符串字面量的示例来理解一下字面量类型拓宽：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// 类型是 string</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">strFun</span> = (<span class="hljs-params">str = <span class="hljs-string">&#x27;this is string&#x27;</span></span>) =&gt; str; <span class="hljs-comment">// 类型是 (str?: string) =&gt; string;</span><br><span class="hljs-keyword">const</span> specifiedStr = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// 类型是 &#x27;this is string&#x27;</span><br><span class="hljs-keyword">let</span> str2 = specifiedStr; <span class="hljs-comment">// 类型是 &#x27;string&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">strFun2</span> = (<span class="hljs-params">str = specifiedStr</span>) =&gt; str; <span class="hljs-comment">// 类型是 (str?: string) =&gt; string;</span><br></code></pre></td></tr></table></figure><p>因为第 1~2 行满足了 let、形参且未显式声明类型注解的条件，所以变量、形参的类型拓宽为 string（形参类型确切地讲是 string | undefined）。</p><p>因为第 3 行的常量不可变更，类型没有拓宽，所以 specifiedStr 的类型是 ‘this is string’ 字面量类型。</p><p>第 4~5 行，因为赋予的值 specifiedStr 的类型是字面量类型，且没有显式类型注解，所以变量、形参的类型也被拓宽了。其实，这样的设计符合实际编程诉求。我们设想一下，如果 str2 的类型被推断为 ‘this is string’，它将不可变更，因为赋予任何其他的字符串类型的值都会提示类型错误。</p><p>基于字面量类型拓宽的条件，我们可以通过如下所示代码添加显示类型注解控制类型拓宽行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">specifiedStr</span>: <span class="hljs-string">&#x27;this is string&#x27;</span> = <span class="hljs-string">&#x27;this is string&#x27;</span>; <span class="hljs-comment">// 类型是 &#x27;&quot;this is string&quot;&#x27;</span><br>  <span class="hljs-keyword">let</span> str2 = specifiedStr; <span class="hljs-comment">// 即便使用 let 定义，类型是 &#x27;this is string&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，除了字面量类型拓宽之外，TypeScript 对某些特定类型值也有类似 “Type Widening” （类型拓宽）的设计，下面我们具体来了解一下。</p><p>比如对 null 和 undefined 的类型进行拓宽，通<strong>过 let、var 定义的变量如果满足未显式声明类型注解且被赋予了 null 或 undefined 值，则推断出这些变量的类型是 any</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 类型拓宽成 any</span><br>  <span class="hljs-keyword">let</span> y = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 类型拓宽成 any</span><br><br>  <span class="hljs-comment">/** -----分界线------- */</span><br>  <span class="hljs-keyword">const</span> z = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 类型是 null</span><br><br>  <span class="hljs-comment">/** -----分界线------- */</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">anyFun</span> = (<span class="hljs-params">param = <span class="hljs-literal">null</span></span>) =&gt; param; <span class="hljs-comment">// 形参类型是 null</span><br>  <span class="hljs-keyword">let</span> z2 = z; <span class="hljs-comment">// 类型是 null</span><br>  <span class="hljs-keyword">let</span> x2 = x; <span class="hljs-comment">// 类型是 null</span><br>  <span class="hljs-keyword">let</span> y2 = y; <span class="hljs-comment">// 类型是 undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：在严格模式下，一些比较老的版本中（2.0）null 和 undefined 并不会被拓宽成“any”。</strong></p><p>为了更方便的理解类型拓宽,下面我们举个例子,更加深入的分析一下</p><p>假设你正在编写一个向量库，你首先定义了一个 Vector3 接口，然后定义了 getComponent 函数用于获取指定坐标轴的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Vector3</span> &#123;<br>  <span class="hljs-attr">x</span>: number;<br>  <span class="hljs-attr">y</span>: number;<br>  <span class="hljs-attr">z</span>: number;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getComponent</span>(<span class="hljs-params">vector: Vector3, axis: <span class="hljs-string">&quot;x&quot;</span> | <span class="hljs-string">&quot;y&quot;</span> | <span class="hljs-string">&quot;z&quot;</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> vector[axis];<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，当你尝试使用 getComponent 函数时，TypeScript 会提示以下错误信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-string">&quot;x&quot;</span>;<br><span class="hljs-keyword">let</span> vec = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">30</span> &#125;;<br><span class="hljs-comment">// 类型“string”的参数不能赋给类型“&quot;x&quot; | &quot;y&quot; | &quot;z&quot;”的参数。</span><br><span class="hljs-comment">//当x为变量时因类型拓展为string而报错，当为常量时，类型为字面常量，故不会报错</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:number = <span class="hljs-title function_">getComponent</span>(vec, x);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br></code></pre></td></tr></table></figure><p>为什么会出现上述错误呢？通过 TypeScript 的错误提示消息，我们知道是因为变量 x 的类型被推断为 string 类型，而 getComponent 函数期望它的第二个参数有一个更具体的类型。这在实际场合中被拓宽了，所以导致了一个错误。</p><p>这个过程是复杂的，因为对于任何给定的值都有许多可能的类型。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>上述 <strong>arr 变量的类型</strong>应该是什么？这里有一些可能性：</p><ul><li>(‘x’ | 1)[]</li><li>[‘x’, 1]<ul><li>[string, number]</li></ul></li><li>readonly [string, number]</li><li>(string | number)[]</li><li>readonly (string|number)[]</li><li>[any, any]</li><li>any[]</li></ul><p>没有更多的上下文，TypeScript 无法知道哪种类型是 “正确的”，它必须猜测你的意图。尽管 TypeScript 很聪明，但它无法读懂你的心思。它不能保证 100% 正确，正如我们刚才看到的那样的疏忽性错误。</p><p>在下面的例子中，变量 x 的类型被推断为字符串，因为 TypeScript 允许这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-string">&#x27;semlinker&#x27;</span>;<br>x = <span class="hljs-string">&#x27;kakuqo&#x27;</span>;<br>x = <span class="hljs-string">&#x27;lolo&#x27;</span>;<br></code></pre></td></tr></table></figure><p>对于 JavaScript 来说，以下代码也是合法的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-string">&#x27;x&#x27;</span>;<br>x = <span class="hljs-regexp">/x|y|z/</span>;<br>x = [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>];<br></code></pre></td></tr></table></figure><p>在推断 x 的类型为字符串时，TypeScript 试图在特殊性和灵活性之间取得平衡。一般规则是，变量的类型在声明之后不应该改变，因此 string 比 string|RegExp 或 string|string[] 或任何字符串更有意义。</p><p>TypeScript 提供了一些控制拓宽过程的方法。其中一种方法是使用 <code>const</code>。如果用 const 而不是 let 声明一个变量，那么它的类型会更窄。事实上，使用 const 可以帮助我们修复前面例子中的错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> x = <span class="hljs-string">&quot;x&quot;</span>; <span class="hljs-comment">// type is &quot;x&quot; </span><br><span class="hljs-keyword">let</span> vec = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">30</span> &#125;;<br><span class="hljs-title function_">getComponent</span>(vec, x); <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>因为 x 不能重新赋值，所以 TypeScript 可以推断更窄的类型，就不会在后续赋值中出现错误。因为字符串字面量型 “x” 可以赋值给  “x”|”y”|”z”，所以代码会通过类型检查器的检查。</p><p>然而，<code>const 并不是万灵药。对于对象和数组，仍然会存在问题</code>。</p><p>以下这段代码在 JavaScript 中是没有问题的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,<br>&#125;; <br><br>obj.<span class="hljs-property">x</span> = <span class="hljs-number">6</span>; <br>obj.<span class="hljs-property">x</span> = <span class="hljs-string">&#x27;6&#x27;</span>;<br><br>obj.<span class="hljs-property">y</span> = <span class="hljs-number">8</span>;<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;semlinker&#x27;</span>;<br></code></pre></td></tr></table></figure><p>而在 TypeScript 中，对于 obj 的类型来说，它可以是 <code>&#123;readonly x：1&#125;</code> 类型，或者是更通用的 <code>&#123;x：number&#125;</code> 类型。当然也可能是 <code>&#123;[key: string]: number&#125;</code> 或 object 类型。对于对象，TypeScript 的拓宽算法会将其内部属性视为将其赋值给 let 关键字声明的变量，进而来推断其属性的类型。因此 obj 的类型为 <code>&#123;x：number&#125;</code> 。这使得你可以将 obj.x 赋值给其他 number 类型的变量，而不是 string 类型的变量，并且它还会阻止你添加其他属性。</p><p>因此最后三行的语句会出现错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,<br>&#125;;<br><br>obj.<span class="hljs-property">x</span> = <span class="hljs-number">6</span>; <span class="hljs-comment">// OK </span><br><br><br><span class="hljs-comment">// Type &#x27;&quot;6&quot;&#x27; is not assignable to type &#x27;number&#x27;.</span><br>obj.<span class="hljs-property">x</span> = <span class="hljs-string">&#x27;6&#x27;</span>; <span class="hljs-comment">// Error</span><br><br><span class="hljs-comment">// Property &#x27;y&#x27; does not exist on type &#x27;&#123; x: number; &#125;&#x27;.</span><br>obj.<span class="hljs-property">y</span> = <span class="hljs-number">8</span>; <span class="hljs-comment">// Error</span><br><br><span class="hljs-comment">// Property &#x27;name&#x27; does not exist on type &#x27;&#123; x: number; &#125;&#x27;.</span><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;semlinker&#x27;</span>; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>TypeScript 试图在具体性和灵活性之间取得平衡。它需要推断一个足够具体的类型来捕获错误，但又不能推断出错误的类型。它通过属性的初始化值来推断属性的类型，当然有几种方法可以覆盖 TypeScript 的默认行为。一种是提供显式类型注释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Type is &#123; x: 1 | 3 | 5; &#125;</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> | <span class="hljs-number">3</span> | <span class="hljs-number">5</span> &#125; = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> <br>&#125;;<br></code></pre></td></tr></table></figure><p>另一种方法是使用 const 断言。不要将其与 let 和 const 混淆，后者在值空间中引入符号。这是一个纯粹的类型级构造。让我们来看看以下变量的不同推断类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Type is &#123; x: number; y: number; &#125;</span><br><span class="hljs-keyword">const</span> obj1 = &#123; <br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <br>  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> <br>&#125;; <br><br><span class="hljs-comment">// Type is &#123; x: 1; y: number; &#125;</span><br><span class="hljs-keyword">const</span> obj2 = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>,<br>&#125;; <br><br><span class="hljs-comment">// Type is &#123; readonly x: 1; readonly y: 2; &#125;</span><br><span class="hljs-keyword">const</span> obj3 = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <br>  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> <br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br></code></pre></td></tr></table></figure><p>当你在一个值之后使用 const 断言时，TypeScript 将为它推断出最窄的类型，没有拓宽。对于真正的常量，这通常是你想要的。当然你也可以对数组使用 const 断言：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Type is number[]</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br><br><span class="hljs-comment">// Type is readonly [1, 2, 3]</span><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br></code></pre></td></tr></table></figure><p>既然有类型拓宽，自然也会有类型缩小，下面我们简单介绍一下 Type Narrowing。</p><h1 id="类型缩小-Type-Narrowing"><a href="#类型缩小-Type-Narrowing" class="headerlink" title="类型缩小(Type Narrowing)"></a>类型缩小(Type Narrowing)</h1><p>在 TypeScript 中，我们可以通过某些操作将变量的类型由一个较为宽泛的集合缩小到相对较小、较明确的集合，这就是 “Type Narrowing”。</p><p>比如，我们可以使用类型守卫（后面会讲到）将函数参数的类型从 any 缩小到明确的类型，具体示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">anything: any</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> anything === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> anything; <span class="hljs-comment">// 类型是 string </span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> anything === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> anything; <span class="hljs-comment">// 类型是 number</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 VS Code 中 hover 到第 4 行的 anything 变量提示类型是 string，到第 6 行则提示类型是 number。</p><p>同样，我们可以使用类型守卫将联合类型缩小到明确的子类型，具体示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">anything: string | number</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> anything === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> anything; <span class="hljs-comment">// 类型是 string </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> anything; <span class="hljs-comment">// 类型是 number</span><br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，我们也可以通过字面量类型等值判断（&#x3D;&#x3D;&#x3D;）或其他控制流语句（包括但不限于 if、三目运算符、switch 分支）将联合类型收敛为更具体的类型，如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  type <span class="hljs-title class_">Goods</span> = <span class="hljs-string">&#x27;pen&#x27;</span> | <span class="hljs-string">&#x27;pencil&#x27;</span> |<span class="hljs-string">&#x27;ruler&#x27;</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getPenCost</span> = (<span class="hljs-params">item: <span class="hljs-string">&#x27;pen&#x27;</span></span>) =&gt; <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getPencilCost</span> = (<span class="hljs-params">item: <span class="hljs-string">&#x27;pencil&#x27;</span></span>) =&gt; <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getRulerCost</span> = (<span class="hljs-params">item: <span class="hljs-string">&#x27;ruler&#x27;</span></span>) =&gt; <span class="hljs-number">6</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getCost</span> = (<span class="hljs-params">item: Goods</span>) =&gt;  &#123;<br>    <span class="hljs-keyword">if</span> (item === <span class="hljs-string">&#x27;pen&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getPenCost</span>(item); <span class="hljs-comment">// item =&gt; &#x27;pen&#x27;</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-string">&#x27;pencil&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getPencilCost</span>(item); <span class="hljs-comment">// item =&gt; &#x27;pencil&#x27;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getRulerCost</span>(item); <span class="hljs-comment">// item =&gt; &#x27;ruler&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述 getCost 函数中，接受的参数类型是字面量类型的联合类型，函数内包含了 <code>if</code> 语句的 3 个流程分支，其中每个流程分支调用的函数的参数都是具体独立的字面量类型。</p><p>那为什么类型由多个字面量组成的变量 item 可以传值给仅接收单一特定字面量类型的函数 <code>getPenCost、getPencilCost、getRulerCost</code> 呢？这是因为在每个流程分支中，编译器知道流程分支中的 item 类型是什么。比如 item &#x3D;&#x3D;&#x3D; ‘pencil’ 的分支，item 的类型就被收缩为“pencil”。</p><p>事实上，如果我们将上面的示例去掉中间的流程分支，编译器也可以推断出收敛后的类型，如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getCost</span> = (<span class="hljs-params">item: Goods</span>) =&gt;  &#123;<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-string">&#x27;pen&#x27;</span>) &#123;<br>    item; <span class="hljs-comment">// item =&gt; &#x27;pen&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    item; <span class="hljs-comment">// =&gt; &#x27;pencil&#x27; | &#x27;ruler&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般来说 <code>TypeScript</code> 非常擅长通过条件来判别类型，但在处理一些特殊值时要特别注意 —— 它可能包含你不想要的东西！例如，以下从联合类型中排除 null 的方法是错误的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;foo&quot;</span>); <span class="hljs-comment">// Type is HTMLElement | null</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>  el; <span class="hljs-comment">// Type is HTMLElement | null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为在 JavaScript 中 <code>typeof null</code> 的结果是 “object” ，所以你实际上并没有通过这种检查排除 <code>null</code> 值。除此之外，falsy 的原始值也会产生类似的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x?: number | string | <span class="hljs-literal">null</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!x) &#123;<br>    x; <span class="hljs-comment">// Type is string | number | null | undefined\</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为空字符串和 0 都属于 falsy 值，所以在分支中 x 的类型可能是 string 或 number 类型。帮助类型检查器缩小类型的另一种常见方法是在它们上放置一个明确的 “标签”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">UploadEvent</span> &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;upload&quot;</span>;<br>  <span class="hljs-attr">filename</span>: string;<br>  <span class="hljs-attr">contents</span>: string;<br>&#125;<br><br>interface <span class="hljs-title class_">DownloadEvent</span> &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;download&quot;</span>;<br>  <span class="hljs-attr">filename</span>: string;<br>&#125;<br><br>type <span class="hljs-title class_">AppEvent</span> = <span class="hljs-title class_">UploadEvent</span> | <span class="hljs-title class_">DownloadEvent</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleEvent</span>(<span class="hljs-params">e: AppEvent</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (e.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;download&quot;</span>:<br>      e; <span class="hljs-comment">// Type is DownloadEvent </span><br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;upload&quot;</span>:<br>      e; <span class="hljs-comment">// Type is UploadEvent </span><br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式也被称为 ”标签联合“ 或 ”可辨识联合“，它在 TypeScript 中的应用范围非常广。</p><h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><p>联合类型表示取值可以为多种类型中的一种，使用 <code>|</code> 分隔每个类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">myFavoriteNumber</span>: string | number;<br>myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>; <span class="hljs-comment">// OK</span><br>myFavoriteNumber = <span class="hljs-number">7</span>; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayHello</span> = (<span class="hljs-params">name: string | <span class="hljs-literal">undefined</span></span>) =&gt; &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>例如，这里 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给 <code>sayHello</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&quot;semlinker&quot;</span>); <br><span class="hljs-title function_">sayHello</span>(<span class="hljs-literal">undefined</span>);<br></code></pre></td></tr></table></figure><p>通过这个示例，你可以凭直觉知道类型 A 和类型 B 联合后的类型是同时接受 A 和 B 值的类型。此外，对于联合类型来说，你可能会遇到以下的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-number">1</span> | <span class="hljs-number">2</span> = <span class="hljs-number">1</span>;<br>type <span class="hljs-title class_">EventNames</span> = <span class="hljs-string">&#x27;click&#x27;</span> | <span class="hljs-string">&#x27;scroll&#x27;</span> | <span class="hljs-string">&#x27;mousemove&#x27;</span>;<br></code></pre></td></tr></table></figure><p>以上示例中的 <code>1</code>、<code>2</code> 或 <code>&#39;click&#39;</code> 被称为字面量类型，用来约束取值只能是某几个值中的一个。</p><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>类型别名用来给一个类型起个新名字。类型别名常用于联合类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Message</span> = string | string[];<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params">message: Message</span>) =&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：类型别名，诚如其名，即我们仅仅是给类型取了一个新的名字，并不是创建了一个新的类型。</strong></p><h1 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h1><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，使用 <code>&amp;</code>定义交叉类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  type <span class="hljs-title class_">Useless</span> = string &amp; number;<br>&#125;<br></code></pre></td></tr></table></figure><p>很显然，如果我们仅仅把原始类型、字面量类型、函数类型等原子类型合并成交叉类型，是没有任何用处的，因为任何类型都不能满足同时属于多种原子类型，比如既是 string 类型又是 number 类型。因此，在上述的代码中，类型别名 Useless 的类型就是个 never。</p><p>交叉类型真正的用武之地就是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型，如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">IntersectionType</span> = &#123; <span class="hljs-attr">id</span>: number; <span class="hljs-attr">name</span>: string; &#125; &amp; &#123; <span class="hljs-attr">age</span>: number &#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">mixed</span>: <span class="hljs-title class_">IntersectionType</span> = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们通过交叉类型，使得 IntersectionType 同时拥有了 id、name、age 所有属性，这里我们可以试着将合并接口类型理解为求并集。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这里，我们来发散思考一下：如果合并的多个接口类型存在同名属性会是什么效果呢？</p><p>如果同名属性的类型不兼容，比如上面示例中两个接口类型同名的 name 属性类型一个是 number，另一个是 string，合并后，name 属性的类型就是 number 和 string 两个原子类型的交叉类型，即 never，如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">IntersectionTypeConfict</span> = &#123; <span class="hljs-attr">id</span>: number; <span class="hljs-attr">name</span>: string; &#125; <br>&amp; &#123; <span class="hljs-attr">age</span>: number; <span class="hljs-attr">name</span>: number; &#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">mixedConflict</span>: <span class="hljs-title class_">IntersectionTypeConfict</span> = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// ts(2322) 错误，&#x27;number&#x27; 类型不能赋给 &#x27;never&#x27; 类型</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>此时，我们赋予 mixedConflict 任意类型的 name 属性值都会提示类型错误。而如果我们不设置 name 属性，又会提示一个缺少必选的 name 属性的错误。在这种情况下，就意味着上述代码中交叉出来的 IntersectionTypeConfict 类型是一个无用类型。</p><p>如果同名属性的类型兼容，比如一个是 number，另一个是 number 的子类型、数字字面量类型，合并后 name 属性的类型就是两者中的子类型。</p><p>如下所示示例中 name 属性的类型就是数字字面量类型 2，因此，我们不能把任何非 2 之外的值赋予 name 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">IntersectionTypeConfict</span> = &#123; <span class="hljs-attr">id</span>: number; <span class="hljs-attr">name</span>: <span class="hljs-number">2</span>; &#125; <br>&amp; &#123; <span class="hljs-attr">age</span>: number; <span class="hljs-attr">name</span>: number; &#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">mixedConflict</span>: <span class="hljs-title class_">IntersectionTypeConfict</span> = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// ok</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-number">2</span><br>&#125;;<br>mixedConflict = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-number">22</span>, <span class="hljs-comment">// &#x27;22&#x27; 类型不能赋给 &#x27;2&#x27; 类型</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>那么如果同名属性是非基本数据类型的话，又会是什么情形。我们来看个具体的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">interface A &#123;<br>  <span class="hljs-attr">x</span>:&#123;<span class="hljs-attr">d</span>:<span class="hljs-literal">true</span>&#125;,<br>&#125;<br>interface B &#123;<br>  <span class="hljs-attr">x</span>:&#123;<span class="hljs-attr">e</span>:string&#125;,<br>&#125;<br>interface C &#123;<br>  <span class="hljs-attr">x</span>:&#123;<span class="hljs-attr">f</span>:number&#125;,<br>&#125;<br>type <span class="hljs-variable constant_">ABC</span> = A &amp; B &amp; C<br><span class="hljs-keyword">let</span> <span class="hljs-attr">abc</span>:<span class="hljs-variable constant_">ABC</span> = &#123;<br>  <span class="hljs-attr">x</span>:&#123;<br>    <span class="hljs-attr">d</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">e</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">f</span>:<span class="hljs-number">666</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码成功运行后，会输出以下结果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfdcc823c6ce4f96b87ebec63bcce2f1~tplv-k3u1fbpfcp-watermark.awebp" alt="1634261312(1).png"></p><p>由上图可知，在混入多个类型时，若存在相同的成员，且<strong>成员类型为非基本数据类型</strong>，那么是可以成功合并。</p><h1 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h1><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p><h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于[对类的一部分行为进行抽象]以外，也常用于对「对象的形状（Shape）」进行描述。</p><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: string;<br>    <span class="hljs-attr">age</span>: number;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p><p>接口一般首字母大写。</p><p>定义的变量比接口少了一些属性是不允许的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: string;<br>    <span class="hljs-attr">age</span>: number;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// index.ts(6,5): error TS2322: Type &#x27;&#123; name: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="hljs-comment">//   Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27;.</span><br></code></pre></td></tr></table></figure><p>多一些属性也是不允许的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: string;<br>    <span class="hljs-attr">age</span>: number;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// index.ts(9,5): error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="hljs-comment">//   Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.</span><br></code></pre></td></tr></table></figure><p>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p><h2 id="可选-只读属性"><a href="#可选-只读属性" class="headerlink" title="可选 | 只读属性"></a>可选 | 只读属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>  readonly <span class="hljs-attr">name</span>: string;<br>  age?: number;<br>&#125;<br></code></pre></td></tr></table></figure><p>只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">ro</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;number&gt; = a;<br>ro[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>; <span class="hljs-comment">// error!</span><br>ro.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// error!</span><br>ro.<span class="hljs-property">length</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// error!</span><br>a = ro; <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure><h2 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h2><p>有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 <strong>索引签名</strong> 的形式来满足上述要求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: string;<br>    age?: number;<br>    [<span class="hljs-attr">propName</span>: string]: any;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: string;<br>    age?: number;<br>    [<span class="hljs-attr">propName</span>: string]: string;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><br><span class="hljs-comment">// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="hljs-comment">//   Index signatures are incompatible.</span><br><span class="hljs-comment">//     Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.</span><br><span class="hljs-comment">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></code></pre></td></tr></table></figure><p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p><p>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code> 的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合。</p><p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: string;<br>    age?: number; <span class="hljs-comment">// 这里真实的类型应该为：number | undefined</span><br>    [<span class="hljs-attr">propName</span>: string]: string | number | <span class="hljs-literal">undefined</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="鸭式辨型法"><a href="#鸭式辨型法" class="headerlink" title="鸭式辨型法"></a>鸭式辨型法</h2><p>所谓的<strong>鸭式辨型法</strong>就是 <code>像鸭子一样走路并且嘎嘎叫的就叫鸭子</code>，即具有鸭子特征的认为它就是鸭子，也就是通过制定规则来判定对象是否实现这个接口。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">LabeledValue</span> &#123;<br>  <span class="hljs-attr">label</span>: string;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labeledObj: LabeledValue</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labeledObj.<span class="hljs-property">label</span>);<br>&#125;<br><span class="hljs-keyword">let</span> myObj = &#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;;<br><span class="hljs-title function_">printLabel</span>(myObj); <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">LabeledValue</span> &#123;<br>  <span class="hljs-attr">label</span>: string;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labeledObj: LabeledValue</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labeledObj.<span class="hljs-property">label</span>);<br>&#125;<br><span class="hljs-title function_">printLabel</span>(&#123; <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Size 10 Object&quot;</span> &#125;); <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>上面代码，在参数里写对象就相当于是直接给 <code>labeledObj</code>赋值，这个对象有严格的类型定义，所以不能多参或少参。而当你在外面将该对象用另一个变量 <code>myObj</code>接收，<code>myObj</code>不会经过额外属性检查，但会根据类型推论为 <code>let myObj: &#123; size: number; label: string &#125; = &#123; size: 10, label: &quot;Size 10 Object&quot; &#125;;</code>，然后将这个 <code>myObj</code>再赋值给 <code>labeledObj</code>，此时根据类型的兼容性，两种类型对象，参照<strong>鸭式辨型法</strong>，因为都具有 <code>label</code>属性，所以被认定为两个相同，故而可以用此法来绕开多余的类型检查。</p><h2 id="绕开额外属性检查的方式"><a href="#绕开额外属性检查的方式" class="headerlink" title="绕开额外属性检查的方式"></a>绕开额外属性检查的方式</h2><h3 id="鸭式辨型法-1"><a href="#鸭式辨型法-1" class="headerlink" title="鸭式辨型法"></a>鸭式辨型法</h3><p>如上例子所示</p><h3 id="类型断言-1"><a href="#类型断言-1" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言的意义就等同于你在告诉程序，你很清楚自己在做什么，此时程序自然就不会再进行额外的属性检查了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Props</span> &#123; <br>  <span class="hljs-attr">name</span>: string; <br>  <span class="hljs-attr">age</span>: number; <br>  money?: number;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Props</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;兔神&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">money</span>: -<span class="hljs-number">100000</span>,<br>  <span class="hljs-attr">girl</span>: <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">Props</span>; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><h3 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Props</span> &#123; <br>  <span class="hljs-attr">name</span>: string; <br>  <span class="hljs-attr">age</span>: number; <br>  money?: number;<br>  [<span class="hljs-attr">key</span>: string]: any;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Props</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;兔神&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">money</span>: -<span class="hljs-number">100000</span>,<br>  <span class="hljs-attr">girl</span>: <span class="hljs-literal">false</span><br>&#125;; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><h1 id="接口与类型别名的区别"><a href="#接口与类型别名的区别" class="headerlink" title="接口与类型别名的区别"></a>接口与类型别名的区别</h1><p>实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。</p><blockquote><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 而接口的作用就是为这些类型命名和为你的代码或第三方代码定义数据模型。</p></blockquote><blockquote><p>type(类型别名)会给一个类型起个新名字。 type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型。起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。给基本类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p></blockquote><h2 id="Objects-x2F-Functions"><a href="#Objects-x2F-Functions" class="headerlink" title="Objects &#x2F; Functions"></a>Objects &#x2F; Functions</h2><p>两者都可以用来描述对象或函数的类型，但是语法不同。</p><p><strong>Interface</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-attr">x</span>: number;<br>  <span class="hljs-attr">y</span>: number;<br>&#125;<br><br>interface <span class="hljs-title class_">SetPoint</span> &#123;<br>  (<span class="hljs-attr">x</span>: number, <span class="hljs-attr">y</span>: number): <span class="hljs-keyword">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Type alias</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Point</span> = &#123;<br>  <span class="hljs-attr">x</span>: number;<br>  <span class="hljs-attr">y</span>: number;<br>&#125;;<br><br>type <span class="hljs-title class_">SetPoint</span> = <span class="hljs-function">(<span class="hljs-params">x: number, y: number</span>) =&gt;</span> <span class="hljs-keyword">void</span>;<br></code></pre></td></tr></table></figure><h2 id="Other-Types"><a href="#Other-Types" class="headerlink" title="Other Types"></a>Other Types</h2><p>与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// primitive</span><br>type <span class="hljs-title class_">Name</span> = string;<br><br><span class="hljs-comment">// object</span><br>type <span class="hljs-title class_">PartialPointX</span> = &#123; <span class="hljs-attr">x</span>: number; &#125;;<br>type <span class="hljs-title class_">PartialPointY</span> = &#123; <span class="hljs-attr">y</span>: number; &#125;;<br><br><span class="hljs-comment">// union</span><br>type <span class="hljs-title class_">PartialPoint</span> = <span class="hljs-title class_">PartialPointX</span> | <span class="hljs-title class_">PartialPointY</span>;<br><br><span class="hljs-comment">// tuple</span><br>type <span class="hljs-title class_">Data</span> = [number, string];<br><br><span class="hljs-comment">// dom</span><br><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>type B = <span class="hljs-keyword">typeof</span> div;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="接口可以定义多次-类型别名不可以"><a href="#接口可以定义多次-类型别名不可以" class="headerlink" title="接口可以定义多次,类型别名不可以"></a>接口可以定义多次,类型别名不可以</h2><p>与类型别名不同，接口可以定义多次，会被自动合并为单个接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Point</span> &#123; <span class="hljs-attr">x</span>: number; &#125;<br>interface <span class="hljs-title class_">Point</span> &#123; <span class="hljs-attr">y</span>: number; &#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br></code></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>两者的扩展方式不同，但并不互斥。接口可以扩展类型别名，同理，类型别名也可以扩展接口。</p><p>接口的扩展就是继承，通过 <code>extends</code> 来实现。类型别名的扩展就是交叉类型，通过 <code>&amp;</code> 来实现。</p><h3 id="接口扩展接口"><a href="#接口扩展接口" class="headerlink" title="接口扩展接口"></a>接口扩展接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">x</span>: number<br>&#125;<br><br>interface <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">y</span>: number<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型别名扩展类型别名"><a href="#类型别名扩展类型别名" class="headerlink" title="类型别名扩展类型别名"></a>类型别名扩展类型别名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">PointX</span> = &#123;<br>    <span class="hljs-attr">x</span>: number<br>&#125;<br><br>type <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PointX</span> &amp; &#123;<br>    <span class="hljs-attr">y</span>: number<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口扩展类型别名"><a href="#接口扩展类型别名" class="headerlink" title="接口扩展类型别名"></a>接口扩展类型别名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">PointX</span> = &#123;<br>    <span class="hljs-attr">x</span>: number<br>&#125;<br>interface <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">y</span>: number<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型别名扩展接口"><a href="#类型别名扩展接口" class="headerlink" title="类型别名扩展接口"></a>类型别名扩展接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">x</span>: number<br>&#125;<br>type <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PointX</span> &amp; &#123;<br>    <span class="hljs-attr">y</span>: number<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型介绍"><a href="#泛型介绍" class="headerlink" title="泛型介绍"></a>泛型介绍</h2><p>假如让你实现一个函数 <code>identity</code>，函数的参数可以是任何值，返回值就是将参数原样返回，并且其只能接受一个参数，你会怎么做？</p><p>你会觉得这很简单，顺手就写出这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">identity</span> = (<span class="hljs-params">arg</span>) =&gt; arg;<br></code></pre></td></tr></table></figure><p>由于其可以接受任意值，也就是说你的函数的入参和返回值都应该可以是任意类型。 现在让我们给代码增加类型声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">type idBoolean = <span class="hljs-function">(<span class="hljs-params">arg: boolean</span>) =&gt;</span> boolean;<br>type idNumber = <span class="hljs-function">(<span class="hljs-params">arg: number</span>) =&gt;</span> number;<br>type idString = <span class="hljs-function">(<span class="hljs-params">arg: string</span>) =&gt;</span> string;<br>...<br></code></pre></td></tr></table></figure><p>一个笨的方法就像上面那样，也就是说 JS 提供多少种类型，就需要复制多少份代码，然后改下类型签名。这对程序员来说是致命的。这种复制粘贴增加了出错的概率，使得代码难以维护，牵一发而动全身。并且将来 JS 新增新的类型，你仍然需要修改代码，也就是说你的代码<strong>对修改开放</strong>，这样不好。还有一种方式是使用 any 这种“万能语法”。缺点是什么呢？我举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">identity</span>(<span class="hljs-string">&quot;string&quot;</span>).<span class="hljs-property">length</span>; <span class="hljs-comment">// ok</span><br><span class="hljs-title function_">identity</span>(<span class="hljs-string">&quot;string&quot;</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// ok</span><br><span class="hljs-title function_">identity</span>(<span class="hljs-literal">null</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// ok</span><br>...<br></code></pre></td></tr></table></figure><p>如果你使用 any 的话，怎么写都是 ok 的， 这就丧失了类型检查的效果。实际上我知道我传给你的是 string，返回来的也一定是 string，而 string 上没有 toFixed 方法，因此需要报错才是我想要的。也就是说我真正想要的效果是：<code>当我用到id的时候，你根据我传给你的类型进行推导</code>。比如我传入的是 string，但是使用了 number 上的方法，你就应该报错。</p><p>为了解决上面的这些问题，我们<strong>使用泛型对上面的代码进行重构</strong>。和我们的定义不同，这里用了一个 类型 T，这个 <strong>T 是一个抽象类型，只有在调用的时候才确定它的值</strong>，这就不用我们复制粘贴无数份代码了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>T</code> 代表 <strong>Type</strong>，在定义泛型时通常用作第一个类型变量名称。但实际上 <code>T</code> 可以用任何有效名称代替。除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p><ul><li>K（Key）：表示对象中的键类型；</li><li>V（Value）：表示对象中的值类型；</li><li>E（Element）：表示元素类型。</li></ul><p>来张图片帮助你理解 <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba87e7a8921144faa4e8dd7dc8e92916~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p><p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> identity &lt;T, U&gt;(<span class="hljs-attr">value</span>: T, <span class="hljs-attr">message</span>: U) : T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(identity&lt;<span class="hljs-title class_">Number</span>, string&gt;(<span class="hljs-number">68</span>, <span class="hljs-string">&quot;Semlinker&quot;</span>));<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2bcfb0e8414282b606705c6a0385e0~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p><p>除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> identity &lt;T, U&gt;(<span class="hljs-attr">value</span>: T, <span class="hljs-attr">message</span>: U) : T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">identity</span>(<span class="hljs-number">68</span>, <span class="hljs-string">&quot;Semlinker&quot;</span>));<br></code></pre></td></tr></table></figure><p>对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 T 和 U，而不需要开发人员显式指定它们。</p><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>假如我想打印出参数的 size 属性呢？如果完全不进行约束 TS 是会报错的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> trace&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">size</span>); <span class="hljs-comment">// Error: Property &#x27;size doesn&#x27;t exist on type &#x27;T&#x27;</span><br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错的原因在于 T 理论上是可以是任何类型的，不同于 any，你不管使用它的什么属性或者方法都会报错（除非这个属性和方法是所有集合共有的）。那么直观的想法是限定传给 trace 函数的<strong>参数类型</strong>应该有 size 类型，这样就不会报错了。如何去表达这个<strong>类型约束</strong>的点呢？实现这个需求的关键在于使用类型约束。 使用 extends 关键字可以做到这一点。简单来说就是你定义一个类型，然后让 T 实现这个接口即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Sizeable</span> &#123;<br>  <span class="hljs-attr">size</span>: number;<br>&#125;<br><span class="hljs-keyword">function</span> trace&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sizeable</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">size</span>);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>有的人可能说我直接将 Trace 的参数限定为 Sizeable 类型可以么？如果你这么做，会有类型丢失的风险，详情可以参考这篇文章<a href="https://juliangaramendy.dev/blog/when-ts-generics">A use case for TypeScript Generics</a>。</p><h2 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h2><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者可以更好的学习其它的工具类型。</p><h3 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h3><p>typeof 的主要用途是在类型上下文中获取变量或者属性的类型，下面我们通过一个具体示例来理解一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">sem</span>: <span class="hljs-title class_">Person</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;semlinker&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br>type <span class="hljs-title class_">Sem</span> = <span class="hljs-keyword">typeof</span> sem; <span class="hljs-comment">// type Sem = Person</span><br></code></pre></td></tr></table></figure><p>在上面代码中，我们通过 <code>typeof</code> 操作符获取 sem 变量的类型并赋值给 Sem 类型变量，之后我们就可以使用 Sem 类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">lolo</span>: <span class="hljs-title class_">Sem</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lolo&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">5</span> &#125;<br></code></pre></td></tr></table></figure><p>你也可以对嵌套对象执行相同的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Message</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;jimmy&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>      <span class="hljs-attr">province</span>: <span class="hljs-string">&#x27;四川&#x27;</span>,<br>      <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;成都&#x27;</span>   <br>    &#125;<br>&#125;<br>type message = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Message</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> type message = &#123;</span><br><span class="hljs-comment">    name: string;</span><br><span class="hljs-comment">    age: number;</span><br><span class="hljs-comment">    address: &#123;</span><br><span class="hljs-comment">        province: string;</span><br><span class="hljs-comment">        city: string;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>此外，<code>typeof</code> 操作符除了可以获取对象的结构类型之外，它也可以用来获取函数对象的类型，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toArray</span>(<span class="hljs-params">x: number</span>): <span class="hljs-title class_">Array</span>&lt;number&gt; &#123;<br>  <span class="hljs-keyword">return</span> [x];<br>&#125;<br>type <span class="hljs-title class_">Func</span> = <span class="hljs-keyword">typeof</span> toArray; <span class="hljs-comment">// -&gt; (x: number) =&gt; number[]</span><br></code></pre></td></tr></table></figure><h3 id="2-keyof"><a href="#2-keyof" class="headerlink" title="2.keyof"></a>2.keyof</h3><p><code>keyof</code> 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br><br>type <span class="hljs-variable constant_">K1</span> = keyof <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// &quot;name&quot; | &quot;age&quot;</span><br>type <span class="hljs-variable constant_">K2</span> = keyof <span class="hljs-title class_">Person</span>[]; <span class="hljs-comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; </span><br>type <span class="hljs-variable constant_">K3</span> = keyof &#123; [<span class="hljs-attr">x</span>: string]: <span class="hljs-title class_">Person</span> &#125;;  <span class="hljs-comment">// string | number</span><br></code></pre></td></tr></table></figure><p>在 TypeScript 中支持两种索引签名，数字索引和字符串索引：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">StringArray</span> &#123;<br>  <span class="hljs-comment">// 字符串索引 -&gt; keyof StringArray =&gt; string | number</span><br>  [<span class="hljs-attr">index</span>: string]: string; <br>&#125;<br><br>interface <span class="hljs-title class_">StringArray1</span> &#123;<br>  <span class="hljs-comment">// 数字索引 -&gt; keyof StringArray1 =&gt; number</span><br>  [<span class="hljs-attr">index</span>: number]: string;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了同时支持两种索引类型，就得要求数字索引的返回值必须是字符串索引返回值的子类。<strong>其中的原因就是当使用数值索引时，JavaScript 在执行索引操作时，会先把数值索引先转换为字符串索引</strong>。所以 <code>keyof &#123; [x: string]: Person &#125;</code> 的结果会返回 <code>string | number</code>。</p><p>keyof也支持基本数据类型：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> K1: keyof<span class="hljs-built_in"> boolean</span>; // <span class="hljs-keyword">let</span> K1: <span class="hljs-string">&quot;valueOf&quot;</span><br><span class="hljs-keyword">let</span> K2: keyof<span class="hljs-built_in"> number</span>; // <span class="hljs-keyword">let</span> K2: <span class="hljs-string">&quot;toString&quot;</span> | <span class="hljs-string">&quot;toFixed&quot;</span> | <span class="hljs-string">&quot;toExponential&quot;</span> | ...<br><span class="hljs-keyword">let</span> K3: keyof symbol; // <span class="hljs-keyword">let</span> K1: <span class="hljs-string">&quot;valueOf&quot;</span><br></code></pre></td></tr></table></figure><h4 id="keyof-的作用"><a href="#keyof-的作用" class="headerlink" title="keyof 的作用"></a>keyof 的作用</h4><p>JavaScript 是一种高度动态的语言。有时在静态类型系统中捕获某些操作的语义可能会很棘手。以一个简单的 <code>prop</code> 函数为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">prop</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数接收 obj 和 key 两个参数，并返回对应属性的值。对象上的不同属性，可以具有完全不同的类型，我们甚至不知道 obj 对象长什么样。</p><p>那么在 TypeScript 中如何定义上面的 <code>prop</code> 函数呢？我们来尝试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">prop</span>(<span class="hljs-params">obj: object, key: string</span>) &#123;<br>  <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面代码中，为了避免调用 prop 函数时传入错误的参数类型，我们为 obj 和 key 参数设置了类型，分别为 <code>&#123;&#125;</code> 和 <code>string</code> 类型。然而，事情并没有那么简单。针对上述的代码，TypeScript 编译器会输出以下错误信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Element</span> implicitly has an <span class="hljs-string">&#x27;any&#x27;</span> type because expression <span class="hljs-keyword">of</span> type <span class="hljs-string">&#x27;string&#x27;</span> can<span class="hljs-string">&#x27;t be used to index type &#x27;</span>&#123;&#125;<span class="hljs-string">&#x27;.</span><br></code></pre></td></tr></table></figure><p>元素隐式地拥有 <code>any</code> 类型，因为 <code>string</code> 类型不能被用于索引 <code>&#123;&#125;</code> 类型。要解决这个问题，你可以使用以下非常暴力的方案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">prop</span>(<span class="hljs-params">obj: object, key: string</span>) &#123;<br>  <span class="hljs-keyword">return</span> (obj <span class="hljs-keyword">as</span> any)[key];<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显该方案并不是一个好的方案，我们来回顾一下 <code>prop</code> 函数的作用，该函数用于获取某个对象中指定属性的属性值。因此我们期望用户输入的属性是对象上已存在的属性，那么如何限制属性名的范围呢？这时我们可以利用本文的主角 <code>keyof</code> 操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> prop&lt;T <span class="hljs-keyword">extends</span> object, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K) &#123;<br>  <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上代码中，我们使用了 TypeScript 的泛型和泛型约束。<strong>首先定义了 T 类型并使用 <code>extends</code> 关键字约束该类型必须是 object 类型的子类型，然后使用 <code>keyof</code> 操作符获取 T 类型的所有键，其返回类型是联合类型，最后利用 <code>extends</code> 关键字约束 K 类型必须为 <code>keyof T</code> 联合类型的子类型。</strong>  是骡子是马拉出来遛遛就知道了，我们来实际测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Todo</span> = &#123;<br>  <span class="hljs-attr">id</span>: number;<br>  <span class="hljs-attr">text</span>: string;<br>  <span class="hljs-attr">done</span>: boolean;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">todo</span>: <span class="hljs-title class_">Todo</span> = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Learn TypeScript keyof&quot;</span>,<br>  <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">function</span> prop&lt;T <span class="hljs-keyword">extends</span> object, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K) &#123;<br>  <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br><br><span class="hljs-keyword">const</span> id = <span class="hljs-title function_">prop</span>(todo, <span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// const id: number</span><br><span class="hljs-keyword">const</span> text = <span class="hljs-title function_">prop</span>(todo, <span class="hljs-string">&quot;text&quot;</span>); <span class="hljs-comment">// const text: string</span><br><span class="hljs-keyword">const</span> done = <span class="hljs-title function_">prop</span>(todo, <span class="hljs-string">&quot;done&quot;</span>); <span class="hljs-comment">// const done: boolean</span><br></code></pre></td></tr></table></figure><p>很明显使用泛型，重新定义后的 <code>prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K)</code> 函数，已经可以正确地推导出指定键对应的类型。那么当访问 todo 对象上不存在的属性时，会出现什么情况？比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date = <span class="hljs-title function_">prop</span>(todo, <span class="hljs-string">&quot;date&quot;</span>);<br></code></pre></td></tr></table></figure><p>对于上述代码，TypeScript 编译器会提示以下错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Argument</span> <span class="hljs-keyword">of</span> type <span class="hljs-string">&#x27;&quot;date&quot;&#x27;</span> is not assignable to parameter <span class="hljs-keyword">of</span> type <span class="hljs-string">&#x27;&quot;id&quot; | &quot;text&quot; | &quot;done&quot;&#x27;</span>.<br></code></pre></td></tr></table></figure><p>这就阻止我们尝试读取不存在的属性。</p><h3 id="3-in"><a href="#3-in" class="headerlink" title="3.in"></a>3.in</h3><p><code>in</code> 用来遍历枚举类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Keys</span> = <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span><br><br>type <span class="hljs-title class_">Obj</span> =  &#123;<br>  [p <span class="hljs-keyword">in</span> <span class="hljs-title class_">Keys</span>]: any<br>&#125; <span class="hljs-comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span><br></code></pre></td></tr></table></figure><h3 id="4-infer"><a href="#4-infer" class="headerlink" title="4.infer"></a>4.infer</h3><p>在条件类型语句中，可以用 <code>infer</code> 声明一个类型变量并且对它进行使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">ReturnType</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> (<br>  ...<span class="hljs-attr">args</span>: any[]<br>) =&gt; infer R ? R : any;<br></code></pre></td></tr></table></figure><p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><h3 id="5-extends"><a href="#5-extends" class="headerlink" title="5.extends"></a>5.extends</h3><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Lengthwise</span> &#123;<br>  <span class="hljs-attr">length</span>: number;<br>&#125;<br><br><span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Lengthwise</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">loggingIdentity</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// Error, number doesn&#x27;t have a .length property</span><br></code></pre></td></tr></table></figure><p>这时我们需要传入符合约束类型的值，必须包含length属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">loggingIdentity</span>(&#123;<span class="hljs-attr">length</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>在实际开发中，我们经常能遇到这样的场景，在对象中获取一些属性的值，然后建立对应的集合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;musion&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">35</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getValues</span>(<span class="hljs-params">person: any, keys: string[]</span>) &#123;<br>    <span class="hljs-keyword">return</span> keys.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> person[key])<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getValues</span>(person, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>])) <span class="hljs-comment">// [&#x27;musion&#x27;, 35]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getValues</span>(person, [<span class="hljs-string">&#x27;gender&#x27;</span>])) <span class="hljs-comment">// [undefined]</span><br></code></pre></td></tr></table></figure><p>在上述例子中，可以看到getValues(persion, [‘gender’])打印出来的是[undefined]，但是ts编译器并没有给出报错信息，那么如何使用ts对这种模式进行类型约束呢？这里就要用到了索引类型,改造一下getValues函数，通过 <strong>索引类型查询</strong>和 <strong>索引访问</strong> 操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">T[K]表示对象T的属性K所表示的类型，在下述例子中，T[K][] 表示变量T取属性K的值的数组<br><br><span class="hljs-keyword">function</span> getValues&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">person</span>: T, <span class="hljs-attr">keys</span>: K[]): T[K][] &#123;<br>  <span class="hljs-keyword">return</span> keys.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> person[key]);<br>&#125;<br><br>interface <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: string;<br>    <span class="hljs-attr">age</span>: number;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;musion&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">35</span><br>&#125;<br><br><span class="hljs-title function_">getValues</span>(person, [<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-comment">// [&#x27;musion&#x27;]</span><br><span class="hljs-title function_">getValues</span>(person, [<span class="hljs-string">&#x27;gender&#x27;</span>]) <span class="hljs-comment">// 报错：</span><br><span class="hljs-comment">// Argument of Type &#x27;&quot;gender&quot;[]&#x27; is not assignable to parameter of type &#x27;(&quot;name&quot; | &quot;age&quot;)[]&#x27;.</span><br><span class="hljs-comment">// Type &quot;gender&quot; is not assignable to type &quot;name&quot; | &quot;age&quot;.</span><br></code></pre></td></tr></table></figure><p>编译器会检查传入的值是否是Person的一部分。通过下面的概念来理解上面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 通过[]索引类型访问操作符, 我们就能得到某个索引的类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>:string;<br>    <span class="hljs-attr">age</span>:number;<br> &#125;<br> type <span class="hljs-title class_">MyType</span> = <span class="hljs-title class_">Person</span>[<span class="hljs-string">&#x27;name&#x27;</span>];  <span class="hljs-comment">//Person中name的类型为string type MyType = string</span><br></code></pre></td></tr></table></figure><p>介绍完概念之后，应该就可以理解上面的代码了。首先看泛型，这里有T和K两种类型，根据类型推断，第一个参数person就是person，类型会被推断为Person。而第二个数组参数的类型推断（K extends keyof T），keyof关键字可以获取T，也就是Person的所有属性名，即[‘name’, ‘age’]。而extends关键字让泛型K继承了Person的所有属性名，即[‘name’, ‘age’]。这三个特性组合保证了代码的动态性和准确性，也让代码提示变得更加丰富了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getValues</span>(person, [<span class="hljs-string">&#x27;gender&#x27;</span>]) <span class="hljs-comment">// 报错：</span><br><span class="hljs-comment">// Argument of Type &#x27;&quot;gender&quot;[]&#x27; is not assignable to parameter of type &#x27;(&quot;name&quot; | &quot;age&quot;)[]&#x27;.</span><br><span class="hljs-comment">// Type &quot;gender&quot; is not assignable to type &quot;name&quot; | &quot;age&quot;.</span><br></code></pre></td></tr></table></figure><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><blockquote><p>根据旧的类型创建出新的类型, 我们称之为映射类型</p></blockquote><p>比如我们定义一个接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">TestInterface</span>&#123;<br>    <span class="hljs-attr">name</span>:string,<br>    <span class="hljs-attr">age</span>:number<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把上面定义的接口里面的属性全部变成可选</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 我们可以通过+/-来指定添加还是删除</span><br><br>type <span class="hljs-title class_">OptionalTestInterface</span>&lt;T&gt; = &#123;<br>  [p <span class="hljs-keyword">in</span> keyof T]+?:T[p]<br>&#125;<br><br>type newTestInterface = <span class="hljs-title class_">OptionalTestInterface</span>&lt;<span class="hljs-title class_">TestInterface</span>&gt;<br><span class="hljs-comment">// type newTestInterface = &#123;</span><br><span class="hljs-comment">//    name?:string,</span><br><span class="hljs-comment">//    age?:number</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>比如我们再加上只读</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">OptionalTestInterface</span>&lt;T&gt; = &#123;<br> +readonly [p <span class="hljs-keyword">in</span> keyof T]+?:T[p]<br>&#125;<br><br>type newTestInterface = <span class="hljs-title class_">OptionalTestInterface</span>&lt;<span class="hljs-title class_">TestInterface</span>&gt;<br><span class="hljs-comment">// type newTestInterface = &#123;</span><br><span class="hljs-comment">//   readonly name?:string,</span><br><span class="hljs-comment">//   readonly age?:number</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>由于生成只读属性和可选属性比较常用, 所以TS内部已经给我们提供了现成的实现 Readonly &#x2F; Partial,会面内置的工具类型会介绍.</p><p><strong>内置的工具类型</strong></p><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><blockquote><p><code>Partial&lt;T&gt;</code> 将类型的属性变成可选</p></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Partial</span>&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];<br>&#125;;<br></code></pre></td></tr></table></figure><p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值的类。中间的 <code>?</code> 号，用于将所有属性变为可选。</p><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">UserInfo</span> &#123;<br>    <span class="hljs-attr">id</span>: string;<br>    <span class="hljs-attr">name</span>: string;<br>&#125;<br><span class="hljs-comment">// error：Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;UserInfo&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">xiaoming</span>: <span class="hljs-title class_">UserInfo</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用  <code>Partial&lt;T&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">NewUserInfo</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">UserInfo</span>&gt;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">xiaoming</span>: <span class="hljs-title class_">NewUserInfo</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个  NewUserInfo 就相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">NewUserInfo</span> &#123;<br>    id?: string;<br>    name?: string;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是 <code>Partial&lt;T&gt;</code> 有个局限性，就是只支持处理第一层的属性，如果我的接口定义是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">UserInfo</span> &#123;<br>    <span class="hljs-attr">id</span>: string;<br>    <span class="hljs-attr">name</span>: string;<br>    <span class="hljs-attr">fruits</span>: &#123;<br>        <span class="hljs-attr">appleNumber</span>: number;<br>        <span class="hljs-attr">orangeNumber</span>: number;<br>    &#125;<br>&#125;<br><br>type <span class="hljs-title class_">NewUserInfo</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">UserInfo</span>&gt;;<br><br><span class="hljs-comment">// Property &#x27;appleNumber&#x27; is missing in type &#x27;&#123; orangeNumber: number; &#125;&#x27; but required in type &#x27;&#123; appleNumber: number; orangeNumber: number; &#125;&#x27;.</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">xiaoming</span>: <span class="hljs-title class_">NewUserInfo</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>    <span class="hljs-attr">fruits</span>: &#123;<br>        <span class="hljs-attr">orangeNumber</span>: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，第二层以后就不会处理了，如果要处理多层，就可以自己实现</p><h4 id="DeepPartial"><a href="#DeepPartial" class="headerlink" title="DeepPartial"></a>DeepPartial</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">DeepPartial</span>&lt;T&gt; = &#123;<br>     <span class="hljs-comment">// 如果是 object，则递归类型</span><br>    [U <span class="hljs-keyword">in</span> keyof T]?: T[U] <span class="hljs-keyword">extends</span> object<br>      ? <span class="hljs-title class_">DeepPartial</span>&lt;T[U]&gt;<br>      : T[U]<br>&#125;;<br><br>type <span class="hljs-title class_">PartialedWindow</span> = <span class="hljs-title class_">DeepPartial</span>&lt;T&gt;; <span class="hljs-comment">// 现在T上所有属性都变成了可选啦</span><br></code></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><blockquote><p>Required将类型的属性变成必选</p></blockquote><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Required</span>&lt;T&gt; = &#123; <br>    [P <span class="hljs-keyword">in</span> keyof T]-?: T[P] <br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>其中 <code>-?</code> 是代表移除 <code>?</code> 这个 modifier 的标识</strong>。再拓展一下，除了可以应用于 <code>?</code> 这个 modifiers ，还有应用在 <code>readonly</code> ，比如 <code>Readonly&lt;T&gt;</code> 这个类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Readonly</span>&lt;T&gt; = &#123;<br>    readonly [p <span class="hljs-keyword">in</span> keyof T]: T[p];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><blockquote><p><code>Readonly&lt;T&gt;</code> 的作用是将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值。</p></blockquote><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Readonly</span>&lt;T&gt; = &#123;<br> readonly [P <span class="hljs-keyword">in</span> keyof T]: T[P];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Todo</span> &#123;<br> <span class="hljs-attr">title</span>: string;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">todo</span>: <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-title class_">Todo</span>&gt; = &#123;<br> <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Delete inactive users&quot;</span><br>&#125;;<br><br>todo.<span class="hljs-property">title</span> = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// Error: cannot reassign a readonly property</span><br></code></pre></td></tr></table></figure><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><blockquote><p>Pick 从某个类型中挑出一些属性出来</p></blockquote><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Pick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;<br>    [P <span class="hljs-keyword">in</span> K]: T[P];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="举例说明-2"><a href="#举例说明-2" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Todo</span> &#123;<br>  <span class="hljs-attr">title</span>: string;<br>  <span class="hljs-attr">description</span>: string;<br>  <span class="hljs-attr">completed</span>: boolean;<br>&#125;<br><br>type <span class="hljs-title class_">TodoPreview</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">Todo</span>, <span class="hljs-string">&quot;title&quot;</span> | <span class="hljs-string">&quot;completed&quot;</span>&gt;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">todo</span>: <span class="hljs-title class_">TodoPreview</span> = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Clean room&quot;</span>,<br>  <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到 NewUserInfo 中就只有个 name 的属性了。</p><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><blockquote><p><code>Record&lt;K extends keyof any, T&gt;</code> 的作用是将 <code>K</code> 中所有的属性的值转化为 <code>T</code> 类型。</p></blockquote><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Record</span>&lt;K <span class="hljs-keyword">extends</span> keyof any, T&gt; = &#123;<br>    [P <span class="hljs-keyword">in</span> K]: T;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="举例说明-3"><a href="#举例说明-3" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">PageInfo</span> &#123;<br>  <span class="hljs-attr">title</span>: string;<br>&#125;<br><br>type <span class="hljs-title class_">Page</span> = <span class="hljs-string">&quot;home&quot;</span> | <span class="hljs-string">&quot;about&quot;</span> | <span class="hljs-string">&quot;contact&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Page</span>, <span class="hljs-title class_">PageInfo</span>&gt; = &#123;<br>  <span class="hljs-attr">about</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;about&quot;</span> &#125;,<br>  <span class="hljs-attr">contact</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;contact&quot;</span> &#125;,<br>  <span class="hljs-attr">home</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;home&quot;</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><blockquote><p>用来得到一个函数的返回值类型</p></blockquote><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">ReturnType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: any[]) =&gt; any&gt; = T <span class="hljs-keyword">extends</span> (<br>  ...<span class="hljs-attr">args</span>: any[]<br>) =&gt; infer R<br>  ? R<br>  : any;<br></code></pre></td></tr></table></figure><p><strong><code>infer</code>在这里用于提取函数类型的返回值类型</strong>。<code>ReturnType&lt;T&gt;</code> 只是将 infer R 从参数位置移动到返回值位置，因此此时 R 即是表示待推断的返回值类型。</p><h4 id="举例说明-4"><a href="#举例说明-4" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Func</span> = <span class="hljs-function">(<span class="hljs-params">value: number</span>) =&gt;</span> string;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-title class_">Func</span>&gt; = <span class="hljs-string">&quot;1&quot;</span>;<br></code></pre></td></tr></table></figure><p><code>ReturnType</code>获取到 <code>Func</code> 的返回值类型为 <code>string</code>，所以，<code>foo</code> 也就只能被赋值为字符串了。</p><h3 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h3><blockquote><p><code>Exclude&lt;T, U&gt;</code> 的作用是将某个类型中属于另一个的类型移除掉。</p></blockquote><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Exclude</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? never : T;<br></code></pre></td></tr></table></figure><p>如果 <code>T</code> 能赋值给 <code>U</code> 类型的话，那么就会返回 <code>never</code> 类型，否则返回 <code>T</code> 类型。最终实现的效果就是将 <code>T</code> 中某些属于 <code>U</code> 的类型移除掉。</p><h4 id="举例说明-5"><a href="#举例说明-5" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>&gt;; <span class="hljs-comment">// &quot;b&quot; | &quot;c&quot;</span><br>type <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span>&gt;; <span class="hljs-comment">// &quot;c&quot;</span><br>type <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Exclude</span>&lt;string | number | (<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span>), <span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// string | number</span><br></code></pre></td></tr></table></figure><h3 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h3><blockquote><p><code>Extract&lt;T, U&gt;</code> 的作用是从 <code>T</code> 中提取出 <code>U</code>。</p></blockquote><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Extract</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? T : never;<br></code></pre></td></tr></table></figure><h4 id="举例说明-6"><a href="#举例说明-6" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;f&quot;</span>&gt;; <span class="hljs-comment">// &quot;a&quot;</span><br>type <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Extract</span>&lt;string | number | (<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span>), <span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// () =&gt;void</span><br></code></pre></td></tr></table></figure><h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h3><blockquote><p><code>Omit&lt;T, K extends keyof any&gt;</code> 的作用是使用 <code>T</code> 类型中除了 <code>K</code> 类型的所有属性，来构造一个新的类型。</p></blockquote><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Omit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof any&gt; = <span class="hljs-title class_">Pick</span>&lt;T, <span class="hljs-title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;<br></code></pre></td></tr></table></figure><h4 id="举例说明-7"><a href="#举例说明-7" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Todo</span> &#123;<br>  <span class="hljs-attr">title</span>: string;<br>  <span class="hljs-attr">description</span>: string;<br>  <span class="hljs-attr">completed</span>: boolean;<br>&#125;<br><br>type <span class="hljs-title class_">TodoPreview</span> = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">Todo</span>, <span class="hljs-string">&quot;description&quot;</span>&gt;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">todo</span>: <span class="hljs-title class_">TodoPreview</span> = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Clean room&quot;</span>,<br>  <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h3><blockquote><p><code>NonNullable&lt;T&gt;</code> 的作用是用来过滤类型中的 <code>null</code> 及 <code>undefined</code> 类型。</p></blockquote><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">NonNullable</span>&lt;T&gt; = T extendsnull | <span class="hljs-literal">undefined</span> ? never : T;<br></code></pre></td></tr></table></figure><h4 id="举例说明-8"><a href="#举例说明-8" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">NonNullable</span>&lt;string | number | <span class="hljs-literal">undefined</span>&gt;; <span class="hljs-comment">// string | number</span><br>type <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">NonNullable</span>&lt;string[] | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>&gt;; <span class="hljs-comment">// string[]</span><br></code></pre></td></tr></table></figure><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><blockquote><p><code>Parameters&lt;T&gt;</code> 的作用是用于获得函数的参数类型组成的元组类型。</p></blockquote><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Parameters</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: any) =&gt; any&gt; = T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: infer P) =&gt; any<br>? P : never;<br></code></pre></td></tr></table></figure><h4 id="举例说明-9"><a href="#举例说明-9" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">type A = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">() =&gt;</span><span class="hljs-keyword">void</span>&gt;; <span class="hljs-comment">// []</span><br>type B = <span class="hljs-title class_">Parameters</span>&lt;typeofArray.<span class="hljs-property">isArray</span>&gt;; <span class="hljs-comment">// [any]</span><br>type C = <span class="hljs-title class_">Parameters</span>&lt;typeofparseInt&gt;; <span class="hljs-comment">// [string, (number | undefined)?]</span><br>type D = <span class="hljs-title class_">Parameters</span>&lt;typeofMath.<span class="hljs-property">max</span>&gt;; <span class="hljs-comment">// number[]</span><br></code></pre></td></tr></table></figure><h1 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h1><h2 id="tsconfig-json介绍"><a href="#tsconfig-json介绍" class="headerlink" title="tsconfig.json介绍"></a>tsconfig.json介绍</h2><p>tsconfig.json 是 TypeScript 项目的配置文件。如果一个目录下存在一个 tsconfig.json 文件，那么往往意味着这个目录就是 TypeScript 项目的根目录。</p><p>tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。</p><h2 id="tsconfig-json-重要字段"><a href="#tsconfig-json-重要字段" class="headerlink" title="tsconfig.json 重要字段"></a>tsconfig.json 重要字段</h2><ul><li>files - 设置要编译的文件的名称；</li><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li><li>compilerOptions - 设置与编译流程相关的选项。</li></ul><h2 id="compilerOptions-选项"><a href="#compilerOptions-选项" class="headerlink" title="compilerOptions 选项"></a>compilerOptions 选项</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>  <br>    <span class="hljs-comment">/* 基本选项 */</span><br>    <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,                       <span class="hljs-comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br>    <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,                  <span class="hljs-comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br>    <span class="hljs-string">&quot;lib&quot;</span>: [],                             <span class="hljs-comment">// 指定要包含在编译中的库文件</span><br>    <span class="hljs-string">&quot;allowJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 允许编译 javascript 文件</span><br>    <span class="hljs-string">&quot;checkJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 报告 javascript 文件中的错误</span><br>    <span class="hljs-string">&quot;jsx&quot;</span>: <span class="hljs-string">&quot;preserve&quot;</span>,                     <span class="hljs-comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br>    <span class="hljs-string">&quot;declaration&quot;</span>: <span class="hljs-literal">true</span>,                   <span class="hljs-comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span><br>    <span class="hljs-string">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,                     <span class="hljs-comment">// 生成相应的 &#x27;.map&#x27; 文件</span><br>    <span class="hljs-string">&quot;outFile&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 将输出文件合并为一个文件</span><br>    <span class="hljs-string">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                        <span class="hljs-comment">// 指定输出目录</span><br>    <span class="hljs-string">&quot;rootDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用来控制输出目录结构 --outDir.</span><br>    <span class="hljs-string">&quot;removeComments&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 删除编译后的所有的注释</span><br>    <span class="hljs-string">&quot;noEmit&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 不生成输出文件</span><br>    <span class="hljs-string">&quot;importHelpers&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 从 tslib 导入辅助工具函数</span><br>    <span class="hljs-string">&quot;isolatedModules&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><br>    <span class="hljs-comment">/* 严格的类型检查选项 */</span><br>    <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 启用所有严格类型检查选项</span><br>    <span class="hljs-string">&quot;noImplicitAny&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 在表达式和声明上有隐含的 any类型时报错</span><br>    <span class="hljs-string">&quot;strictNullChecks&quot;</span>: <span class="hljs-literal">true</span>,              <span class="hljs-comment">// 启用严格的 null 检查</span><br>    <span class="hljs-string">&quot;noImplicitThis&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span><br>    <span class="hljs-string">&quot;alwaysStrict&quot;</span>: <span class="hljs-literal">true</span>,                  <span class="hljs-comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><br>    <span class="hljs-comment">/* 额外的检查 */</span><br>    <span class="hljs-string">&quot;noUnusedLocals&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 有未使用的变量时，抛出错误</span><br>    <span class="hljs-string">&quot;noUnusedParameters&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-comment">// 有未使用的参数时，抛出错误</span><br>    <span class="hljs-string">&quot;noImplicitReturns&quot;</span>: <span class="hljs-literal">true</span>,             <span class="hljs-comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span><br>    <span class="hljs-string">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><br>    <span class="hljs-comment">/* 模块解析选项 */</span><br>    <span class="hljs-string">&quot;moduleResolution&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,            <span class="hljs-comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br>    <span class="hljs-string">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用于解析非相对模块名称的基目录</span><br>    <span class="hljs-string">&quot;paths&quot;</span>: &#123;&#125;,                           <span class="hljs-comment">// 模块名到基于 baseUrl 的路径映射的列表</span><br>    <span class="hljs-string">&quot;rootDirs&quot;</span>: [],                        <span class="hljs-comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br>    <span class="hljs-string">&quot;typeRoots&quot;</span>: [],                       <span class="hljs-comment">// 包含类型声明的文件列表</span><br>    <span class="hljs-string">&quot;types&quot;</span>: [],                           <span class="hljs-comment">// 需要包含的类型声明文件名列表</span><br>    <span class="hljs-string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 允许从没有设置默认导出的模块中默认导入。</span><br><br>    <span class="hljs-comment">/* Source Map Options */</span><br>    <span class="hljs-string">&quot;sourceRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                    <span class="hljs-comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br>    <span class="hljs-string">&quot;mapRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span><br>    <span class="hljs-string">&quot;inlineSourceMap&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br>    <span class="hljs-string">&quot;inlineSources&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><br>    <span class="hljs-comment">/* 其他选项 */</span><br>    <span class="hljs-string">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-comment">// 启用装饰器</span><br>    <span class="hljs-string">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span>          <span class="hljs-comment">// 为装饰器提供元数据的支持</span><br>  &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><h1 id="编写高效-TS-代码的一些建议"><a href="#编写高效-TS-代码的一些建议" class="headerlink" title="编写高效 TS 代码的一些建议"></a>编写高效 TS 代码的一些建议</h1><h2 id="尽量减少重复代码"><a href="#尽量减少重复代码" class="headerlink" title="尽量减少重复代码"></a>尽量减少重复代码</h2><p>对于刚接触 TypeScript 的小伙伴来说，在定义接口时，可能一不小心会出现以下类似的重复代码。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">firstName</span>: string;<br>  <span class="hljs-attr">lastName</span>: string;<br>&#125;<br><br>interface <span class="hljs-title class_">PersonWithBirthDate</span> &#123;<br>  <span class="hljs-attr">firstName</span>: string;<br>  <span class="hljs-attr">lastName</span>: string;<br>  <span class="hljs-attr">birth</span>: <span class="hljs-title class_">Date</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>很明显，相对于 <code>Person</code> 接口来说，<code>PersonWithBirthDate</code> 接口只是多了一个 <code>birth</code> 属性，其他的属性跟 <code>Person</code> 接口是一样的。那么如何避免出现例子中的重复代码呢？要解决这个问题，可以利用 <code>extends</code> 关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Person</span> &#123; <br>  <span class="hljs-attr">firstName</span>: string; <br>  <span class="hljs-attr">lastName</span>: string;<br>&#125;<br><br>interface <span class="hljs-title class_">PersonWithBirthDate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123; <br>  <span class="hljs-attr">birth</span>: <span class="hljs-title class_">Date</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>当然除了使用 <code>extends</code> 关键字之外，也可以使用交叉运算符（&amp;）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">PersonWithBirthDate</span> = <span class="hljs-title class_">Person</span> &amp; &#123; <span class="hljs-attr">birth</span>: <span class="hljs-title class_">Date</span> &#125;;<br></code></pre></td></tr></table></figure><p>另外，有时候你可能还会发现自己想要定义一个类型来匹配一个初始配置对象的「形状」，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">INIT_OPTIONS</span> = &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">640</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">480</span>,<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#00FF00&quot;</span>,<br>  <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;VGA&quot;</span>,<br>&#125;;<br><br>interface <span class="hljs-title class_">Options</span> &#123;<br>  <span class="hljs-attr">width</span>: number;<br>  <span class="hljs-attr">height</span>: number;<br>  <span class="hljs-attr">color</span>: string;<br>  <span class="hljs-attr">label</span>: string;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实，对于 Options 接口来说，你也可以使用 typeof 操作符来快速获取配置对象的「形状」：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">Options</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-variable constant_">INIT_OPTIONS</span>;<br></code></pre></td></tr></table></figure><p>在实际的开发过程中，重复的类型并不总是那么容易被发现。有时它们会被语法所掩盖。比如有多个函数拥有相同的类型签名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url: string, opts: Options</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">url: string, opts: Options</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>对于上面的 get 和 post 方法，为了避免重复的代码，你可以提取统一的类型签名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">type <span class="hljs-title class_">HTTPFunction</span> = <span class="hljs-function">(<span class="hljs-params">url: string, opts: Options</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt;; <br><span class="hljs-keyword">const</span> <span class="hljs-attr">get</span>: <span class="hljs-title class_">HTTPFunction</span> = <span class="hljs-function">(<span class="hljs-params">url, opts</span>) =&gt;</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">post</span>: <span class="hljs-title class_">HTTPFunction</span> = <span class="hljs-function">(<span class="hljs-params">url, opts</span>) =&gt;</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br></code></pre></td></tr></table></figure><h2 id="使用更精确的类型替代字符串类型"><a href="#使用更精确的类型替代字符串类型" class="headerlink" title="使用更精确的类型替代字符串类型"></a>使用更精确的类型替代字符串类型</h2><p>假设你正在构建一个音乐集，并希望为专辑定义一个类型。这时你可以使用 <code>interface</code> 关键字来定义一个 <code>Album</code> 类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Album</span> &#123;<br>  <span class="hljs-attr">artist</span>: string; <span class="hljs-comment">// 艺术家</span><br>  <span class="hljs-attr">title</span>: string; <span class="hljs-comment">// 专辑标题</span><br>  <span class="hljs-attr">releaseDate</span>: string; <span class="hljs-comment">// 发行日期：YYYY-MM-DD</span><br>  <span class="hljs-attr">recordingType</span>: string; <span class="hljs-comment">// 录制类型：&quot;live&quot; 或 &quot;studio&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于 <code>Album</code> 类型，你希望 <code>releaseDate</code> 属性值的格式为 <code>YYYY-MM-DD</code>，而 <code>recordingType</code> 属性值的范围为 <code>live</code> 或 <code>studio</code>。但因为接口中 <code>releaseDate</code> 和 <code>recordingType</code> 属性的类型都是字符串，所以在使用 <code>Album</code> 接口时，可能会出现以下问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">dangerous</span>: <span class="hljs-title class_">Album</span> = &#123;<br>  <span class="hljs-attr">artist</span>: <span class="hljs-string">&quot;Michael Jackson&quot;</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Dangerous&quot;</span>,<br>  <span class="hljs-attr">releaseDate</span>: <span class="hljs-string">&quot;November 31, 1991&quot;</span>, <span class="hljs-comment">// 与预期格式不匹配</span><br>  <span class="hljs-attr">recordingType</span>: <span class="hljs-string">&quot;Studio&quot;</span>, <span class="hljs-comment">// 与预期格式不匹配</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>虽然 <code>releaseDate</code> 和 <code>recordingType</code> 的值与预期的格式不匹配，但此时 TypeScript 编译器并不能发现该问题。为了解决这个问题，你应该为 <code>releaseDate</code> 和 <code>recordingType</code> 属性定义更精确的类型，比如这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Album</span> &#123;\<br>  <span class="hljs-attr">artist</span>: string; <span class="hljs-comment">// 艺术家</span><br>  <span class="hljs-attr">title</span>: string; <span class="hljs-comment">// 专辑标题</span><br>  <span class="hljs-attr">releaseDate</span>: <span class="hljs-title class_">Date</span>; <span class="hljs-comment">// 发行日期：YYYY-MM-DD</span><br>  <span class="hljs-attr">recordingType</span>: <span class="hljs-string">&quot;studio&quot;</span> | <span class="hljs-string">&quot;live&quot;</span>; <span class="hljs-comment">// 录制类型：&quot;live&quot; 或 &quot;studio&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>重新定义 <code>Album</code> 接口之后，对于前面的赋值语句，TypeScript 编译器就会提示以下异常信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">dangerous</span>: <span class="hljs-title class_">Album</span> = &#123;<br>  <span class="hljs-attr">artist</span>: <span class="hljs-string">&quot;Michael Jackson&quot;</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Dangerous&quot;</span>,<br>  <span class="hljs-comment">// 不能将类型“string”分配给类型“Date”。ts(2322)</span><br>  <span class="hljs-attr">releaseDate</span>: <span class="hljs-string">&quot;November 31, 1991&quot;</span>, <span class="hljs-comment">// Error</span><br>  <span class="hljs-comment">// 不能将类型“&quot;Studio&quot;”分配给类型“&quot;studio&quot; | &quot;live&quot;”。ts(2322)\</span><br>  <span class="hljs-attr">recordingType</span>: <span class="hljs-string">&quot;Studio&quot;</span>, <span class="hljs-comment">// Error</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>为了解决上面的问题，你需要为 <code>releaseDate</code> 和 <code>recordingType</code> 属性设置正确的类型，比如这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">dangerous</span>: <span class="hljs-title class_">Album</span> = &#123;<br>  <span class="hljs-attr">artist</span>: <span class="hljs-string">&quot;Michael Jackson&quot;</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Dangerous&quot;</span>,<br>  <span class="hljs-attr">releaseDate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;1991-11-31&quot;</span>),<br>  <span class="hljs-attr">recordingType</span>: <span class="hljs-string">&quot;studio&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="定义的类型总是表示有效的状态"><a href="#定义的类型总是表示有效的状态" class="headerlink" title="定义的类型总是表示有效的状态"></a>定义的类型总是表示有效的状态</h2><p>假设你正在构建一个允许用户指定页码，然后加载并显示该页面对应内容的 Web 应用程序。首先，你可能会先定义 <code>State</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">State</span> &#123;<br>  <span class="hljs-attr">pageContent</span>: string;<br>  <span class="hljs-attr">isLoading</span>: boolean;<br>  errorMsg?: string;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着你会定义一个 <code>renderPage</code> 函数，用来渲染页面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderPage</span>(<span class="hljs-params">state: State</span>) &#123;<br>  <span class="hljs-keyword">if</span> (state.<span class="hljs-property">errorMsg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`呜呜呜，加载页面出现异常了...<span class="hljs-subst">$&#123;state.errorMsg&#125;</span>`</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.<span class="hljs-property">isLoading</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`页面加载中~~~`</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;div&gt;<span class="hljs-subst">$&#123;state.pageContent&#125;</span>&lt;/div&gt;`</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果：页面加载中~~~</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">renderPage</span>(&#123;<span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">pageContent</span>: <span class="hljs-string">&quot;&quot;</span>&#125;));<br><span class="hljs-comment">// 输出结果：&lt;div&gt;大家好&lt;/div&gt;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">renderPage</span>(&#123;<span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">pageContent</span>: <span class="hljs-string">&quot;大家好呀&quot;</span>&#125;));<br></code></pre></td></tr></table></figure><p>创建好 <code>renderPage</code> 函数，你可以继续定义一个 <code>changePage</code> 函数，用于根据页码获取对应的页面数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changePage</span>(<span class="hljs-params">state: State, newPage: string</span>) &#123;<br>  state.<span class="hljs-property">isLoading</span> = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-title function_">getUrlForPage</span>(newPage));<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Unable to load <span class="hljs-subst">$&#123;newPage&#125;</span>: <span class="hljs-subst">$&#123;response.statusText&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();<br>    state.<span class="hljs-property">isLoading</span> = <span class="hljs-literal">false</span>;<br>    state.<span class="hljs-property">pageContent</span> = text;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    state.<span class="hljs-property">errorMsg</span> = <span class="hljs-string">&quot;&quot;</span> + e;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于以上的 <code>changePage</code> 函数，它存在以下问题：</p><ul><li>在 catch 语句中，未把 <code>state.isLoading</code> 的状态设置为 <code>false</code>；</li><li>未及时清理 <code>state.errorMsg</code> 的值，因此如果之前的请求失败，那么你将继续看到错误消息，而不是加载消息。</li></ul><p>出现上述问题的原因是，前面定义的 <code>State</code> 类型允许同时设置 <code>isLoading</code> 和 <code>errorMsg</code> 的值，尽管这是一种无效的状态。针对这个问题，你可以考虑引入可辨识联合类型来定义不同的页面请求状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">RequestPending</span> &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-string">&quot;pending&quot;</span>;<br>&#125;<br><br>interface <span class="hljs-title class_">RequestError</span> &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-string">&quot;error&quot;</span>;<br>  <span class="hljs-attr">errorMsg</span>: string;<br>&#125;<br><br>interface <span class="hljs-title class_">RequestSuccess</span> &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-string">&quot;ok&quot;</span>;<br>  <span class="hljs-attr">pageContent</span>: string;<br>&#125;<br><br>type <span class="hljs-title class_">RequestState</span> = <span class="hljs-title class_">RequestPending</span> | <span class="hljs-title class_">RequestError</span> | <span class="hljs-title class_">RequestSuccess</span>;<br><br>interface <span class="hljs-title class_">State</span> &#123;<br>  <span class="hljs-attr">currentPage</span>: string;<br>  <span class="hljs-attr">requests</span>: &#123; [<span class="hljs-attr">page</span>: string]: <span class="hljs-title class_">RequestState</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上代码中，通过使用可辨识联合类型分别定义了 3 种不同的请求状态，这样就可以很容易的区分出不同的请求状态，从而让业务逻辑处理更加清晰。接下来，需要基于更新后的 <code>State</code> 类型，来分别更新一下前面创建的 <code>renderPage</code> 和 <code>changePage</code> 函数：</p><p><strong>更新后的 renderPage 函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderPage</span>(<span class="hljs-params">state: State</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; currentPage &#125; = state;<br>  <span class="hljs-keyword">const</span> requestState = state.<span class="hljs-property">requests</span>[currentPage];<br>  <span class="hljs-keyword">switch</span> (requestState.<span class="hljs-property">state</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pending&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`页面加载中~~~`</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;error&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`呜呜呜，加载第<span class="hljs-subst">$&#123;currentPage&#125;</span>页出现异常了...<span class="hljs-subst">$&#123;requestState.errorMsg&#125;</span>`</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ok&quot;</span>:<br>      <span class="hljs-string">`&lt;div&gt;第<span class="hljs-subst">$&#123;currentPage&#125;</span>页的内容：<span class="hljs-subst">$&#123;requestState.pageContent&#125;</span>&lt;/div&gt;`</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>更新后的 changePage 函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changePage</span>(<span class="hljs-params">state: State, newPage: string</span>) &#123;<br>  state.<span class="hljs-property">requests</span>[newPage] = &#123; <span class="hljs-attr">state</span>: <span class="hljs-string">&quot;pending&quot;</span> &#125;;<br>  state.<span class="hljs-property">currentPage</span> = newPage;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-title function_">getUrlForPage</span>(newPage));<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`无法正常加载页面 <span class="hljs-subst">$&#123;newPage&#125;</span>: <span class="hljs-subst">$&#123;response.statusText&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> pageContent = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();<br>    state.<span class="hljs-property">requests</span>[newPage] = &#123; <span class="hljs-attr">state</span>: <span class="hljs-string">&quot;ok&quot;</span>, pageContent &#125;;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    state.<span class="hljs-property">requests</span>[newPage] = &#123; <span class="hljs-attr">state</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-attr">errorMsg</span>: <span class="hljs-string">&quot;&quot;</span> + e &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>changePage</code> 函数中，会根据不同的情形设置不同的请求状态，而不同的请求状态会包含不同的信息。这样 <code>renderPage</code> 函数就可以根据统一的 <code>state</code> 属性值来进行相应的处理。因此，通过使用可辨识联合类型，让请求的每种状态都是有效的状态，不会出现无效状态的问题。</p><p>转载<a href="https://juejin.cn/post/7018805943710253086">2021 typescript史上最强学习入门文章(2w字)</a></p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3 + koa2 + mysql 开发中的杂谈</title>
    <link href="./2023/03/08/Vue3%20+%20koa2%20+%20mysql%20%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%9D%82%E8%B0%88/"/>
    <url>./2023/03/08/Vue3%20+%20koa2%20+%20mysql%20%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3-koa2-mysql-开发中的杂谈"><a href="#Vue3-koa2-mysql-开发中的杂谈" class="headerlink" title="Vue3 + koa2 + mysql 开发中的杂谈"></a>Vue3 + koa2 + mysql 开发中的杂谈</h1><h2 id="一、Vue3开发"><a href="#一、Vue3开发" class="headerlink" title="一、Vue3开发"></a>一、Vue3开发</h2><h3 id="1、v-md-editorMarkdown文本编辑插件"><a href="#1、v-md-editorMarkdown文本编辑插件" class="headerlink" title="1、v-md-editorMarkdown文本编辑插件"></a>1、<a href="https://ckang1229.gitee.io/vue-markdown-editor/zh/examples/preview-demo.html#%E5%BC%95%E5%85%A5">v-md-editor</a>Markdown文本编辑插件</h3><p>理由：本插件在使用过程中完美兼容vue3，且功能较丰富，有详细完整的教程</p><p>vue3使用一定要安装对应的版本</p><h3 id="2、vue3中组件通信"><a href="#2、vue3中组件通信" class="headerlink" title="2、vue3中组件通信"></a>2、vue3中组件通信</h3><h4 id="1、祖孙通信使用依赖注入provide-x2F-inject，，兄弟使用mitt库"><a href="#1、祖孙通信使用依赖注入provide-x2F-inject，，兄弟使用mitt库" class="headerlink" title="1、祖孙通信使用依赖注入provide&#x2F;inject，，兄弟使用mitt库"></a>1、祖孙通信使用依赖注入provide&#x2F;inject，，兄弟使用mitt库</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">依赖注入在main.js中使用<br><span class="hljs-regexp">//</span> 依赖注入的方式，provide不能对象的方式写<br><span class="hljs-regexp">//</span> app.provide(&#123;<br><span class="hljs-regexp">//</span>     <span class="hljs-string">&#x27;axios&#x27;</span>: axios,<br><span class="hljs-regexp">//</span>     BasicUrl: <span class="hljs-string">&#x27;http://localhost:5030/&#x27;</span><br><span class="hljs-regexp">//</span> &#125;)<br>app.provide(<span class="hljs-string">&#x27;axios&#x27;</span>, axios)<br>app.provide(<span class="hljs-string">&#x27;BasicUrl&#x27;</span>, BasicUrl.Url)<br><br>在vue组件中可正常使用<br>const axios = inject(<span class="hljs-string">&#x27;axios&#x27;</span>)<br><br>provide: &#123;<br>   name:value<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、父子使用props"><a href="#2、父子使用props" class="headerlink" title="2、父子使用props"></a>2、父子使用props</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs elixir">provide/inject是祖孙间通信，父子间通信最好用props<br>父组件<br>&lt;upload-components <span class="hljs-symbol">:blogdetail=<span class="hljs-string">&quot;blogdetail&quot;</span>&gt;&lt;/upload-components&gt;</span><br>子组件接收<br>props两种接收方式<br><span class="hljs-number">1</span>、<span class="hljs-symbol">props:</span>[<span class="hljs-string">&quot;blogdetail&quot;</span>]<br><span class="hljs-number">2</span>、<span class="hljs-symbol">props:</span>&#123;<br>      <span class="hljs-symbol">blogdetail:</span>&#123;<br>          <span class="hljs-symbol">type:</span><span class="hljs-title class_">String</span>/<span class="hljs-title class_">Object</span><br>          <span class="hljs-symbol">default:</span><span class="hljs-string">&#x27;&#x27;</span>               //没有输入时的默认值<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、兄弟使用mitt库"><a href="#3、兄弟使用mitt库" class="headerlink" title="3、兄弟使用mitt库"></a>3、兄弟使用mitt库</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript">vue2<span class="hljs-number">.0</span>时经常用事件总线 $emit 和 $on进行组件间的通信，vue3<span class="hljs-number">.0</span>中这两个方法被移除了，无法使用<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br>vue兄弟组件通信可以引用第三方库mitt库 ！！！也是官方推荐的<br><br>想在<span class="hljs-title class_">Vue3</span>当中使用事件总线当然也非常简单的啦一共分为三个步骤<br><span class="hljs-number">1.</span>安装<br>npm install --save mitt<br><br><span class="hljs-number">2.</span>挂载<br><span class="hljs-comment">//main.js中</span><br><span class="hljs-keyword">import</span> mitt <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mitt&quot;</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>()<span class="hljs-comment">//正常配置</span><br><span class="hljs-comment">//挂载事务总线</span><br><span class="hljs-keyword">const</span> vueEvent = <span class="hljs-keyword">new</span> <span class="hljs-title function_">mitt</span>()<br>app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">vueEvent</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">mitt</span>()<br><br><br><span class="hljs-number">3.</span>使用<br><span class="hljs-keyword">import</span> &#123;getCurrentInstance&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br> <span class="hljs-keyword">const</span> vueEvent = <span class="hljs-title function_">getCurrentInstance</span>()?.<span class="hljs-property">appContext</span>.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">vueEvent</span><br><span class="hljs-comment">//发送</span><br>vueEvent.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;handleCurrentNo&#x27;</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">//接收</span><br>   <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      vueEvent.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;handleCurrentNo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">val: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>        state.<span class="hljs-property">currentNo</span> = val<br>      &#125;)<br>    &#125;)<br>    <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      vueEvent.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;handleCurrentNo&#x27;</span>)<br>    &#125;)<br></code></pre></td></tr></table></figure><h3 id="3、axios配置及操作"><a href="#3、axios配置及操作" class="headerlink" title="3、axios配置及操作"></a>3、axios配置及操作</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//axios.js</span><br><span class="hljs-keyword">import</span> axios from <span class="hljs-string">&quot;axios&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; ElMessage &#125; from <span class="hljs-string">&quot;element-plus&quot;</span>;<br><br>let http = axios.create(&#123;<br>   baseURL:<span class="hljs-string">&#x27;http://localhost:5030/&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">//请求拦截</span><br>http.interceptors.request.use( config =&gt; &#123;<br>   <span class="hljs-keyword">if</span>(localStorage.elementToken)&#123;<br>     config.headers.Authorization = localStorage.elementToken<br>   &#125;<br>   <span class="hljs-keyword">return</span> config<br>&#125;)<br><br><span class="hljs-comment">//响应拦截</span><br>http.interceptors.response.use( res =&gt; &#123;<br>  <span class="hljs-keyword">return</span> res<br>&#125;, err =&gt; &#123;<br>  console.log(err.response);<br>  ElMessage.error(err.response.data.msg)<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> http<br><br><span class="hljs-comment">//在main.js中直接使用provide传出去</span><br><span class="hljs-keyword">import</span> axios from <span class="hljs-string">&#x27;./axios.js&#x27;</span><br>app.provide(<span class="hljs-string">&#x27;axios&#x27;</span>, axios)<br><br><span class="hljs-comment">//然后在组件中直接引用即可</span><br><span class="hljs-keyword">const</span> axios = inject(<span class="hljs-string">&#x27;axios&#x27;</span>)<br>     <span class="hljs-comment">//由于axios配置时设置了拦截，所以例如element自带的文件上传需要在头上加上token令牌</span><br>      <span class="hljs-comment">// let config = &#123;</span><br>         <span class="hljs-comment">//     headers: &#123;</span><br>         <span class="hljs-comment">//      Authorization: localStorage.elementToken,</span><br>         <span class="hljs-comment">//      &#125;,</span><br>        <span class="hljs-comment">// &#125;;</span><br>      <br>      <span class="hljs-comment">//自定义的上传文件，例如图片时，在拿到文件后，需要将其实例化</span><br>       <span class="hljs-comment">//实例表单</span><br>     <span class="hljs-comment">// let formdata = new FormData();</span><br>      <span class="hljs-comment">//添加表单</span><br>     <span class="hljs-comment">// formdata.append(&quot;file&quot;, files[0]);</span><br>     然后直接使用axios上传formdata即可，后端接收文件是<span class="hljs-keyword">const</span> files = ctx.request.files.file<br>axios<br>        .post(<span class="hljs-string">&#x27;访问的url&#x27;</span>，上传的值，config(配置的头文件，一般没有))<br>        .then((res) =&gt; &#123;<br>          console.log(res.data);<br>        &#125;)<br>        .<span class="hljs-keyword">catch</span>((err) =&gt; &#123;<br>          console.log(err);<br>        &#125;);<br>或者<br>axios(&#123;<br>  url:<span class="hljs-string">&#x27;&#x27;</span>,<br>  method:<span class="hljs-string">&#x27;post&#x27;</span>,<br>  data:<span class="hljs-string">&#x27;上传的值&#x27;</span><br>  header:&#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>&#125;      <span class="hljs-comment">//配置</span><br>&#125;)<br><br><span class="hljs-comment">//get请求</span><br><span class="hljs-comment">//单纯的接收 XXX/user/test接口传回的值</span><br>vue端：axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/user/test&#x27;</span>)  <br>koa端：user.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/test&#x27;</span>,<span class="hljs-keyword">async</span>(ctx) =&gt; &#123;   &#125;)<br><br><span class="hljs-comment">//带参获取值</span><br>vue端：axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/user/test/&#x27;</span> + testvalue)<br>koa端：user.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/test/:name&#x27;</span>,<span class="hljs-keyword">async</span>(ctx) =&gt; &#123;  <br>           <span class="hljs-keyword">const</span> testvalue = ctx.params.name <br>    &#125;)<br> <br><span class="hljs-comment">//post请求</span><br>vue端：axios.post(<span class="hljs-string">&#x27;/user/test&#x27;</span>,testvalue)    <span class="hljs-comment">//此处的testvalue应为对象</span><br>koa端：user.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/test&#x27;</span>,<span class="hljs-keyword">async</span>(ctx) =&gt; &#123;  <br>           <span class="hljs-keyword">const</span> testvalue = ctx.requestbody.body.testvalue<br>           或键值对的名字一样时<br>           <span class="hljs-keyword">const</span> &#123;testvalue&#125; = ctx.requestbody.body<br>    &#125;)<br></code></pre></td></tr></table></figure><h3 id="4、常用函数"><a href="#4、常用函数" class="headerlink" title="4、常用函数"></a>4、常用函数</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//生命周期，页面初始时即加载的服务</span><br>onMounted(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; &#125;);<br><br><span class="hljs-comment">//计算属性</span><br>const double = computed(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123; &#125;)<br><br><span class="hljs-comment">//需要在 DOM 更新之后再执行一段代码时，可以借助nextTick实现</span><br>nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="5、注意事项"><a href="#5、注意事项" class="headerlink" title="5、注意事项"></a>5、注意事项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs vue">//使用element表单时的注意<br>&lt;template&gt;<br>  &lt;div class=&quot;datapage_divise animate__animated animate__fadeInDown&quot;&gt;<br>    &lt;div class=&quot;upload_title&quot;&gt;<br>      &lt;!-- 此处model与ref最好区分开，model是输入时的数据，ref是最终的传递的数据，虽然可以<br>      是一样，但是千万不要设置一样，否则输入时极度慢 --&gt;<br>      &lt;el-form<br>        :model=&quot;formtitledata&quot;<br>        :rules=&quot;rules&quot;<br>        ref=&quot;ruleForm&quot;<br>        label-width=&quot;100px&quot;<br>        class=&quot;demo-ruleForm&quot;<br>        size=&quot;mini&quot;<br>      &gt;<br>        &lt;el-form-item label=&quot;链接地址&quot; type=&quot;color:black&quot; prop=&quot;linkpath&quot;&gt;<br>          &lt;el-input type=&quot;text&quot; v-model=&quot;formtitledata.linkpath&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item label=&quot;链接简介&quot; prop=&quot;linkcomments&quot;&gt;<br>          &lt;el-input<br>            type=&quot;textarea&quot;<br>            v-model=&quot;formtitledata.linkcomments&quot;<br>          &gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item style=&quot;text-align:center&quot;&gt;<br>          &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm&quot;&gt;立即创建&lt;/el-button&gt;<br>          &lt;el-button @click=&quot;resetForm&quot;&gt;重置&lt;/el-button&gt;<br>        &lt;/el-form-item&gt;<br>      &lt;/el-form&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; defineComponent, reactive, inject, ref, onMounted &#125; from &quot;vue&quot;;<br><br>export default defineComponent(&#123;<br>  name: &quot;datapage&quot;,<br>  setup(props) &#123;<br>    const axios = inject(&quot;axios&quot;);<br>    //引入dayjs是由于mysql生成的日期传到前端格式有杂质，故用dayjs修改<br>    const dayjs = inject(&quot;dayjs&quot;);<br><br>    let formtitledata = reactive(&#123;<br>      linkpath: &quot;&quot;,<br>      linkcomments: &quot;&quot;,<br>    &#125;);<br>    //表单规则<br>    const rules = reactive(&#123;<br>      linkpath: [<br>        &#123; required: true, message: &quot;请输入链接地址&quot;, trigger: &quot;blur&quot; &#125;,<br>        &#123; min: 1, max: 30, message: &quot;长度在 3 到 5 个字符&quot;, trigger: &quot;blur&quot; &#125;,<br>      ],<br>      linkcomments: [<br>        &#123; required: true, message: &quot;请填写链接简介&quot;, trigger: &quot;blur&quot; &#125;,<br>      ],<br>    &#125;);<br>    //接收需设置为ref<br>    const ruleForm = ref();<br>    function submitForm() &#123;<br>      ruleForm.value.validate((valid) =&gt; &#123;<br>        if (valid) &#123;<br>          console.log(valid);<br>          axios<br>            .post(&quot;/artical/addlink&quot;, formtitledata)<br>            .then((res) =&gt; &#123;<br>              console.log(res.data);<br>            &#125;)<br>            .catch((error) =&gt; &#123;<br>              console.log(error);<br>            &#125;);<br>        &#125; else &#123;<br>          console.log(&quot;error submit!!&quot;);<br>          return false;<br>        &#125;<br>      &#125;);<br>    &#125;<br>    //重置<br>    function resetForm() &#123;<br>      ruleForm.value.resetFields();<br>    &#125;<br><br>    return &#123;<br>      formtitledata,<br>      ruleForm,<br>      rules,<br>      submitForm,<br>      resetForm,<br>      dayjs<br>    &#125;;<br>  &#125;,<br>&#125;);<br>&lt;/script&gt;<br><br><br>//一组表格中选取一行数据修改思路<br>1、获取到后台的对象的数组<br>2、向数组中的每一个对象添加一个boolean类型的键值对<br>为数组中每一个对象添加&#123;edit:false&#125;键值对<br>let addedit = res.data。arr;<br>        addedit.forEach((element) =&gt; &#123;<br>          element[&quot;edit&quot;] = false;<br>        &#125;);<br>3、通过v-if或v-show实现修改功能，注:v-if和v-show前不需要&#x27;:&#x27;绑定，否则功能无法实现<br><br>//将后端获取的数据存储到本地<br>localStorage和sessionStorage一样都是用来存储客户端临时信息的对象<br>localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。<br>sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。<br>用法：<br>setItem (key, value) ——  保存数据，以键值对的方式储存信息。<br>getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。<br>removeItem (key) ——  删除单个数据，根据键值移除对应的信息。<br>clear () ——  删除所有的数据<br>key (index) —— 获取某个索引的key<br>例如：token为已获取到的值<br>localStorage.set(&quot;elementToken&quot;,token)<br><br>//文件下载<br>const downloadU = BasicUrl + &quot;/files/download/&quot; + row.filename;<br>      window.open(downloadU, &quot;myIframe&quot;);<br>通过该指令可直接下载文件，后端会接受到该路径，接收token验证，所以需要需要将/files/download/*加入到koa-jwt白名单中， /^\/files\/download\/*/<br><br>const send = require(&#x27;koa-send&#x27;);<br>//实现下载功能<br>fileList.get(&#x27;/download/:name&#x27;, async (ctx) =&gt; &#123;<br>    const name = ctx.params.name<br>    console.log(&#x27;filename&#x27;, name);<br>    const path = `public/uploads/$&#123;name&#125;`;<br>    console.log(&#x27;fileQueryPath&#x27;, path);<br>    ctx.attachment(path);<br>    await send(ctx, path);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="二、Koa2开发"><a href="#二、Koa2开发" class="headerlink" title="二、Koa2开发"></a>二、Koa2开发</h2><h3 id="1、调用其三方接口，请求其他数据"><a href="#1、调用其三方接口，请求其他数据" class="headerlink" title="1、调用其三方接口，请求其他数据"></a>1、调用其三方接口，请求其他数据</h3><p><a href="https://blog.csdn.net/qq_40816649/article/details/87895301">参考node请求</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//wallhaven.cc/api的图片接口非常友好，有相应的api文档，登陆账号后就可获得密钥</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Router</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-router&#x27;</span>);<br><span class="hljs-keyword">const</span> queryback = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../util/db/db.js&#x27;</span>)<br><span class="hljs-keyword">const</span> otherapi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();<br><br><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;request&#x27;</span>)<br>otherapi.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/wallhaven/:name&#x27;</span>, <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br><br>    <span class="hljs-keyword">let</span> pageid = ctx.<span class="hljs-property">params</span>.<span class="hljs-property">name</span><br>        <span class="hljs-comment">//request需要异步执行，</span><br>    <span class="hljs-keyword">let</span> dd = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//node封装的请求中间件GET请求</span><br>        <span class="hljs-title function_">request</span>(&#123;<br>                <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://wallhaven.cc/api/v1/search&#x27;</span>,<br>                <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>                <span class="hljs-comment">//请求带参数时，get中params中填写的数据对应的为qs中的对象，结果为json</span><br>                <span class="hljs-comment">//post中body填写的数据对应的为form的对象，具体看请求头</span><br>                <span class="hljs-attr">qs</span>:&#123;<br>                   <span class="hljs-string">&#x27;sorting&#x27;</span>:<span class="hljs-string">&#x27;toplist&#x27;</span>,<br>                   <span class="hljs-string">&#x27;topRange&#x27;</span>:<span class="hljs-string">&#x27;1d&#x27;</span>,<br>                   <span class="hljs-string">&#x27;purity&#x27;</span>:<span class="hljs-string">&#x27;100&#x27;</span>,<br>                   <span class="hljs-string">&#x27;page&#x27;</span>:pageid,<br>                &#125;,<br>                <span class="hljs-attr">headers</span>: &#123;<br>                    <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>                &#125;<br>            &#125;,<br>            <span class="hljs-keyword">function</span> (<span class="hljs-params">error, response, body</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!error &amp;&amp; response.<span class="hljs-property">statusCode</span> == <span class="hljs-number">200</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(body))<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败&#x27;</span>, error);<br>                &#125;<br>            &#125;)<br>    &#125;)<br>    <span class="hljs-keyword">if</span> (dd.<span class="hljs-property">data</span> !== <span class="hljs-literal">null</span>) &#123;<br>        ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">200</span><br>        ctx.<span class="hljs-property">body</span> = &#123;<br>            <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;success&#x27;</span>,<br>            <span class="hljs-attr">imgs</span>: dd.<span class="hljs-property">data</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">404</span><br>        ctx.<span class="hljs-property">body</span> = &#123;<br>            <span class="hljs-attr">code</span>: -<span class="hljs-number">1</span>,<br>        &#125;<br>    &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="2、async、await、Promise之间的联系"><a href="#2、async、await、Promise之间的联系" class="headerlink" title="2、async、await、Promise之间的联系"></a>2、async、await、Promise之间的联系</h3><p>async 函数</p><ol><li>函数的返回值为 promise 对象</li><li>promise 对象的结果由 async 函数执行的返回值决定</li></ol><p>await 表达式</p><ol><li>await 右侧的表达式一般为 promise 对象, 但也可以是其它的值</li><li>如果表达式是 promise 对象, await 返回的是 promise 成功的值</li><li>如果表达式是其它值, 直接将此值作为 await 的返回值</li></ol><p> 注意</p><ol><li>await 必须写在 async 函数中, 但 async 函数中可以没有 await</li><li>如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//异步操作一般使用，该命令运行在async中</span><br><span class="hljs-comment">//let dd = await new Promise((resolve, reject) =&gt; &#123;  &#125;</span><br>    <br>&lt;script&gt;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>) <br>            &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> <br>            &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">3</span>)<br>         <span class="hljs-comment">// return fn3.test() // 程序运行会抛出异常</span><br>            &#125;<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn4</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-keyword">return</span> fn3.<span class="hljs-title function_">test</span>() <span class="hljs-comment">// 程序运行会抛出异常</span><br>           &#125;<br><br><span class="hljs-comment">// 没有使用 await 的 async 函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn5</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">4</span> <br>          &#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>           <span class="hljs-comment">// await 右侧是一个成功的 promise</span><br>           <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn1</span>()<br>           <span class="hljs-comment">// await 右侧是一个非 promise 的数据</span><br>           <span class="hljs-comment">// const result = await fn2()</span><br>           <span class="hljs-comment">// await 右侧是一个失败的 promise</span><br>           <span class="hljs-comment">// const result = await fn3()</span><br>           <span class="hljs-comment">// await 右侧抛出异常</span><br>           <span class="hljs-comment">// const result = await fn4()</span><br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;result: &#x27;</span>, result)<br>           <span class="hljs-keyword">return</span> result+<span class="hljs-number">10</span><br>           &#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn</span>()<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;result2&#x27;</span>, result2) &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, error) <br>                 &#125;<br>          <span class="hljs-keyword">const</span> result3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn4</span>()<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;result4&#x27;</span>, result3) <br>        &#125;<br>          <span class="hljs-comment">// test()</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="3、koa-jwt的白名单"><a href="#3、koa-jwt的白名单" class="headerlink" title="3、koa-jwt的白名单"></a>3、koa-jwt的白名单</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">const &#123;<br>    PRIVATE_KEY<br>&#125; = require(<span class="hljs-string">&#x27;./util/encrpytion/md5.js&#x27;</span>)<br>const koaJWT = require(<span class="hljs-string">&#x27;koa-jwt&#x27;</span>)<br><br><span class="hljs-regexp">//</span>使用kaoJwt拦截token<br>app.use(koaJWT(&#123;<br>    <span class="hljs-regexp">//</span> 解密 密钥<br>    secret: PRIVATE_KEY,<br>    algorithms: [<span class="hljs-string">&quot;HS256&quot;</span>]<br>   &#125;).unless(&#123;<br>    path: [<br>    <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    <span class="hljs-string">&#x27;/login/register&#x27;</span>,<br>    <span class="hljs-string">&#x27;/email&#x27;</span>,<br>    <span class="hljs-string">&#x27;/email/examEmail&#x27;</span>,<br>    <span class="hljs-string">&#x27;/email/forget&#x27;</span>,<br>    <span class="hljs-regexp">/^\/files\/download\/*/</span>,<br>  ] <br>  <span class="hljs-regexp">//</span>此处使用正则表达式，此处是下载的命令<br>  <span class="hljs-regexp">//</span>⽩名单,除了这⾥写的地址，其 他的URL都需要验证<br>   &#125;));<br><br>白名单中需要使用正则表达式可放行<span class="hljs-regexp">/files/</span>download/:name<br></code></pre></td></tr></table></figure><h3 id="4、解析token令牌，获取用户名"><a href="#4、解析token令牌，获取用户名" class="headerlink" title="4、解析token令牌，获取用户名"></a>4、解析token令牌，获取用户名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//设置的加密，解码</span><br>md5.<span class="hljs-property">js</span><br><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">md5</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-comment">// 给密码加密</span><br>    <span class="hljs-comment">//注意参数需要为string类型，否则会报错</span><br>    <span class="hljs-keyword">return</span> crypto.<span class="hljs-title function_">createHash</span>(<span class="hljs-string">&#x27;md5&#x27;</span>).<span class="hljs-title function_">update</span>(<span class="hljs-title class_">String</span>(s)).<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>);<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    md5,<br>    <span class="hljs-comment">// 处理密码的密钥</span><br>    <span class="hljs-attr">PWD_SALT</span>: <span class="hljs-string">&#x27;xd_node&#x27;</span>,<br>    <span class="hljs-comment">// 处理token的密钥</span><br>    <span class="hljs-attr">PRIVATE_KEY</span>: <span class="hljs-string">&#x27;xd_blog&#x27;</span>,<br>    <span class="hljs-comment">// token的过期时间</span><br>    <span class="hljs-attr">EXPIRESD</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span><br>&#125;<br><br><span class="hljs-comment">//解析令牌</span><br>selectUser.<span class="hljs-property">js</span><br><span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-variable constant_">PRIVATE_KEY</span>,<br>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../encrpytion/md5.js&#x27;</span>)<br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">selectUser</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> token = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">header</span>.<span class="hljs-property">authorization</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (token) &#123;<br>        <span class="hljs-keyword">let</span> jiemi = <span class="hljs-keyword">await</span> jwt.<span class="hljs-title function_">verify</span>(token, <span class="hljs-variable constant_">PRIVATE_KEY</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> data<br>        &#125;)<br>        <span class="hljs-keyword">let</span> myusername = jiemi.<span class="hljs-property">username</span><br>        <span class="hljs-keyword">return</span> myusername<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    selectUser<br>&#125;<br><br>在接口中使用，导入即可<br><span class="hljs-keyword">const</span> &#123;<br>    selectUser<br>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../util/file/selectUser.js&#x27;</span>)<br><br><span class="hljs-keyword">const</span> myusername = <span class="hljs-keyword">await</span> <span class="hljs-title function_">selectUser</span>(ctx)<br></code></pre></td></tr></table></figure><h3 id="5、关于跨域问题"><a href="#5、关于跨域问题" class="headerlink" title="5、关于跨域问题"></a>5、关于跨域问题</h3><p>在前后端交互的过程中难免会遇到跨域的问题，解决的方式有如下</p><p>1、在前端解决跨域问题</p><p>2、在后端解决跨域问题</p><p>3、通过nginx解决问题</p><p>由于各种各样的问题且知识有限的问题，在解决跨域问题是优先考虑后端解决跨域问题，即使用cors解决</p><p>在koa2中直接使用koa2-cors即可</p><p>在app.js中导入</p><p>const cors &#x3D; require(‘koa2-cors’)</p><p>app.use(cors())</p><h3 id="6、app-js文件解析"><a href="#6、app-js文件解析" class="headerlink" title="6、app.js文件解析"></a>6、app.js文件解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//整个函数的入口</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa2&quot;</span>); <span class="hljs-comment">//构造函数</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>(); <span class="hljs-comment">//声明一个实例</span><br><span class="hljs-keyword">const</span> port = <span class="hljs-number">5030</span>; <span class="hljs-comment">//端口号</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router/index.js&#x27;</span>);<br><span class="hljs-keyword">const</span> koaStatic = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-static&#x27;</span>)<br><span class="hljs-keyword">const</span> chance = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chance&#x27;</span>)<br><br><span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-variable constant_">PRIVATE_KEY</span><br>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./util/encrpytion/md5.js&#x27;</span>)<br><span class="hljs-keyword">const</span> koaBody = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-body&#x27;</span>)<br><span class="hljs-keyword">const</span> koaJWT = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-jwt&#x27;</span>)<br><br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa2-cors&#x27;</span>)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>())<br><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>)<br><br><span class="hljs-comment">//koa-static可将文件路径转换为http路径，文件起始地址需先转到根路径，然后调用根目录下的静态目录下文件目录</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">koaStatic</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>)))<br><br><span class="hljs-comment">//使用kaoJwt拦截token</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">koaJWT</span>(&#123;<br>    <span class="hljs-comment">// 解密 密钥</span><br>    <span class="hljs-attr">secret</span>: <span class="hljs-variable constant_">PRIVATE_KEY</span>,<br>    <span class="hljs-attr">algorithms</span>: [<span class="hljs-string">&quot;HS256&quot;</span>]<br>   &#125;).<span class="hljs-title function_">unless</span>(&#123;<br>    <span class="hljs-attr">path</span>: [<br>    <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    <span class="hljs-string">&#x27;/login/register&#x27;</span>,<br>    <span class="hljs-string">&#x27;/email&#x27;</span>,<br>    <span class="hljs-string">&#x27;/email/examEmail&#x27;</span>,<br>    <span class="hljs-string">&#x27;/email/forget&#x27;</span>,<br>    <span class="hljs-regexp">/^\/files\/download\/*/</span>,<br>  ] <br>  <span class="hljs-comment">//此处使用正则表达式，此处是下载的命令</span><br>  <span class="hljs-comment">//⽩名单,除了这⾥写的地址，其 他的URL都需要验证</span><br>   &#125;));<br><br>app.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-title function_">koaBody</span>(&#123;<br>        <span class="hljs-comment">// 允许上传多个文件</span><br>        <span class="hljs-attr">multipart</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">formidable</span>: &#123;<br>            <span class="hljs-comment">// 设置上传文件大小最大限制，默认2M</span><br>            <span class="hljs-attr">maxFileSize</span>: <span class="hljs-number">200</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>,<br>            <span class="hljs-comment">// 保留文件扩展名</span><br>            <span class="hljs-attr">keepExtensions</span>: <span class="hljs-literal">true</span>,<br>        &#125;<br>    &#125;)<br>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   router.routers()的作用是：启动路由</span><br><span class="hljs-comment">   router.allowedMethods()的作用是：允许任何请求(get,post,put)</span><br><span class="hljs-comment">*/</span><br>app.<span class="hljs-title function_">use</span>(router.<span class="hljs-title function_">routes</span>(), router.<span class="hljs-title function_">allowedMethods</span>())<br><span class="hljs-comment">//路由重定向</span><br><br>app.<span class="hljs-title function_">use</span>(chance)<br><br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server is running at http://localhost:<span class="hljs-subst">$&#123;port&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="三、Mysql搭建，navicat中操作"><a href="#三、Mysql搭建，navicat中操作" class="headerlink" title="三、Mysql搭建，navicat中操作"></a>三、Mysql搭建，navicat中操作</h2><h4 id="1、mysql存储emoji表情，数据添加外键"><a href="#1、mysql存储emoji表情，数据添加外键" class="headerlink" title="1、mysql存储emoji表情，数据添加外键"></a>1、mysql存储emoji表情，数据添加外键</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>、mysql可直接使用navicat创建<br><span class="hljs-number">2</span>、一个表中的数据可以为另一个表的外键，建立外键，就可实现改主表的数据，引用表的数据也跟随着一起改变，建立外键的条件，必须两个表的数据类型一样，数据编码一样，且建立时，引用的表中数值要么为空，要么填写的所有数据都可在主表中找到，也就是，在建立关系的时候主表包含引用表<br><span class="hljs-number">3</span>、在数据库中存储emoji表情时，存储的编码格式必须改为utf8mb4，因为表情的占用<span class="hljs-number">4</span>个字节<br>utf8与utf8mb4的区别：<br><span class="hljs-variable constant_">UTF</span>-<span class="hljs-number">8</span>编码中，一个英文字符占用一个字节的存储空间，一个中文（含繁体）占用三个字节的存储空间。<br><span class="hljs-title class_">UTF8MB</span>4：<span class="hljs-title class_">MySQL</span>在<span class="hljs-number">5.5</span><span class="hljs-number">.3</span>之后增加了utf8mb4的编码，mb4就是most bytes <span class="hljs-number">4</span>的意思，专门用来兼容四字节的unicode。因此可以用来存储emoji表情。<br><br>修改完数据库后，还需在后端配置连接时加上 <span class="hljs-attr">charset</span>:<span class="hljs-string">&#x27;utf8mb4&#x27;</span><br><br>dbconfig.<span class="hljs-property">js</span><br><span class="hljs-keyword">let</span> config<br><span class="hljs-comment">//数据库配置</span><br> config = &#123;<br>        <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        <span class="hljs-attr">port</span>:<span class="hljs-string">&#x27;3306&#x27;</span>,<br>        <span class="hljs-attr">user</span>:<span class="hljs-string">&#x27;root&#x27;</span>,<br>        <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;1234&#x27;</span>,<br>        <span class="hljs-attr">database</span>:<span class="hljs-string">&#x27;back_project_2&#x27;</span>,<br>        <span class="hljs-comment">//存入4字节的表情时，除了mysql改为utf8mb4,此处连接也需改为utf8mb4</span><br>        <span class="hljs-attr">charset</span>:<span class="hljs-string">&#x27;utf8mb4&#x27;</span><br>    &#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = config<br><br>正常插入有两种方式<br>有特殊字符时需使用方式<span class="hljs-number">2</span><br>方式<span class="hljs-number">1</span><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`insert into artical (username,pagename,textpage,htmlpage) values (&#x27;<span class="hljs-subst">$&#123;myusername&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;textname&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;textpage&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;htmlpage&#125;</span>&#x27;)`</span>)<br><br><span class="hljs-comment">//此处必须这么写，因为文本可能中含有单引号，方式1写法会引起mysql的报错，</span><br><span class="hljs-comment">//而下面的方式2写法直接可以不用考虑单引号及其他特殊字符引起的变化</span><br><br>方式<span class="hljs-number">2</span><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`insert into artical (username,pagename,textpage,htmlpage,comments) values (?,?,?,?,?)`</span>, [myusername, name, textpage, htmlpage, desc])<br><br>在配置连接池时，也无需过多的操作，只需加一个参数即可<br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./dbconfig&#x27;</span>)<br><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<br><br><span class="hljs-comment">//创建连接池</span><br><span class="hljs-keyword">let</span> pool =mysql.<span class="hljs-title function_">createPool</span>(config);<br><br>此处的p就是插入操作中的数组[myusername, name, textpage, htmlpage, desc]<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-params">sql,p</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <br>        pool.<span class="hljs-title function_">getConnection</span>(<span class="hljs-function">(<span class="hljs-params">err,connection</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(err)&#123;<br>                <span class="hljs-title function_">reject</span>(err)<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//事件驱动回调</span><br>            connection.<span class="hljs-title function_">query</span>(sql,p,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span>(err)&#123;<br>                    <span class="hljs-title function_">reject</span>(err)<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-title function_">resolve</span>(data)<br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">//释放连接</span><br>            connection.<span class="hljs-title function_">release</span>();<br>        &#125;<br>        &#125;)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;)<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = queryback<br></code></pre></td></tr></table></figure><h4 id="2、内连接"><a href="#2、内连接" class="headerlink" title="2、内连接"></a>2、内连接</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">基础模型<br>1、<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-string">&#x27;...&#x27;</span><br><span class="hljs-number">2</span>、<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> u <br><span class="hljs-keyword">join</span>  test t <span class="hljs-keyword">on</span> t.pagename = u.pagename <span class="hljs-keyword">where</span> <span class="hljs-string">&#x27;...&#x27;</span><br><span class="hljs-number">3</span>、<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> u <br><span class="hljs-keyword">join</span>  test t <span class="hljs-keyword">on</span> t.pagename = u.pagename<br><span class="hljs-keyword">join</span>  exam <span class="hljs-built_in">e</span> <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.pagename = <span class="hljs-built_in">e</span>.pagename<br><span class="hljs-keyword">where</span> <span class="hljs-string">&#x27;...&#x27;</span><br><span class="hljs-number">4</span>、<br><span class="hljs-keyword">select</span> 查询列表 <span class="hljs-keyword">from</span> 表<br>[<span class="hljs-keyword">where</span> 筛选条件]<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组的字段<br>[<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序的字段];<br>5、<br>数据排序 <br>升序   asc<br>降序   desc<br>6、将有同一个用户名的不同标签的表混合成只有一行，将标签内容整合成一行，类似于数组<br>例：<span class="hljs-keyword">select</span> b.pagename,GROUP_CONCAT(b.classname SEPARATOR <span class="hljs-string">&#x27;,&#x27;</span>)<br><span class="hljs-keyword">from</span> textclass b<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> b.pagename<br><br><span class="hljs-number">7</span>、混合示例<br><span class="hljs-keyword">select</span> a.pagename,a.username,a.writetime,a.comments,c.classname,d.id <span class="hljs-keyword">from</span>  artical a <br><span class="hljs-keyword">join</span> <br>(<span class="hljs-keyword">select</span> b.pagename,<br>GROUP_CONCAT(b.classname SEPARATOR <span class="hljs-string">&#x27;,&#x27;</span>) classname<br><span class="hljs-keyword">from</span> textclass b<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> b.pagename) c <br><span class="hljs-keyword">on</span> a.pagename=c.pagename <br><span class="hljs-keyword">join</span> articalcollect d <br><span class="hljs-keyword">on</span> d.pagename = c.pagename<br><span class="hljs-keyword">where</span> d.username = <span class="hljs-string">&#x27;test&#x27;</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.writetime <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3+Koa2+Mysql实战随记（一）</title>
    <link href="./2023/03/08/vue3+koa2+mysql%E5%AE%9E%E6%88%98%E9%9A%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>./2023/03/08/vue3+koa2+mysql%E5%AE%9E%E6%88%98%E9%9A%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3-Koa2-Mysql实战随记（一）"><a href="#Vue3-Koa2-Mysql实战随记（一）" class="headerlink" title="Vue3+Koa2+Mysql实战随记（一）"></a>Vue3+Koa2+Mysql实战随记（一）</h1><h2 id="一、项目创建"><a href="#一、项目创建" class="headerlink" title="一、项目创建"></a>一、项目创建</h2><h3 id="一、vue3项目创建的两种方法"><a href="#一、vue3项目创建的两种方法" class="headerlink" title="一、vue3项目创建的两种方法"></a>一、vue3项目创建的两种方法</h3><h4 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1) 使用 vue-cli 创建"></a>1) 使用 vue-cli 创建</h4><p><a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">文档</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">## 安装或者升级<br>npm install -g @vue/cli<br>## 保证 vue cli 版本在 4.5.0 以上<br>vue --version<br>## 创建项目<br>vue create my-project<br><br>运行项目一般用<br>npm run serve<br><br>此处会因为不兼容会出现bug，使用脚手架创建vue3项目启动不了，时间2021.7.21，<br>解决办法<br>打包的vue的版本3.1.3有问题<br>删掉，换成3.1.2<br>npm uninstall vue<br>npm install vue@3.1.2<br></code></pre></td></tr></table></figure><p>Please pick a preset - 选择 Manually select features<br>Check the features needed for your project - 选择上 TypeScript ，特别注意点空格是选择，点回车是下一步<br>Choose a version of Vue.js that you want to start the project with - 选择 3.x (Preview)<br>Use class-style component syntax - 直接回车<br>Use Babel alongside TypeScript - 直接回车<br>Pick a linter &#x2F; formatter config - 直接回车<br>Use history mode for router? - 直接回车<br>Pick a linter &#x2F; formatter config - 直接回车<br>Pick additional lint features - 直接回车<br>Where do you prefer placing config for Babel, ESLint, etc.? - 直接回车<br>Save this as a preset for future projects? - 直接回车</p><h4 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2) 使用 vite 创建"></a>2) 使用 vite 创建</h4><p><a href="https://v3.cn.vuejs.org/guide/installation.html">文档</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">npm init vite-app &lt;project-name&gt;<br>cd &lt;project-name&gt;<br>npm install<br>npm run dev<br></code></pre></td></tr></table></figure><ul><li>vite 是一个由原生 ESM 驱动的 Web 开发构建工具。在开发环境下基于浏览器原生 ES imports 开发，</li><li>它做到了<em><strong>本地快速开发启动</strong></em>, 在生产环境下基于 Rollup 打包。<ul><li>快速的冷启动，不需要等待打包操作；</li><li>即时的热模块更新，替换性能和模块数量的解耦让更新飞起；</li><li>真正的按需编译，不再等待整个应用编译完成，这是一个巨大的改变。</li></ul></li></ul><h3 id="二、创建koa2项目"><a href="#二、创建koa2项目" class="headerlink" title="二、创建koa2项目"></a>二、创建koa2项目</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"># 项目初始化<br>npm init -y<br><br># 安装koa2<br>npm i koa2 -S<br><br>运行项目一般用<br>node app.<span class="hljs-property">js</span><br>可通过npm i -s nodemon 配置热启动，nodemon app.<span class="hljs-property">js</span><br>如果nodemon app.<span class="hljs-property">js</span>，即使用npx nodemon app.<span class="hljs-property">js</span><br></code></pre></td></tr></table></figure><h2 id="二、项目搭建时的问题"><a href="#二、项目搭建时的问题" class="headerlink" title="二、项目搭建时的问题"></a>二、项目搭建时的问题</h2><h3 id="一、前端vue3-element-plus"><a href="#一、前端vue3-element-plus" class="headerlink" title="一、前端vue3+element-plus"></a>一、前端vue3+element-plus</h3><p><strong>由于vue3相对于vue2变化较大，组件element不兼容，故相应的推出了element-plus</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>、对于引用element-plus的组件，存在一些深层的样式不容易修改，例如el-input的输入框背景颜色，故使用deep或&gt;&gt;&gt;修改，<br>另外还需为style加上scoped,将修改的内容影响限定在该页面<br><span class="hljs-comment">/* 此处需要深层次修改，故用&gt;&gt;&gt;和/deep/，不过vue3提示用:deep() </span><br><span class="hljs-comment">   其中el-input__inner为深层的input标签的class名 */</span><br>:<span class="hljs-title function_">deep</span>().<span class="hljs-property">el</span>-input__inner &#123;<br>    background-<span class="hljs-attr">color</span>: transparent;<br>    <span class="hljs-attr">color</span>: turquoise;<br>   &#125;<br><br>衍生：span不换行盒子，div换行盒子<br>     设置<span class="hljs-attr">display</span>:flex,然后可使用弹性盒子flex，极度方便，详情可见<span class="hljs-attr">https</span>:<span class="hljs-comment">//www.runoob.com/w3cnote/flex-grammar.html</span><br>     亦可参见阮一峰的grid，<span class="hljs-attr">http</span>:<span class="hljs-comment">//www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</span><br>     还有camvas画布，<br><br><span class="hljs-number">2</span>、不存在页面或错误页面的显示，在vue2中可以直接<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;*&#x27;</span>即可，但是vue3需要<span class="hljs-string">&#x27;/:catchAll(.*)&#x27;</span><br>&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:catchAll(.*)&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Not Found&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/404.vue&#x27;</span>)<br>  &#125;<br><br><span class="hljs-number">3</span>、路由守卫<br><span class="hljs-comment">//to值访问路由，from跳转路由，next执行下一项</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//此处的isToken为得到，后端登录后生成并录入浏览器的token</span><br>  <span class="hljs-keyword">const</span> isToken = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">elementToken</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//未登录时，如果遇到以下三个页面放行，否则跳转至登录页面</span><br>  <span class="hljs-keyword">if</span>(to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/login&#x27;</span> || to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/register&#x27;</span> || to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/forget&#x27;</span>)&#123;<br>    <span class="hljs-title function_">next</span>()<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    isToken ? <span class="hljs-title function_">next</span>() : <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>  &#125;<br>  <br> <span class="hljs-number">4</span>、页面实例分析<br> &lt;template&gt;<br>&lt;div class=&quot;register-b&quot;&gt;<br>  &lt;div class=&quot;register&quot;&gt;<br>    &lt;h3&gt;注册页面&lt;/h3&gt;<br>    //以下为form表单，详情参考element-plus组件<br>    &lt;el-form<br>    //绑定数据<br>      :model=&quot;registerData&quot;<br>    //是否显示必填字段的标签旁边的红色星号<br>      hide-required-asterisk=&quot;false&quot;<br>    //输入规则<br>      :rules=&quot;rules&quot;<br>    //显示输入对错的图标<br>      status-icon<br>    //表单验证，ref 绑定控件，$refs 获取控件<br>      ref=&quot;registerForm&quot;<br>    //标签大小<br>      label-width=&quot;100px&quot;<br>      class=&quot;demo-ruleForm&quot;<br>    &gt;<br>      &lt;el-form-item prop=&quot;email&quot;&gt;<br>        &lt;el-input<br>          type=&quot;email&quot;<br>          v-model=&quot;registerData.email&quot;<br>        //输入框中的文字<br>          placeholder=&quot;请在此处输入邮箱&quot;<br>          //输入框内开头的图标<br>          prefix-icon=&quot;el-icon-message&quot;<br>        &gt;&lt;/el-input&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;el-form-item prop=&quot;code&quot;&gt;<br>        &lt;el-input<br>          type=&quot;text&quot;<br>          style=&quot;width:50%&quot;<br>          v-model=&quot;registerData.code&quot;<br>          placeholder=&quot;请在此处输入验证码&quot;<br>          prefix-icon=&quot;el-icon-s-promotion&quot;<br>        &gt;&lt;/el-input&gt;<br>        &lt;span class=&quot;jianju&quot;<br>          &gt;&lt;time-yan-zheng :email=&quot;registerData.email&quot;&gt; &lt;/time-yan-zheng<br>        &gt;&lt;/span&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item prop=&quot;username&quot;&gt;<br>        &lt;el-input<br>          type=&quot;text&quot;<br>          v-model=&quot;registerData.username&quot;<br>          placeholder=&quot;请在此处输入昵称&quot;<br>          prefix-icon=&quot;el-icon-user&quot;<br>        &gt;&lt;/el-input&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;el-form-item prop=&quot;password&quot;&gt;<br>        &lt;el-input<br>          type=&quot;password&quot;<br>          v-model=&quot;registerData.password&quot;<br>          placeholder=&quot;请在此处输入密码&quot;<br>          prefix-icon=&quot;el-icon-lock&quot;<br>    //提供密码显示的功能<br>          show-password<br>        &gt;&lt;/el-input&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;el-form-item prop=&quot;password2&quot;&gt;<br>        &lt;el-input<br>          type=&quot;password&quot;<br>          v-model=&quot;registerData.password2&quot;<br>          placeholder=&quot;请在此处输入密码&quot;<br>          prefix-icon=&quot;el-icon-lock&quot;<br>          show-password<br>        &gt;&lt;/el-input&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;div class=&quot;input-button&quot;&gt;<br>        &lt;el-button<br>          type=&quot;primary&quot;<br>          @click=&quot;submitForm(&#x27;registerForm&#x27;)&quot;<br>          class=&quot;res&quot;<br>          &gt;注册&lt;/el-button<br>        &gt;<br>      &lt;/div&gt;<br><br>      &lt;div class=&quot;input-link&quot;&gt;<br>        &lt;span class=&quot;login&quot;<br>          &gt;&lt;el-button type=&quot;text&quot; @click=&quot;topage(&#x27;/login&#x27;)&quot;<br>            &gt;用户登录&lt;/el-button<br>          &gt;&lt;/span<br>        &gt;<br>        &lt;span class=&quot;forget&quot;<br>          &gt;&lt;el-button type=&quot;text&quot; @click=&quot;topage(&#x27;/forget&#x27;)&quot;<br>            &gt;忘记密码&lt;/el-button<br>          &gt;&lt;/span<br>        &gt;<br>      &lt;/div&gt;<br>    &lt;/el-form&gt;<br>  &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; defineComponent, reactive &#125; from &quot;vue&quot;;<br>import timeYanZheng from &quot;../components/emailTime/time.vue&quot;;<br>import &#123; useRouter &#125; from &quot;vue-router&quot;;<br><br>export default defineComponent(&#123;<br>  components: &#123;<br>    timeYanZheng,<br>  &#125;,<br>  setup() &#123;<br>    const registerData = reactive(&#123;<br>      username: &quot;&quot;,<br>      password: &quot;&quot;,<br>      password2: &quot;&quot;,<br>      code: &quot;&quot;,<br>      email: &quot;&quot;,<br>    &#125;);<br>  <br>     //此处的功能实现vue3中页面的跳转，通过点击时调用函数topage，跳转页面<br>    const router = useRouter();<br>    const topage = (path) =&gt; &#123;<br>      router.push(path);<br>    &#125;;<br><br>    let validatePass = (rule, value, callback) =&gt; &#123;<br>      if (value != registerData.password) &#123;<br>        callback(new Error(&quot;两次输入的密码不一致&quot;));<br>      &#125; else &#123;<br>        callback();<br>      &#125;<br>    &#125;;<br><br>    const rules = reactive(&#123;<br>      //以下皆是输入框中的规则，可通过在数组中添加不同的对象实现，详情可见element-plus<br>      username: [<br>        &#123; required: true, message: &quot;用户名不得为空&quot;, trigger: &quot;blur&quot; &#125;,<br>        &#123; min: 3, max: 32, message: &quot;长度应在3-32之间&quot;, trigger: &quot;blur&quot; &#125;,<br>      ],<br>      password: [<br>        &#123; required: true, message: &quot;密码不得为空&quot;, trigger: &quot;blur&quot; &#125;,<br>        &#123; min: 3, max: 32, message: &quot;长度应在3-32之间&quot;, trigger: &quot;blur&quot; &#125;,<br>      ],<br>      password2: [<br>        &#123; required: true, message: &quot;密码不得为空&quot;, trigger: &quot;blur&quot; &#125;,<br>        &#123; min: 3, max: 32, message: &quot;长度应在3-32之间&quot;, trigger: &quot;blur&quot; &#125;,<br>        &#123; validator: validatePass, trigger: &quot;blur&quot; &#125;,<br>      ],<br>      code: [<br>        &#123; required: true, message: &quot;验证码不得为空&quot;, trigger: &quot;blur&quot; &#125;,<br>        &#123; min: 6, max: 6, message: &quot;长度应为6位&quot;, trigger: &quot;blur&quot; &#125;,<br>      ],<br>      email: [<br>        &#123; required: true, message: &quot;请输入邮箱地址&quot;, trigger: &quot;blur&quot; &#125;,<br>        &#123;<br>          type: &quot;email&quot;,<br>          message: &quot;请输入正确的邮箱地址&quot;,<br>          trigger: [&quot;blur&quot;, &quot;change&quot;],<br>        &#125;,<br>      ],<br>    &#125;);<br><br>    return &#123;<br>      registerData,<br>      rules,<br>      topage,<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    submitForm(formName) &#123;<br>      console.log(this.$refs[formName]);<br>        //检查表单，element-plus提供<br>      this.$refs[formName].validate((valid) =&gt; &#123;<br>        if (valid) &#123;<br>            //在写后端时，尽量返回ctx.resposes.status状态码,因为这样可直接通过element-plus在浏览器中显示效果出来，status               状态码返回的状态可在前端判判定，未成功不能进入下一个页面<br>            //通过axios访问后端，通过将第二个访问post包裹在第一个post的then里，可实现递进式访问<br>          this.$axios<br>            .post(&quot;./email/examEmail&quot;, this.registerData)<br>            .then(<br>              this.$axios<br>                .post(&quot;./login/register&quot;, this.registerData)<br>                .then((res) =&gt; &#123;<br>                  console.log(res.data);<br>                &#125;)<br>            )<br>          <br>            //成功即打印<br>            .then((res) =&gt; &#123;<br>              console.log(res.data);<br>              this.$message(&#123;<br>                type: &quot;success&quot;,<br>                message: &quot;用户注册成功&quot;,<br>              &#125;);<br>              //当无误完成后，即跳转至登录页面<br>              this.$router.push(&quot;/login&quot;);<br>            &#125;);<br>          //     console.log(res.data);<br>          //     if (res.data.code === 0) &#123;<br>          //       this.$router.push(&quot;/login&quot;);<br>          //     this.$message(&#123;<br>          //       type: &quot;success&quot;,<br>          //       message: &quot;用户注册成功&quot;,<br>          //     &#125;);<br>          //      &#125;<br>          //      else&#123;<br>          //        this.$message(&#123;<br>          //       type: &quot;error&quot;,<br>          //       message: &quot;用户注册失败&quot;,<br>          //     &#125;);<br>          //      &#125;<br>        &#125; else &#123;<br>          console.log(&quot;error submit!!&quot;);<br>          return false;<br>        &#125;<br>      &#125;);<br>    &#125;,<br>  &#125;,<br>&#125;);<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.register-b &#123;<br>  background: url(&quot;../assets/img/bg11.jpg&quot;) no-repeat center;<br>  height: 100vh;<br>  background-size: cover;<br>&#125;<br><br>.register &#123;<br>  width: 40vw;<br>  height: 70vh;<br>  background-color: rgba(17, 30, 131, 0.1);<br>  position: absolute;<br>    //通过函数，将盒子居中，推荐<br>  left: calc(50% - 40vw / 2);<br>  top: calc(50% - 70vh / 2);<br>    //flex弹性盒子的应用，两边对齐<br>  justify-content: space-between;<br>&#125;<br><br>.jianju &#123;<br>  margin-left: 1vw;<br>&#125;<br><br>h3 &#123;<br>  text-align: center;<br>&#125;<br><br>.el-input &#123;<br>  width: 80%;<br>&#125;<br><br>.input-button &#123;<br>  display: flex;<br>&#125;<br><br>/* 此处需要深层次修改，故用&gt;&gt;&gt;和/deep/，不过vue提示用:deep() */<br>:deep().el-input__inner &#123;<br>    background-color: transparent;<br>    color: turquoise;<br>   &#125; <br><br>.el-button &#123;<br>  margin: 0 auto;<br>&#125;<br><br>.input-link &#123;<br>  margin-top: 10px;<br>  display: flex;<br>  justify-content: space-between;<br>&#125;<br><br>.el-button.res &#123;<br>  width: 67%;<br>&#125;<br>.login &#123;<br>  margin-left: 4vw;<br>&#125;<br><br>.forget &#123;<br>  margin-right: 4vw;<br>&#125;<br>&lt;/style&gt;<br><br> 5、验证码倒计时组件如下：<br> <br> time.vue<br>  <br> &lt;template&gt;<br>      &lt;el-button<br>        type=&quot;primary&quot;<br>        class=&quot;yanzheng&quot;<br>        @click=&quot;getCode()&quot;<br>        :disabled=&quot;!login.canGet&quot;<br>      &gt;<br>        &lt;div&gt;<br>          &lt;span v-show=&quot;!login.canGet&quot;&gt;&#123;&#123;<br>            login.waitTime + &quot;s后重新获取&quot;<br>          &#125;&#125;&lt;/span&gt;<br>          &lt;span v-show=&quot;login.canGet&quot;&gt;获取邮箱验证码&lt;/span&gt;<br>        &lt;/div&gt;<br>      &lt;/el-button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; defineComponent &#125; from &quot;vue&quot;;<br>import timeCountdown from &quot;./time.js&quot;;<br><br>export default defineComponent(&#123;<br>  props: &#123;<br>    email: &#123;<br>      type: String,<br>      default: &#x27;&#x27;<br>    &#125;<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      registerData: &#123;<br>        yanzhengma: &quot;&quot;,<br>      &#125;,<br>      tempLogin: &#123;<br>        //定义一个临时对象<br>        canGet: true,<br>        timer: null,<br>        waitTime: 60,<br>      &#125;,<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    getCode() &#123;<br>        //由于传过来的email为单一的值，而axios传回后端的为&#123;&#125;对象类型，<br>      console.log(1, this.login);<br>      let test =&#123;<br>          email:this.email<br>      &#125;<br>      this.$axios.post(&quot;/email&quot;, test).then((res) =&gt; &#123;<br>        console.log(2, res.data);<br>        this.$message(&#123;<br>          type: &quot;success&quot;,<br>          message: &quot;验证码发送成功&quot;,<br>        &#125;);<br>      &#125;);<br><br>      //倒计时开始<br>      timeCountdown(this.login); //参数为最终对象<br>    &#125;,<br>  &#125;,<br>  computed: &#123;<br>    login() &#123;<br>      //最终对象<br>      if (!this.tempLogin.canGet) &#123;<br>        console.log(this.email);<br>        return timeCountdown(this.tempLogin);<br>      &#125; else &#123;<br>        return this.tempLogin;<br>      &#125;<br>    &#125;,<br>  &#125;,<br>&#125;);<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>.el-button.yanzheng &#123;<br>  margin-left: 1vw;<br>  width: 9vw;<br>&#125;<br><br>&lt;/style&gt;<br><br>//time.js<br><br>function timeCountdown(obj) &#123; //obj包括timer、waitTime 、canGet <br>    const TIME_COUNT = 60; //默认倒计时秒数<br><br>    if (!obj.timer) &#123;<br>        obj.waitTime = TIME_COUNT;<br>        obj.canGet = false;<br>        obj.timer = setInterval(() =&gt; &#123;<br>            if (obj.waitTime&gt;0 &amp;&amp; obj.waitTime&lt;=TIME_COUNT) &#123;<br>                obj.waitTime--;<br>            &#125;else&#123;<br>                obj.canGet = true;<br>                clearInterval(obj.timer); //清空定时器<br>                obj.timer = null;<br>            &#125;<br>        &#125;, 1000)<br>    &#125;<br>    return &#123;<br>        timer: obj.timer,<br>        canGet: obj.canGet,<br>        waitTime: obj.waitTime<br>    &#125;<br>&#125;<br><br>export default timeCountdown<br><br><br>6、axios配置文件<br><br>axios.js<br><br>import axios from &quot;axios&quot;;<br>import &#123; ElMessage &#125; from &quot;element-plus&quot;;<br><br><br>let http = axios.create(&#123;<br>  baseURL:&#x27;http://localhost:5030/&#x27;<br>&#125;)<br><br>//请求拦截<br>http.interceptors.request.use( config =&gt; &#123;<br>   if(localStorage.elementToken)&#123;<br>     config.headers.Authorization = localStorage.elementToken<br>   &#125;<br>   return config<br>&#125;)<br><br>//响应拦截<br>http.interceptors.response.use( res =&gt; &#123;<br>  return res<br>&#125;, err =&gt; &#123;<br>  console.log(err.response);<br>    //在浏览器头先生出相应的错误<br>  ElMessage.error(err.response.data.msg)<br>&#125;)<br><br>export default http<br><br>在main.js中导入axios<br><br>import axios from &#x27;./axios.js&#x27;<br>const app = createApp(App);<br>app.config.globalProperties.$axios=axios;<br><br>7、引用阿里图标写一个组件<br>&lt;template&gt;<br>  &lt;div :class=&quot;[&#x27;iconfont&#x27;, id, color]&quot; :style=&quot;&#123;fontSize: `$&#123;size&#125;px`&#125;&quot;&gt;   <br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; defineComponent &#125; from &#x27;vue&#x27;<br>export default defineComponent(&#123;<br>  props:&#123;<br>      id: &#123;<br>          type:String,<br>          default:&quot;&quot;<br>      &#125;,<br>      color: &#123;<br>          type:String,<br>          default:&quot;&quot;<br>      &#125;,<br>      size: &#123;<br>          type:[Number,String],<br>          default:40<br>      &#125;,<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br>&lt;style&gt;<br>&lt;/style&gt;<br><br>8、根据不同的页面的路径判断是否展示某一模块<br>&lt;template&gt;<br>  &lt;div class=&quot;home&quot;&gt;<br>    &lt;div class=&quot;wrapper&quot;&gt;<br>      &lt;layoutSlide icon-id=&quot;icon-wangluo&quot; icon-color=&quot;text-warning&quot; icon-size=&quot;45&quot;&gt;<br>        Welcome to LongQue<br>      &lt;/layoutSlide&gt;<br>      &lt;div :class=&quot;(`$&#123;data&#125;`)&quot; style=&quot;max-height: 90vh&quot;&gt;<br>        &lt;layoutHead&gt;<br>          &lt;template #title&gt;&#123;&#123;title&#125;&#125;&lt;/template&gt;<br>          &lt;template #dea&gt;&#123;&#123;dea&#125;&#125;&lt;/template&gt;<br>          &lt;template #good&gt;您已被赞&#123;&#123;praise&#125;&#125;次！&lt;/template&gt;<br>        &lt;/layoutHead&gt;<br>        &lt;transition enter-active-class=&quot;animate__animated animate__zoomIn&quot;&gt;<br>          &lt;router-view&gt;&lt;/router-view&gt;<br>        &lt;/transition&gt;<br>      &lt;/div&gt;<br>     &lt;userProfile :src=&quot;src&quot; /&gt;<br>    &lt;/div&gt;<br><br>    &lt;layout-footer&gt;&lt;/layout-footer&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>import &#123; <br>         defineComponent,<br>         &#125; from &#x27;vue&#x27;;<br>import userProfile from &#x27;../components/home/userProfile.vue&#x27;<br>import layoutSlide from &#x27;../components/home/layout/layoutSlide.vue&#x27;<br>import layoutHead from &#x27;../components/home/layout/layoutHead.vue&#x27;<br>import &#123; computed&#125; from &#x27;vue&#x27;<br>import &#123; useRouter &#125; from &#x27;vue-router&#x27;;<br>import &#123; praise &#125; from &#x27;../components/introduction/sendData.js&#x27;<br>import LayoutFooter from &#x27;../components/home/layout/layoutFooter.vue&#x27;;<br><br>export default defineComponent(&#123;<br>  name: &#x27;Home&#x27;,<br>  setup() &#123;<br>    const router = useRouter();<br>    const title = computed(() =&gt; &#123;<br>      const &#123;path &#125; = router.currentRoute.value;<br>       //如果是根目录，即展示I&#x27;m，否则不展示<br>      return path === &quot;/&quot; ? &quot;I&#x27;m&quot; : &quot;&quot;;<br>    &#125;)<br>    const dea = computed(() =&gt; &#123;<br>      const &#123;path, name &#125; = router.currentRoute.value;<br>      return path === &quot;/&quot; ? &quot;Mark&quot; : name;<br>    &#125;)<br><br>    const data = computed(() =&gt; &#123;<br>      const &#123; path &#125; = router.currentRoute.value;<br>        //如果是根目录，即宽度为100%，否则宽度为100，且有下拉条<br>      return path === &quot;/&quot; ? &quot;w-100&quot; : &quot;w-100 pre-scrollable&quot;;<br>    &#125;);<br>   <br>     return&#123;<br>       src: require(&#x27;../assets/img/p1.jpg&#x27;),<br>       title,<br>       dea,<br>       praise,<br>       data<br>     &#125;<br>  &#125;,<br>  components: &#123;<br>    userProfile,<br>    layoutSlide,<br>    layoutHead,<br>    LayoutFooter<br>  &#125;,<br><br>&#125;);<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>.home &#123;<br>  background: url(&quot;../assets/img/bg.jpg&quot;) no-repeat center;<br>  background-attachment: scroll;<br>  height: 100vh;<br>  background-size: cover;<br>&#125;<br><br>.wrapper &#123;<br>  width: 90vw;<br>  height: 90vh;<br>  background-color: rgb(44,48,80,0.1);<br>  position: absolute;<br>  left:calc(50% - 90vw / 2);<br>  top:calc(50% - 90vh /2);<br>  display: flex;<br>  justify-content: space-between;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><h3 id="二、后端koa2"><a href="#二、后端koa2" class="headerlink" title="二、后端koa2"></a>二、后端koa2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>、mysql数据库连接<br>config.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">let</span> config<br><span class="hljs-comment">//数据库配置</span><br> config = &#123;<br>        <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        <span class="hljs-attr">port</span>:<span class="hljs-string">&#x27;3306&#x27;</span>,<br>        <span class="hljs-attr">user</span>:<span class="hljs-string">&#x27;root&#x27;</span>,<br>        <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;1234&#x27;</span>,<br>        <span class="hljs-attr">database</span>:<span class="hljs-string">&#x27;back_project_2&#x27;</span><br>    &#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = config<br><br>db.<span class="hljs-property">js</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./config&#x27;</span>)<br><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<br><br><span class="hljs-comment">//创建连接池</span><br><span class="hljs-keyword">let</span> pool =mysql.<span class="hljs-title function_">createPool</span>(config);<br><br><span class="hljs-comment">//基础</span><br><span class="hljs-comment">// //对数据库进行增删改查操作的基础</span><br><span class="hljs-comment">// function query(sql,callback)&#123;</span><br><span class="hljs-comment">//     //创建连接</span><br><span class="hljs-comment">//     pool.getConnection(function(err,connection)&#123;</span><br><span class="hljs-comment">//         connection.query(sql,function(err,rows)&#123;</span><br><span class="hljs-comment">//             //表示连接成功时有错误即抛出错误，没有错误即返回取得的数据</span><br><span class="hljs-comment">//             callback(err,rows)</span><br><span class="hljs-comment">//             //中断连接</span><br><span class="hljs-comment">//             connection.release()</span><br><span class="hljs-comment">//         &#125;)</span><br><span class="hljs-comment">//     &#125;)</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">//直接使用含回调的即可</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-params">sql</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <br>        pool.<span class="hljs-title function_">getConnection</span>(<span class="hljs-function">(<span class="hljs-params">err,connection</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(err)&#123;<br>                <span class="hljs-title function_">reject</span>(err)<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//事件驱动回调</span><br>            connection.<span class="hljs-title function_">query</span>(sql,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span>(err)&#123;<br>                    <span class="hljs-title function_">reject</span>(err)<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-title function_">resolve</span>(data)<br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">//释放连接</span><br>            connection.<span class="hljs-title function_">release</span>();<br>        &#125;<br>        &#125;)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;)<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = queryback<br><br><span class="hljs-number">2</span>、验证码发送<br><span class="hljs-comment">//验证码配置</span><br><span class="hljs-keyword">const</span> nodemailer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;nodemailer&#x27;</span>)<br><span class="hljs-keyword">const</span> smtpTransport = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;nodemailer-smtp-transport&#x27;</span>)<br><br><span class="hljs-keyword">const</span> transport = nodemailer.<span class="hljs-title function_">createTransport</span>(<span class="hljs-title function_">smtpTransport</span>(&#123;<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;smtp.163.com&#x27;</span>, <span class="hljs-comment">// 服务 由于我用的163邮箱</span><br>    <span class="hljs-attr">port</span>: <span class="hljs-number">465</span>, <span class="hljs-comment">// smtp端口 默认无需改动</span><br>    <span class="hljs-attr">secure</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">auth</span>: &#123;<br>      <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;******@163.com&#x27;</span>, <span class="hljs-comment">// 邮箱用户名</span><br>      <span class="hljs-attr">pass</span>: <span class="hljs-string">&#x27;**********&#x27;</span> <span class="hljs-comment">// SMTP授权码  //邮箱设置中开启</span><br>    &#125;<br>&#125;));<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">randomFns</span>=(<span class="hljs-params"></span>)=&gt; &#123; <span class="hljs-comment">// 生成6位随机数</span><br>    <span class="hljs-keyword">let</span> code = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i= <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>        code += <span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*<span class="hljs-number">10</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> code <br>&#125;<br> <br><span class="hljs-keyword">const</span> regEmail=<span class="hljs-regexp">/^([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+\.[a-zA-Z]&#123;2,3&#125;$/</span> <span class="hljs-comment">//验证邮箱正则</span><br><br> <span class="hljs-keyword">const</span> <span class="hljs-title function_">emailModel</span> = <span class="hljs-keyword">async</span>(<span class="hljs-params">EMAIL,code,call</span>) =&gt; &#123;<br>    transport.<span class="hljs-title function_">sendMail</span>(&#123;<br>      <span class="hljs-attr">from</span>: <span class="hljs-string">&#x27;******@163.com&#x27;</span>, <span class="hljs-comment">// 发件邮箱，须根上面的邮箱用户名一样</span><br>      <span class="hljs-attr">to</span>: <span class="hljs-variable constant_">EMAIL</span>, <span class="hljs-comment">// 收件列表</span><br>      <span class="hljs-attr">subject</span>: <span class="hljs-string">&#x27;验证你的电子邮件&#x27;</span>, <span class="hljs-comment">// 标题</span><br>      <span class="hljs-attr">html</span>: <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;p&gt;你好！&lt;/p&gt;</span><br><span class="hljs-string">      &lt;p&gt;您正在注册龙雀社区账号&lt;/p&gt;</span><br><span class="hljs-string">      &lt;p&gt;你的验证码是：&lt;strong style=&quot;color: #ff4e2a;&quot;&gt;<span class="hljs-subst">$&#123;code&#125;</span>&lt;/strong&gt;&lt;/p&gt;</span><br><span class="hljs-string">      &lt;p&gt;***该验证码5分钟内有效***&lt;/p&gt;`</span> <span class="hljs-comment">// html 内容</span><br>    &#125;, <br>    <span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(error)&#123;<br>       call (<span class="hljs-literal">false</span>)<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>       call (<span class="hljs-literal">true</span>)<br>      &#125;<br>      <span class="hljs-comment">// console.log(1,error)</span><br>      <span class="hljs-comment">// console.log(2,data)</span><br>      transport.<span class="hljs-title function_">close</span>(); <span class="hljs-comment">// 如果没用，关闭连接池</span><br>    &#125;)<br>    <span class="hljs-comment">//....验证码发送后的相关工作 </span><br>  &#125;<br><br>  <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>      regEmail,<br>      randomFns,<br>      emailModel<br>  &#125;<br><br>调用验证码<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Router</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-router&#x27;</span>);<br><span class="hljs-keyword">const</span> queryback = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../util/db/db.js&#x27;</span>)<br><span class="hljs-keyword">const</span> email = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();<br><br><span class="hljs-keyword">const</span> &#123;<br>    regEmail,<br>    emailModel,<br>    randomFns<br>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../util/email/emailConfig&#x27;</span>)<br><br><br><span class="hljs-comment">//注册验证码</span><br>email.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title class_">Email</span> = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>.<span class="hljs-property">email</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Email</span>);<br>    <span class="hljs-keyword">let</span> find = <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`select email from user where email = &#x27;<span class="hljs-subst">$&#123;Email&#125;</span>&#x27;`</span>)<br>    <span class="hljs-comment">// console.log(find);</span><br>    <span class="hljs-keyword">if</span> (!find || find.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> code = <span class="hljs-title function_">randomFns</span>()<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(code);<br>        <span class="hljs-keyword">if</span> (regEmail.<span class="hljs-title function_">test</span>(<span class="hljs-title class_">Email</span>)) &#123;<br>            <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`insert into emails (email,code) values (&#x27;<span class="hljs-subst">$&#123;Email&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;code&#125;</span>&#x27;)`</span>)<br>          <br>            <span class="hljs-comment">//重点，化为异步之后方可实现返回验证码发送之后的结果</span><br>            <span class="hljs-comment">//await是异步的标志，new promise是异步的施行</span><br>            <span class="hljs-keyword">let</span> dd = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-title function_">emailModel</span>(<span class="hljs-title class_">Email</span>, code, <span class="hljs-function">(<span class="hljs-params">call</span>) =&gt;</span> &#123;<br>                    <span class="hljs-title function_">resolve</span>(call)<br>                &#125;)<br>            &#125;)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dd)<br>            <span class="hljs-keyword">if</span> (dd === <span class="hljs-literal">true</span>)<br>               &#123;<br>                   ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">200</span><br>                   ctx.<span class="hljs-property">body</span> = &#123;<br>                       <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>                       <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;验证码已发送&#x27;</span><br>                   &#125;<br>                    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">async</span> () =&gt; &#123; <span class="hljs-comment">//5分钟后失效</span><br>                    <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`delete from emails where email = &#x27;<span class="hljs-subst">$&#123;Email&#125;</span>&#x27;`</span>)<br>                &#125;, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">5</span>)<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">200</span><br>                ctx.<span class="hljs-property">body</span> = &#123;<br>                    <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>                    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;验证码发送失败，请稍后再试&#x27;</span><br>                &#125;<br>               &#125;<br>             <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// assert(false,422,&#x27;请输入正确的邮箱格式！&#x27;)</span><br>            ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">422</span><br>            ctx.<span class="hljs-property">body</span> = &#123;<br>                <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>                <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;请输入正确的邮箱格式&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">400</span><br>        ctx.<span class="hljs-property">body</span> = &#123;<br>            <span class="hljs-attr">code</span>: -<span class="hljs-number">1</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;该邮箱已注册&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">//校验验证码</span><br>email.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/examEmail&#x27;</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> email = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>.<span class="hljs-property">email</span><br>    <span class="hljs-keyword">const</span> code = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>.<span class="hljs-property">code</span><br>    <span class="hljs-keyword">const</span> examE = <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`select * from emails where email = &#x27;<span class="hljs-subst">$&#123;email&#125;</span>&#x27; and code = &#x27;<span class="hljs-subst">$&#123;code&#125;</span>&#x27;`</span>)<br>    <span class="hljs-keyword">if</span>(!examE || examE.<span class="hljs-property">length</span> ===<span class="hljs-number">0</span>)&#123;<br>        ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">400</span><br>                ctx.<span class="hljs-property">body</span> = &#123;<br>                    <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>                    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;验证码错误，请稍后再试&#x27;</span><br>                &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">200</span><br>                ctx.<span class="hljs-property">body</span> = &#123;<br>                    <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>                    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;验证码填写正确&#x27;</span><br>                &#125;<br>    &#125;<br>&#125;)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = email;<br><br><span class="hljs-number">3</span>、加密、解密<br>配置md5.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">md5</span>(<span class="hljs-params">s</span>)&#123;<br>  <span class="hljs-comment">// 给密码加密</span><br>    <span class="hljs-comment">//注意参数需要为string类型，否则会报错</span><br>    <span class="hljs-keyword">return</span> crypto.<span class="hljs-title function_">createHash</span>(<span class="hljs-string">&#x27;md5&#x27;</span>).<span class="hljs-title function_">update</span>(<span class="hljs-title class_">String</span>(s)).<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>);<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    md5,<br>    <span class="hljs-comment">// 处理密码的密钥</span><br>    <span class="hljs-attr">PWD_SALT</span>:<span class="hljs-string">&#x27;xd_node&#x27;</span>,<br>    <span class="hljs-comment">// 处理token的密钥</span><br>    <span class="hljs-attr">PRIVATE_KEY</span>:<span class="hljs-string">&#x27;xd_blog&#x27;</span>,<br>    <span class="hljs-comment">// token的过期时间</span><br>    <span class="hljs-attr">EXPIRESD</span>:<span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">24</span><br>&#125;<br><br>login.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Router</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-router&#x27;</span>);<br><span class="hljs-keyword">const</span> queryback = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../util/db/db.js&#x27;</span>)<br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();<br><br><span class="hljs-keyword">const</span> &#123;<br>    md5,<br>    <span class="hljs-variable constant_">PWD_SALT</span>,<br>    <span class="hljs-variable constant_">PRIVATE_KEY</span>,<br>    <span class="hljs-variable constant_">EXPIRESD</span><br>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../util/encrpytion/md5.js&#x27;</span>)<br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br><br><span class="hljs-comment">//注册接口</span><br>login.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/register&#x27;</span>, <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> myusername = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>.<span class="hljs-property">username</span><br>    <span class="hljs-keyword">let</span> mypwd = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>.<span class="hljs-property">password</span><br>    <span class="hljs-keyword">let</span> myemail = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>.<span class="hljs-property">email</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myusername, mypwd, myemail);<br>    <span class="hljs-comment">// 查询有无相同的用户名</span><br>    <span class="hljs-keyword">let</span> regis = <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`select * from user where username = &#x27;<span class="hljs-subst">$&#123;myusername&#125;</span>&#x27;`</span>)<br>    <span class="hljs-comment">// 用户名不存在</span><br>    <span class="hljs-keyword">if</span> (!regis || regis.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 调用加密方法给密码加密</span><br>        mypwd = <span class="hljs-title function_">md5</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;mypwd&#125;</span><span class="hljs-subst">$&#123;PWD_SALT&#125;</span>`</span>)<br>        <span class="hljs-comment">// 然后再插入到数据库</span><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`insert into user (username, password, email) values (&#x27;<span class="hljs-subst">$&#123;myusername&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;mypwd&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;myemail&#125;</span>&#x27;)`</span>)<br>        ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">200</span><br>        ctx.<span class="hljs-property">body</span> = &#123;<br>            <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;注册成功！&quot;</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">400</span><br>        ctx.<span class="hljs-property">body</span> = &#123;<br>            <span class="hljs-attr">code</span>: -<span class="hljs-number">1</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;账号已存在，请重新注册！&quot;</span><br>        &#125;<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">//更新密码</span><br>login.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/forget&#x27;</span>, <span class="hljs-title function_">async</span>(ctx) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> mypwd = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>.<span class="hljs-property">password</span><br>    <span class="hljs-keyword">let</span> myemail = ctx .<span class="hljs-property">request</span>.<span class="hljs-property">body</span>.<span class="hljs-property">email</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mypwd, myemail);<br>    <span class="hljs-keyword">let</span> regis = <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`select * from user where email = &#x27;<span class="hljs-subst">$&#123;myemail&#125;</span>&#x27;`</span>)<br>    <span class="hljs-comment">// 邮箱不存在</span><br>    <span class="hljs-keyword">if</span> (!regis || regis.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">400</span><br>        ctx.<span class="hljs-property">body</span> = &#123;<br>            <span class="hljs-attr">code</span>: -<span class="hljs-number">1</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;邮箱未注册，请先注册！&quot;</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 调用加密方法给密码加密</span><br>        mypwd = <span class="hljs-title function_">md5</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;mypwd&#125;</span><span class="hljs-subst">$&#123;PWD_SALT&#125;</span>`</span>)<br>        <span class="hljs-comment">// 然后再插入到数据库</span><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`update user set password = &#x27;<span class="hljs-subst">$&#123;mypwd&#125;</span>&#x27; where email = &#x27;<span class="hljs-subst">$&#123;myemail&#125;</span>&#x27;`</span>)<br>        ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">200</span><br>        ctx.<span class="hljs-property">body</span> = &#123;<br>            <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;修改成功！&quot;</span><br>        &#125;<br>      <br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">//登录接口</span><br>login.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> myusername = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>.<span class="hljs-property">username</span><br>    <span class="hljs-keyword">let</span> mypwd = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>.<span class="hljs-property">password</span><br>    <span class="hljs-keyword">let</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`select username,email from user where username = &#x27;<span class="hljs-subst">$&#123;myusername&#125;</span>&#x27; or email = &#x27;<span class="hljs-subst">$&#123;myusername&#125;</span>&#x27;`</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myusername, mypwd);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<br>    <span class="hljs-keyword">if</span> (!user || user.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//用户名不存在</span><br>        <span class="hljs-comment">//返回时必须返回status,status状态码可与前端element-ui中的form表单一起使用，可以判断</span><br>       ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">400</span><br>        ctx.<span class="hljs-property">body</span> = &#123;<br>            <span class="hljs-attr">code</span>: -<span class="hljs-number">1</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;该账号不存在&#x27;</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 调用加密方法给密码加密</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myusername,mypwd);<br>        mypwd = <span class="hljs-title function_">md5</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;mypwd&#125;</span><span class="hljs-subst">$&#123;PWD_SALT&#125;</span>`</span>)<br>        <span class="hljs-comment">// 把加密过后的密码以及用户名 和 数据库的数据  匹配</span><br>        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`select * from user where username = &#x27;<span class="hljs-subst">$&#123;myusername&#125;</span>&#x27; or email = &#x27;<span class="hljs-subst">$&#123;myusername&#125;</span>&#x27; and password = &#x27;<span class="hljs-subst">$&#123;mypwd&#125;</span>&#x27;`</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>        <span class="hljs-keyword">if</span> (!result || result.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>            ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">404</span><br>            ctx.<span class="hljs-property">body</span> = &#123;<br>                <span class="hljs-attr">code</span>: -<span class="hljs-number">1</span>,<br>                <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;账号或密码不正确&#x27;</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果该结果存在说明登录成功，则生成token</span><br>            <span class="hljs-keyword">let</span> token = jwt.<span class="hljs-title function_">sign</span>(&#123;<br>                myusername<br>            &#125;, <span class="hljs-variable constant_">PRIVATE_KEY</span>, &#123;<br>                <span class="hljs-attr">expiresIn</span>: <span class="hljs-variable constant_">EXPIRESD</span><br>            &#125;)<br>            ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">200</span><br>            ctx.<span class="hljs-property">body</span> = &#123;<br>                <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>                <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;登录成功&#x27;</span>,<br>                <span class="hljs-attr">token</span>: token<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 获取用户信息</span><br>login.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/info&#x27;</span>, <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>    <span class="hljs-comment">// 这个req是经过了 koaJwt拦截token 后得到的对象  req.user可得到解密后的token信息</span><br>    <span class="hljs-comment">// console.log(ctx.request.body.user);</span><br>    <span class="hljs-keyword">let</span> token = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">header</span>.<span class="hljs-property">authorization</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>];<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(token);<br>    <span class="hljs-keyword">if</span> (token) &#123;<br>        <span class="hljs-keyword">let</span> jiemi = <span class="hljs-keyword">await</span> jwt.<span class="hljs-title function_">verify</span>(token, <span class="hljs-variable constant_">PRIVATE_KEY</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>            <span class="hljs-keyword">return</span> data<br>        &#125;)<br>        <span class="hljs-keyword">let</span> myusername = jiemi.<span class="hljs-property">myusername</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myusername);<br>        <span class="hljs-keyword">let</span> userinfo = <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryback</span>(<span class="hljs-string">`select test from user where username = &#x27;<span class="hljs-subst">$&#123;myusername&#125;</span>&#x27;`</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userinfo);<br>        ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">200</span><br>        ctx.<span class="hljs-property">body</span> = &#123;<br>            <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;成功&#x27;</span>,<br>            <span class="hljs-attr">data</span>: userinfo<br>        &#125;<br>    &#125;<br>&#125;)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = login;<br><br><span class="hljs-number">4</span>、在前端中已经通过判定生成的token进行放行(可设置直接放行)，在后端中也需在app.<span class="hljs-property">js</span>中设置放行<br><br><span class="hljs-comment">//整个函数的入口</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa2&quot;</span>);  <span class="hljs-comment">//构造函数</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();   <span class="hljs-comment">//声明一个实例</span><br><span class="hljs-keyword">const</span> port = <span class="hljs-number">5030</span>;   <span class="hljs-comment">//端口号</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../router/index.js&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123;<span class="hljs-variable constant_">PRIVATE_KEY</span>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../util/encrpytion/md5.js&#x27;</span>)<br><span class="hljs-keyword">const</span> koaBody = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-body&#x27;</span>)<br><span class="hljs-keyword">const</span> koaJWT = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-jwt&#x27;</span>)<br><br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa2-cors&#x27;</span>)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>())<br><br><span class="hljs-comment">// 使用kaoJwt拦截token</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">koaJWT</span>(&#123;<br>    <span class="hljs-comment">// 解密 密钥</span><br>    <span class="hljs-attr">secret</span>: <span class="hljs-variable constant_">PRIVATE_KEY</span>,<br>    <span class="hljs-attr">algorithms</span>: [<span class="hljs-string">&quot;HS256&quot;</span>]<br>   &#125;).<span class="hljs-title function_">unless</span>(&#123;<br>    <span class="hljs-attr">path</span>: [<br>    <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-string">&#x27;/list&#x27;</span>,<br>    <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    <span class="hljs-string">&#x27;/login/register&#x27;</span>,<br>    <span class="hljs-string">&#x27;/email&#x27;</span>,<br>    <span class="hljs-string">&#x27;/email/examEmail&#x27;</span>,<br>    <span class="hljs-string">&#x27;/email/forget&#x27;</span>,<br>  <br>  ] <span class="hljs-comment">//⽩名单,除了这⾥写的地址，其 他的URL都需要验证</span><br>   &#125;));<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">koaBody</span>());<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   router.routers()的作用是：启动路由</span><br><span class="hljs-comment">   router.allowedMethods()的作用是：允许任何请求(get,post,put)</span><br><span class="hljs-comment">*/</span><br>app.<span class="hljs-title function_">use</span>(router.<span class="hljs-title function_">routes</span>(),router.<span class="hljs-title function_">allowedMethods</span>())<br><span class="hljs-comment">//路由重定向</span><br><br><br><span class="hljs-comment">//调用中间件</span><br><span class="hljs-comment">// app.use( async (ctx)=&gt;&#123;</span><br><span class="hljs-comment">//    //返回数据给页面 ctx.response.body=&quot;&quot;</span><br><span class="hljs-comment">//    ctx.response.body = &quot;Hello,Koa&quot;;</span><br><span class="hljs-comment">// &#125;)</span><br><br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server is running at http://localhost:<span class="hljs-subst">$&#123;port&#125;</span>`</span>)<br>&#125;)<br><br><span class="hljs-number">5</span>、多层路由<br>index.<span class="hljs-property">js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Router</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-router&#x27;</span>);<br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();<br><br><span class="hljs-keyword">const</span> login =<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./login.js&#x27;</span>)<br><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/login&#x27;</span>,login.<span class="hljs-title function_">routes</span>(),login.<span class="hljs-title function_">allowedMethods</span>());<br><br><span class="hljs-comment">//路由重定向</span><br><span class="hljs-comment">//修改此处重定向时，需要将当前初始页填入第一个，将修改的的填入第二个，方可成功修改，原因未知</span><br>router.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/home&#x27;</span>,<span class="hljs-string">&#x27;/list&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><p>在结合Vue3+Element-plus+mysql开发中，后端最好返回如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">ctx.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> = <span class="hljs-number">400</span><br>        ctx.<span class="hljs-property">body</span> = &#123;<br>            <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;成功&#x27;</span>,<br>            <span class="hljs-attr">data</span>: userinfo<br>        &#125;<br></code></pre></td></tr></table></figure><p>status状态码返回的状态码可在前端判判定，未成功不能进入下一个页面</p><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV1oK4y147t8">b站视频1，进主页查看所有</a></p><p><a href="https://www.bilibili.com/video/BV1dz4y1X79Z">b站视频2</a></p><p><a href="http://codesohigh.com/subject/koa2/koa2.html">koa2文档</a></p>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
